<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Language Syntax</TITLE>
<META NAME="description" CONTENT="Language Syntax">
<META NAME="keywords" CONTENT="OQL">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="OQL.css">

<LINK REL="next" HREF="node8.html">
<LINK REL="previous" HREF="node6.html">
<LINK REL="up" HREF="node2.html">
<LINK REL="next" HREF="node8.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html517"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html513"
  HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html507"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html515"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html518"
  HREF="node8.html">Quick Reference Manual</A>
<B> Up:</B> <A NAME="tex2html514"
  HREF="node2.html">The Object Query Language</A>
<B> Previous:</B> <A NAME="tex2html508"
  HREF="node6.html">Language Concepts</A>
 &nbsp; <B>  <A NAME="tex2html516"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html519"
  HREF="node7.html#SECTION00251000000000000000">Terminal Atom Syntax</A>
<UL>
<LI><A NAME="tex2html520"
  HREF="node7.html#SECTION00251100000000000000">Integer Atom</A>
<LI><A NAME="tex2html521"
  HREF="node7.html#SECTION00251200000000000000">Float Atom</A>
<LI><A NAME="tex2html522"
  HREF="node7.html#SECTION00251300000000000000">String Atom</A>
<LI><A NAME="tex2html523"
  HREF="node7.html#SECTION00251400000000000000">Char Atom</A>
<LI><A NAME="tex2html524"
  HREF="node7.html#SECTION00251500000000000000">Boolean Atom</A>
<LI><A NAME="tex2html525"
  HREF="node7.html#SECTION00251600000000000000">Identifier Atom</A>
<LI><A NAME="tex2html526"
  HREF="node7.html#SECTION00251700000000000000">Oid Atom</A>
<LI><A NAME="tex2html527"
  HREF="node7.html#SECTION00251800000000000000">Object Atom</A>
<LI><A NAME="tex2html528"
  HREF="node7.html#SECTION00251900000000000000">Null Atom</A>
<LI><A NAME="tex2html529"
  HREF="node7.html#SECTION002511000000000000000">Nil Atom</A>
</UL>
<BR>
<LI><A NAME="tex2html530"
  HREF="node7.html#SECTION00252000000000000000">Non Terminal Atom Production</A>
<UL>
<LI><A NAME="tex2html531"
  HREF="node7.html#SECTION00252100000000000000">List, Set, Bag and Array Atoms</A>
<LI><A NAME="tex2html532"
  HREF="node7.html#SECTION00252200000000000000">Struct Atom</A>
</UL>
<BR>
<LI><A NAME="tex2html533"
  HREF="node7.html#SECTION00253000000000000000">Keywords</A>
<LI><A NAME="tex2html534"
  HREF="node7.html#SECTION00254000000000000000">Comments</A>
<LI><A NAME="tex2html535"
  HREF="node7.html#SECTION00255000000000000000">Statements</A>
<LI><A NAME="tex2html536"
  HREF="node7.html#SECTION00256000000000000000">Expression Statements</A>
<LI><A NAME="tex2html537"
  HREF="node7.html#SECTION00257000000000000000">Atomic Literal Expressions</A>
<LI><A NAME="tex2html538"
  HREF="node7.html#SECTION00258000000000000000">Arithmetic Expressions</A>
<UL>
<LI><A NAME="tex2html539"
  HREF="node7.html#SECTION00258100000000000000">Additive Expression</A>
<LI><A NAME="tex2html540"
  HREF="node7.html#SECTION00258200000000000000">Multiplicative, Division and Minus Expressions</A>
<LI><A NAME="tex2html541"
  HREF="node7.html#SECTION00258300000000000000">Shift, Mod, And, Or, XOr Expressions</A>
<LI><A NAME="tex2html542"
  HREF="node7.html#SECTION00258400000000000000">Sign Expressions</A>
<LI><A NAME="tex2html543"
  HREF="node7.html#SECTION00258500000000000000">Complement Expressions</A>
</UL>
<BR>
<LI><A NAME="tex2html544"
  HREF="node7.html#SECTION00259000000000000000">Assignment Expressions</A>
<LI><A NAME="tex2html545"
  HREF="node7.html#SECTION002510000000000000000">Auto Increment &amp; Decrement Expressions</A>
<LI><A NAME="tex2html546"
  HREF="node7.html#SECTION002511000000000000000">Comparison Expressions</A>
<UL>
<LI><A NAME="tex2html547"
  HREF="node7.html#SECTION002511100000000000000">Equal and NotEqual Expressions</A>
<LI><A NAME="tex2html548"
  HREF="node7.html#SECTION002511200000000000000">Less and Greater Expressions</A>
<LI><A NAME="tex2html549"
  HREF="node7.html#SECTION002511300000000000000">Regular Expression Operators</A>
</UL>
<BR>
<LI><A NAME="tex2html550"
  HREF="node7.html#SECTION002512000000000000000">Logical Expressions</A>
<LI><A NAME="tex2html551"
  HREF="node7.html#SECTION002513000000000000000">Conditional Expression</A>
<LI><A NAME="tex2html552"
  HREF="node7.html#SECTION002514000000000000000">Expression Sequences</A>
<LI><A NAME="tex2html553"
  HREF="node7.html#SECTION002515000000000000000">Array Deferencing</A>
<UL>
<LI><A NAME="tex2html554"
  HREF="node7.html#SECTION002515100000000000000">Single Deferencing</A>
<LI><A NAME="tex2html555"
  HREF="node7.html#SECTION002515200000000000000">Range Deferencing</A>
</UL>
<BR>
<LI><A NAME="tex2html556"
  HREF="node7.html#SECTION002516000000000000000">Identifier Expressions</A>
<UL>
<LI><A NAME="tex2html557"
  HREF="node7.html#SECTION002516100000000000000"><TT>::</TT> Operator</A>
<LI><A NAME="tex2html558"
  HREF="node7.html#SECTION002516200000000000000"><TT>isset</TT> Operator</A>
<LI><A NAME="tex2html559"
  HREF="node7.html#SECTION002516300000000000000"><TT>unset</TT> Operator</A>
<LI><A NAME="tex2html560"
  HREF="node7.html#SECTION002516400000000000000"><TT>refof</TT> Operator</A>
<LI><A NAME="tex2html561"
  HREF="node7.html#SECTION002516500000000000000"><TT>valof</TT> Operator</A>
<LI><A NAME="tex2html562"
  HREF="node7.html#SECTION002516600000000000000"><TT>scopeof</TT> Operator</A>
<LI><A NAME="tex2html563"
  HREF="node7.html#SECTION002516700000000000000"><TT>push</TT> Operator</A>
<LI><A NAME="tex2html564"
  HREF="node7.html#SECTION002516800000000000000"><TT>pop</TT> Operator</A>
</UL>
<BR>
<LI><A NAME="tex2html565"
  HREF="node7.html#SECTION002517000000000000000">Path Expressions</A>
<LI><A NAME="tex2html566"
  HREF="node7.html#SECTION002518000000000000000">Function Call</A>
<LI><A NAME="tex2html567"
  HREF="node7.html#SECTION002519000000000000000">Method Invocation</A>
<UL>
<LI><A NAME="tex2html568"
  HREF="node7.html#SECTION002519100000000000000">Instance Method Invocation</A>
<LI><A NAME="tex2html569"
  HREF="node7.html#SECTION002519200000000000000">Class Method Invocation</A>
</UL>
<BR>
<LI><A NAME="tex2html570"
  HREF="node7.html#SECTION002520000000000000000">Eval/Unval Operators</A>
<UL>
<LI><A NAME="tex2html571"
  HREF="node7.html#SECTION002520100000000000000"><TT>eval</TT> Operator</A>
<LI><A NAME="tex2html572"
  HREF="node7.html#SECTION002520200000000000000"><TT>unval</TT> Operator</A>
</UL>
<BR>
<LI><A NAME="tex2html573"
  HREF="node7.html#SECTION002521000000000000000">Set Expressions</A>
<UL>
<LI><A NAME="tex2html574"
  HREF="node7.html#SECTION002521100000000000000"><TT>union</TT> Operator</A>
<LI><A NAME="tex2html575"
  HREF="node7.html#SECTION002521200000000000000"><TT>intersect</TT> Operator</A>
<LI><A NAME="tex2html576"
  HREF="node7.html#SECTION002521300000000000000"><TT>except</TT> Operator</A>
<LI><A NAME="tex2html577"
  HREF="node7.html#SECTION002521400000000000000">Inclusion Operators</A>
</UL>
<BR>
<LI><A NAME="tex2html578"
  HREF="node7.html#SECTION002522000000000000000">Object Creation</A>
<LI><A NAME="tex2html579"
  HREF="node7.html#SECTION002523000000000000000">Object Deletion</A>
<LI><A NAME="tex2html580"
  HREF="node7.html#SECTION002524000000000000000">Collection Expressions</A>
<UL>
<LI><A NAME="tex2html581"
  HREF="node7.html#SECTION002524100000000000000"><TT>contents</TT> Operator</A>
<LI><A NAME="tex2html582"
  HREF="node7.html#SECTION002524200000000000000"><TT>in</TT> Operator</A>
<LI><A NAME="tex2html583"
  HREF="node7.html#SECTION002524300000000000000"><TT>add/to</TT> Operator</A>
<LI><A NAME="tex2html584"
  HREF="node7.html#SECTION002524400000000000000"><TT>[]</TT> Operator</A>
<LI><A NAME="tex2html585"
  HREF="node7.html#SECTION002524500000000000000"><TT>[:]</TT> Operator</A>
<LI><A NAME="tex2html586"
  HREF="node7.html#SECTION002524600000000000000"><TT>[?]</TT> Operator</A>
<LI><A NAME="tex2html587"
  HREF="node7.html#SECTION002524700000000000000"><TT>append/to</TT> Operator</A>
<LI><A NAME="tex2html588"
  HREF="node7.html#SECTION002524800000000000000"><TT>suppress/from</TT> Operator</A>
<LI><A NAME="tex2html589"
  HREF="node7.html#SECTION002524900000000000000"><TT>empty</TT> Operator</A>
<LI><A NAME="tex2html590"
  HREF="node7.html#SECTION0025241000000000000000"><TT>in</TT> Operator</A>
<LI><A NAME="tex2html591"
  HREF="node7.html#SECTION0025241100000000000000"><TT>for</TT> Operator</A>
</UL>
<BR>
<LI><A NAME="tex2html592"
  HREF="node7.html#SECTION002525000000000000000">Exception Expressions</A>
<LI><A NAME="tex2html593"
  HREF="node7.html#SECTION002526000000000000000">Function Definition Expressions</A>
<LI><A NAME="tex2html594"
  HREF="node7.html#SECTION002527000000000000000">Conversion Expressions</A>
<UL>
<LI><A NAME="tex2html595"
  HREF="node7.html#SECTION002527100000000000000"><TT>string</TT> operator</A>
<LI><A NAME="tex2html596"
  HREF="node7.html#SECTION002527200000000000000"><TT>int</TT> operator</A>
<LI><A NAME="tex2html597"
  HREF="node7.html#SECTION002527300000000000000"><TT>char</TT> operator</A>
<LI><A NAME="tex2html598"
  HREF="node7.html#SECTION002527400000000000000"><TT>float</TT> operator</A>
<LI><A NAME="tex2html599"
  HREF="node7.html#SECTION002527500000000000000"><TT>oid</TT> operator</A>
<LI><A NAME="tex2html600"
  HREF="node7.html#SECTION002527600000000000000"><TT>ident</TT> operator</A>
</UL>
<BR>
<LI><A NAME="tex2html601"
  HREF="node7.html#SECTION002528000000000000000">Type Information Expressions</A>
<UL>
<LI><A NAME="tex2html602"
  HREF="node7.html#SECTION002528100000000000000"><TT>typeof</TT> operator</A>
<LI><A NAME="tex2html603"
  HREF="node7.html#SECTION002528200000000000000"><TT>classof</TT> operator</A>
<LI><A NAME="tex2html604"
  HREF="node7.html#SECTION002528300000000000000"><TT>typeof</TT> operator</A>
</UL>
<BR>
<LI><A NAME="tex2html605"
  HREF="node7.html#SECTION002529000000000000000">Query Expressions</A>
<UL>
<LI><A NAME="tex2html606"
  HREF="node7.html#SECTION002529100000000000000">ODMG vs. E<SMALL>YE</SMALL>DB OQL Query Expressions</A>
<LI><A NAME="tex2html607"
  HREF="node7.html#SECTION002529200000000000000">The general <TT>select</TT> syntax</A>
<LI><A NAME="tex2html608"
  HREF="node7.html#SECTION002529300000000000000">Arrays and collections in query expressions</A>
<LI><A NAME="tex2html609"
  HREF="node7.html#SECTION002529400000000000000">The Implicit <TT>select</TT> syntax</A>
<LI><A NAME="tex2html610"
  HREF="node7.html#SECTION002529500000000000000">Querying the schema</A>
<LI><A NAME="tex2html611"
  HREF="node7.html#SECTION002529600000000000000">How queries are optimized?</A>
</UL>
<BR>
<LI><A NAME="tex2html612"
  HREF="node7.html#SECTION002530000000000000000">Miscellenaous Expressions</A>
<UL>
<LI><A NAME="tex2html613"
  HREF="node7.html#SECTION002530100000000000000"><TT>bodyof</TT> operator</A>
<LI><A NAME="tex2html614"
  HREF="node7.html#SECTION002530200000000000000"><TT>structof</TT> operator</A>
<LI><A NAME="tex2html615"
  HREF="node7.html#SECTION002530300000000000000"><TT>[!]</TT> operator</A>
<LI><A NAME="tex2html616"
  HREF="node7.html#SECTION002530400000000000000"><TT>import</TT> operator</A>
</UL>
<BR>
<LI><A NAME="tex2html617"
  HREF="node7.html#SECTION002531000000000000000">Selection Statements</A>
<LI><A NAME="tex2html618"
  HREF="node7.html#SECTION002532000000000000000">Iteration Statements</A>
<UL>
<LI><A NAME="tex2html619"
  HREF="node7.html#SECTION002532100000000000000"><TT>while</TT> statement</A>
<LI><A NAME="tex2html620"
  HREF="node7.html#SECTION002532200000000000000"><TT>do/while</TT> statement</A>
<LI><A NAME="tex2html621"
  HREF="node7.html#SECTION002532300000000000000">C-<TT>for</TT> statement</A>
<LI><A NAME="tex2html622"
  HREF="node7.html#SECTION002532400000000000000">collection-<TT>for</TT> statement</A>
</UL>
<BR>
<LI><A NAME="tex2html623"
  HREF="node7.html#SECTION002533000000000000000">Jump Statements</A>
<UL>
<LI><A NAME="tex2html624"
  HREF="node7.html#SECTION002533100000000000000"><TT>break</TT> Statement</A>
<LI><A NAME="tex2html625"
  HREF="node7.html#SECTION002533200000000000000"><TT>return</TT> Statement</A>
</UL>
<BR>
<LI><A NAME="tex2html626"
  HREF="node7.html#SECTION002534000000000000000">Function Definition Statements</A>
<UL>
<LI><A NAME="tex2html627"
  HREF="node7.html#SECTION002534100000000000000">Argument Types/Return Type</A>
<LI><A NAME="tex2html628"
  HREF="node7.html#SECTION002534200000000000000">Arguments <TT>in</TT>, <TT>out</TT> and <TT>inout</TT></A>
<LI><A NAME="tex2html629"
  HREF="node7.html#SECTION002534300000000000000">Return Value</A>
<LI><A NAME="tex2html630"
  HREF="node7.html#SECTION002534400000000000000">Default Arguments</A>
<LI><A NAME="tex2html631"
  HREF="node7.html#SECTION002534500000000000000">Unval Arguments</A>
<LI><A NAME="tex2html632"
  HREF="node7.html#SECTION002534600000000000000">Scope of Variables</A>
<LI><A NAME="tex2html633"
  HREF="node7.html#SECTION002534700000000000000">Recursivity</A>
<LI><A NAME="tex2html634"
  HREF="node7.html#SECTION002534800000000000000">Particularity</A>
<LI><A NAME="tex2html635"
  HREF="node7.html#SECTION002534900000000000000">The <TT>oql$functions</TT> Variable</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00250000000000000000"></A> <A NAME="5477"></A>
<A NAME="lsyntax"></A>
<BR>
Language Syntax
</H1>

<H2><A NAME="SECTION00251000000000000000"></A> <A NAME="5479"></A>
<A NAME="termatoms"></A>
<BR>
Terminal Atom Syntax
</H2>
To express the syntax of terminal atoms, we use the standard
regular expression notation.

<H3><A NAME="SECTION00251100000000000000"></A> <A NAME="5481"></A>
<BR>
Integer Atom
</H3>
Integers are coded on 64 bits.
<BR>
The syntax for the integer type is one of the followings:
<PRE><TT>
<TT>[0-9]+</TT> 		 <SPAN  CLASS="textit">decimal base</SPAN>
<BR><TT>0x[0-9a-fA-F]+</TT> 		 <SPAN  CLASS="textit">hexadecimal</SPAN>
<BR><TT>0[0-7]+</TT> 		 <SPAN  CLASS="textit">octal</SPAN>
<BR>
</TT></PRE>
The domain for the integer type is as follows:

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">Minimal Value</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">Maximal Value</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>-9223372036854775808</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>9223372036854775807</TD>
</TR>
</TABLE>
A few examples:

<PRE>
13940     // integer expressed in the decimal base
0x273f1   // integer expressed in the hexadecimal base
0x273F1   // integer expressed in the hexadecimal base
0100      // integer expressed in the octal base
</PRE>

<H3><A NAME="SECTION00251200000000000000"></A> <A NAME="5485"></A>
<BR>
Float Atom
</H3>
The syntax for floating point atoms is one of the following regular
expressions:
<BR>
<BR><TT>[0-9]+&#92;.[0-9]+?</TT>
<BR><TT>[0-9]+?&#92;.[0-9]+</TT>
<BR><TT>[0-9]+&#92;.[0-9]+?(e|E)[+-]?[0-9]+([fF]|[lL])?</TT>
<BR><TT>[0-9]+?&#92;.[0-9]+(e|E)[+-]?[0-9]+([fF]|[lL])?</TT>
<BR>
<BR>
The domain for the float type is as follows:

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">Minimal Value</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">Maximal Value</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>4.94065645841246544e-324</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>1.79769313486231570e+308</TD>
</TR>
</TABLE>
A few examples:

<PRE>
1.
1.23
.3
0.3039
1e+10
2.e+112
1.2e-100
.234e-200
.234e-200f
.234e-200F
</PRE>

<H3><A NAME="SECTION00251300000000000000"></A> <A NAME="5489"></A>
<BR>
String Atom
</H3>
The syntax for the string type is as follows:
<BR><TT>&#92;"([^"]|&#92;&#92;&#92;")*&#92;"</TT>
<BR>
<BR>
The following escape sequences are interpreted:

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">Escape Sequence</SPAN>
</DIV></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">Name</SPAN>
</DIV></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">ASCII Name</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>alert</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>BEL</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;b</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>backspace</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>BS</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;f</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>form feed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>FF</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;n</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>newline</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>NL (LF)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;r</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>carriage return</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>CR</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;t</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>horizontal tab</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>HT</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;v</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>vertical tab</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>VT</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;&#92;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>backslash</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&#92;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>double quote</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>single quote</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>'</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&#92;ooo</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>octal number</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&#92;ooo</TD>
</TR>
</TABLE>
A few examples:

<PRE>
"hello"
"hello \"world\""
"this is a multi-lines\ntext\n"
"this text contains escape sequences: \007\v\f\n''
</PRE>

<H3><A NAME="SECTION00251400000000000000"></A> <A NAME="5493"></A>
<BR>
Char Atom
</H3>
The syntax for the char type is one of the followings:
<BR><TT>'</TT><SPAN  CLASS="textit">ascii character</SPAN><TT>'</TT>
<BR><TT>'&#92;[0-7+]'</TT>
<BR><TT>'&#92;(x|X)[0-9a-fA-F+]'</TT>
<BR><TT>'&#92;a'</TT>
<BR><TT>'&#92;b'</TT>
<BR><TT>'&#92;f'</TT>
<BR><TT>'&#92;n'</TT>
<BR><TT>'&#92;r'</TT>
<BR><TT>'&#92;t'</TT>
<BR><TT>'&#92;v'</TT>
<BR>
<BR>
A few examples:

<PRE>
'a'
'b'
'\n'
'\a'
'\007'
'\x50'
'\x5F'
</PRE>

<P>

<H3><A NAME="SECTION00251500000000000000"></A> <A NAME="5495"></A>
<BR>
Boolean Atom
</H3>
The syntax for a boolean atom is one of the followings:
<BR><TT>true</TT>
<BR><TT>false</TT>

<H3><A NAME="SECTION00251600000000000000"></A> <A NAME="5497"></A>
<BR>
Identifier Atom
</H3>
The syntax for an identifier atom is as follows:
<BR><TT>[a-zA-Z&#92;$_#][a-zA-Z&#92;$_0-9#]*</TT>
<BR>
<BR>
This means that an identifier must start whith a letter, a ``<TT>_</TT>'',
a ``<TT>$</TT>'' or a ``<TT>#</TT>'' which may be followed by letters, digits,
``<TT>_</TT>'', ``<TT>$</TT>'' and ``<TT>#</TT>'' characters.
<BR>
<BR>
For instance, the following words are some valid identifiers:

<PRE>
a
alpha
beta1
alpha_beta
$a
oql$maxint
oql#2
$
#
_1
</PRE>
Note that identifiers beginning by <TT>oql$</TT> or <TT>oql#</TT> are
reserved for special used by the interpreter.

<H3><A NAME="SECTION00251700000000000000"></A> <A NAME="5499"></A>
<BR>
Oid Atom
</H3>
The syntax for an <TT>oid</TT> is as following:
<BR><TT>[0-9]+:[0-9]+:[0-9]+:oid</TT>
<BR>
<BR>
Note that <TT>oid</TT> atoms are not typed directly by the user, but are produced
by the database via the OQL interpreter.

<BR>
The following words are some syntaxically valid atom <TT>oid</TT>s:

<PRE>
123.2.33373:oid
82727272.1.292828282:oid
</PRE>

<H3><A NAME="SECTION00251800000000000000"></A> <A NAME="5501"></A>
<BR>
Object Atom
</H3>
The syntax for an atom <TT>object</TT> is as following:
<BR><TT>[0-9a-fA-F]+:obj</TT>
<BR>
<BR>
Note that object atoms are not typed directly by the user, but are produced
by OQL interpreter.

<BR>
The following words are some syntaxically valid atom <TT>object</TT>s:

<PRE>
38383:obj
ea954:obj
</PRE>

<H3><A NAME="SECTION00251900000000000000"></A> <A NAME="5503"></A>
<BR>
Null Atom
</H3>
The <TT>null</TT> atom denotes an unitialized value. Its type depends on the context.
It can denote a unitialized integer, float, char, string or oid.

<BR>
<BR>
The syntax for a null atom is one of the followings:
<BR><TT>null</TT>
<BR><TT>NULL</TT>

<H3><A NAME="SECTION002511000000000000000"></A> <A NAME="5505"></A>
<BR>
Nil Atom
</H3>
The <TT>nil</TT> atom denotes the empty atom.
<BR>
The syntax for a nil atom is as follows:
<BR><TT>nil</TT>

<H2><A NAME="SECTION00252000000000000000"></A> <A NAME="5507"></A>
<BR>
Non Terminal Atom Production
</H2>
The other atoms - <TT>set</TT>s, <TT>bag</TT>s, <TT>array</TT>s,
<TT>list</TT>s and <TT>struct</TT>s - are non terminal
atoms. This means that they cannot be generated using a simple lexical
construct.

<P>

<H3><A NAME="SECTION00252100000000000000"></A> <A NAME="5509"></A>
<BR>
List, Set, Bag and Array Atoms
</H3>
To construct a collection atom - <TT>list</TT>, <TT>set</TT>, <TT>bag</TT>
or <TT>array</TT> -, one may use the
function <SPAN  CLASS="textit">collection()</SPAN> where <SPAN  CLASS="textit">collection</SPAN> denotes the
collection type, for instance:

<PRE>
set(1, 2, 3)
list(1, "hello", "world")
array(2, 3, list(3893, -2, 'a'), 22)
bag(2, 2, 3, 4, 5, 12)
</PRE>
This is the simple way to construct such atoms, but as any other atoms,
a collection atom may be produced by the OQL interpreter as the evaluation
of a complex expression, for instance:

<PRE>
select x from Person x
</PRE>
produces an atom <TT>bag</TT> of objects.

<H3><A NAME="SECTION00252200000000000000"></A> <A NAME="5511"></A>
<BR>
Struct Atom
</H3>
The most direct way to construct a <TT>struct</TT> atom is as follows:
<BR><TT>struct(</TT>{<SPAN  CLASS="textit">identifier</SPAN><TT>:</TT><SPAN  CLASS="textit">expr</SPAN>}<TT>)</TT>
<BR>
<BR>
For instance:

<PRE>
struct(a: 1)
struct(format: text, s: "this is the text")
struct(name: "john", age: 32, spouse: first(select Person))
</PRE>

<H2><A NAME="SECTION00253000000000000000"></A> <A NAME="5513"></A>
<BR>
Keywords
</H2>
Any programming language has its own set of reserved words (keywords)
that cannot be used as identifiers. For instance, the keyword ``<TT>if</TT>''
cannot be used as a variable in a C program.
<BR>
OQL also has its own set of keywords.
But OQL is one part among others in
the information system: for instance, there are an Object Model,
an Object Definition Language (ODL) and Language bindings.
The Object Model does not introduce
any keyword, while ODL has its own set of keywords which are different
from the OQL keywords. For instance, a class can include an
attribute whose name is ``<TT>if</TT>'' as it is not a ODL keyword.
If one wants to access this attribute in OQL, using for instance
the path expression ``<TT>x.if</TT>'', we will get a syntax error.
This is not acceptable.
<BR>
We introduce in OQL (and in ODL) a way to neutralize any keyword:
the token ``<TT>@</TT>'' used as a prefix keyword neutralizes
the keyword and makes it a valid identifier. For instance, ``<TT>x.@if</TT>'',
denotes the attribute ``<TT>if</TT>'' of the instance ``<TT>x</TT>''.
<BR>
More generaly, ``<TT>@</TT><SPAN  CLASS="textit">identifier</SPAN>'' denotes the identifier
``<SPAN  CLASS="textit">identifier</SPAN>'' whether ``<SPAN  CLASS="textit">identifier</SPAN>'' is a keyword or not.

<BR>
<BR>
OQL introduces the following keywords:

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>add</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>all</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>append</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>array</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>as</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>asc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>bodyof</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>break</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>by</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>classof</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>contents</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>define</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>delete</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>desc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>distinct</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>do</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>element</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>else</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>empty</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>eval</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>except</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>exists</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>for</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>from</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>function</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>group</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>having</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>ident</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>if</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>import</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>in</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>intersect</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>is</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>isset</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>like</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>list</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>mod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>new</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>nil</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>not</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>order</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>pop</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>print</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>push</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>refof</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>return</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>scopeof</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>select</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>set</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>struct</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>structof</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>suppress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>then</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>throw</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>to</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>true</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>typeof</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>union</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>unset</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>unval</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>valof</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>where</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>while</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION00254000000000000000"></A> <A NAME="5517"></A>
<BR>
Comments
</H2>
In OQL, comments are identical to the C++:

<UL>
<LI>all characters after the token <TT>//</TT> until the end of the current
line are ignored by the interpreter,
</LI>
<LI>all characters between the tokens <TT>/*</TT> and <TT>*/</TT> are
ignored.
</LI>
</UL>
For instance:

<PRE>
1 + 2;        // this is a comment
a := "hello"; /* this is another
                 comment */
</PRE>

<H2><A NAME="SECTION00255000000000000000"></A> <A NAME="5521"></A>
<BR>
Statements
</H2>
A valid OQL construct is composed of a sequence of statements. Main of
the statements are expression statements.

<BR>
<BR>
A statement can be one of the following:
<BR> - an expression statement,
<BR> - a selection statement, <TT>if/else</TT>,
<BR> - an iteration statement, <TT>while</TT>, <TT>do/while</TT>, <TT>for</TT>,
<BR> - a function definition statement, <TT>function</TT>
<BR> - a jump statement, <TT>break</TT>, <TT>return</TT>
<BR> - a compound statement,
<BR> - an empty statement.
<BR>
<BR>
The OQL expression sub-grammar is very close from the C grammar. The
OQL grammar for the flow controls statement - <TT>if/else</TT>, 
<TT>while</TT>, <TT>do/while</TT>, <TT>for</TT> - is identical to the C
grammar. The common operators of OQL and C have the same associativity
and precedence.

<P>

<H2><A NAME="SECTION00256000000000000000"></A> <A NAME="5530"></A>
<BR>
Expression Statements
</H2>
An expression statement is an expression following by a semicolon.
Expressions are built from typed operands composed recursively by operators.

<BR>
<BR>
The syntax of an expression statement is as follows:
<BR><SPAN  CLASS="textit">expr</SPAN> <TT>;</TT>
<BR>
where <SPAN  CLASS="textit">expr</SPAN> denotes any expression.
<BR>
<BR>
There are three main kinds of expressions: atomic expressions,
unary expressions and binary expressions.
Atomic expressions are composed of one terminal atom and no operators,
unary expressions are composed
of one operand and one operator, binary expressions are composed
of two operands and one operator.

<BR>
<BR>
We divide the OQL expression family into several semantical sub-families
according to their operators as follows:
<BR>
<BR>  - atomic expressions,
<BR>  - arithmetic expressions,
<BR>  - assignment expressions,
<BR>  - auto increment &amp; decrement expressions,
<BR>  - comparison expressions,
<BR>  - logical expressions,
<BR>  - conditional lists,
<BR>  - expression sequences,
<BR>  - array deferencing,
<BR>  - identifier expressions,
<BR>  - path expressions,
<BR>  - function call,
<BR>  - method invocation,
<BR>  - eval/unval operators,
<BR>  - set expressions,
<BR>  - object creation,
<BR>  - object deletion,
<BR>  - collection expressions,
<BR>  - exception expressions,
<BR>  - function definition expressions,
<BR>  - conversion expressions,
<BR>  - type information expressions
<BR>  - query expressions,
<BR>  - miscellenaous expressions
<BR>
<BR>
In the following sub-sections, we introduce all the OQL expression types
using the following template presentation:
<BR>
<OL>
<LI>we present first, in an unformal way, the syntax and the semantics
of the operators,
</LI>
<LI>general formal information is presented in a first table:
<BR>  - operator(s)
<BR>  - type
<BR>  - syntax
<BR>  - operand types
<BR>  - functions
</LI>
<LI>in an optionnal second table, we present all the valid operand combination
and their result type. A comment about the function performed is added
if necessary. This table is skipped in case of the operand type combination
is unique or trivial.
</LI>
<LI>in a last table, we introduce a few examples. The examples
manipulating database objects use the schema that can be found in
the directory
<BR><TT>$EYEDBROOT/examples/common</TT>:

<PRE>
// person.odl

enum CivilState {
  Lady = 0x10,
  Sir  = 0x20,
  Miss = 0x40
};

class Address {
  attribute string street;
  attribute string&lt;32&gt; town;
  attribute string country;
};

class Person {
  attribute string name;
  attribute int age;
  attribute Address addr;
  attribute Address other_addrs[];
  attribute CivilState cstate;
  attribute Person * spouse inverse Person::spouse;
  attribute set&lt;Car *&gt; cars inverse owner;
  attribute array&lt;Person *&gt; children;

  int change_address(in string street, in string town,
                     out string oldstreet, out string oldtown);

  static int getPersonCount();
  index on name;
};

class Car {
  attribute string brand;
  attribute int num;
  Person *owner inverse cars;
};

class Employee extends Person {
  attribute long salary;
};
</PRE>
</LI>
</OL>
Expression types are gathered so to minimize the number of tables in this
document.

<H2><A NAME="SECTION00257000000000000000"></A> <A NAME="5536"></A>
<BR>
Atomic Literal Expressions
</H2>
Atomic literal expressions are expressions composed of a single terminal
(or token or lexical unit) without any operator. They are also called
primary expressions. These expressions have already been introduced in
Section <A HREF="#termatoms">5.1</A>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">no operator</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">terminal atom</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer, float, char, string, boolean, identifier, null, nil, oid,</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>same type as the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>1</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2.</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>1</TT>2.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>'a'</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>"hello"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">value of</SPAN> <TT>alpha</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>true</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>83283.1.29292:oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">an error is raised</SPAN> in case
of the oid is invalid.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Otherwise the result is the input oid: <TT>83283.1.29292:oid</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION00258000000000000000"></A> <A NAME="5556"></A>
<BR>
Arithmetic Expressions
</H2>
Arithmetic expressions gather the expressions used for any arithmetic
computation: addition, multiplication, substraction, division, modulo, shift
left and right,
bitwise or, bitwise exclusive, bitwise and, bitwise complement.
This Section introduced these operators with a special focus on the
additive operator which is a multi-purpose operator.

<H3><A NAME="SECTION00258100000000000000"></A> <A NAME="5558"></A>
<BR>
Additive Expression
</H3>
The additive operator (i.e. <TT>+</TT>) is used for arithmetic
addition of integers, floating point numbers and characters, and is
also used for string concatenation,
list or array concatenation and set or bag union. Its functionality
depends on the type of its operands: it is a polymorphic operator.
Note that the choice of its functionality is done at evaluation time, not
at compile time. That means that the functionality of an expression such as
<TT>x + y</TT> is unknown until the evaluation time. Depending on the
dynamic type of the operands <TT>x</TT> and <TT>y</TT>, it can be a
simple arithmetic addition, a string or list or array concatenation,
a set or bag union or it can raise an error.
<BR>
When used as a arithmetic operator and when the two
operands have not the same type, one of the operands can be
automatically promote to the type of the second one.
The <SPAN  CLASS="textit">promotion</SPAN> mechanism is the same as in the C or C++ languages:
<TT>integer</TT> may be promoted to <TT>float</TT>, <TT>char</TT> may be promoted to
<TT>float</TT> or <TT>integer</TT>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>+</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">expr</SPAN> <TT>+</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>yes</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>integer, float, char, string, list, bag, set, array</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>see following table</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>multi functions according to operands: arithmetic addition,
string concatenation, list or array concatenation, set or bag union.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=4><SPAN><SPAN  CLASS="textit">Possible Operand Combinations</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">first operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">second operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">result type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">string concatenation</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">list concatenation</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>array</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>array</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>array</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">array concatenation</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">set union</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">bag union</SPAN></TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 + 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>3</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 + 2.</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>3.</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2 + 2.3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>4.3</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>'a' + 'b'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>195</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>'a' + 1.2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>98.200</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" + "world"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>"helloworld"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list(1, 2, 3) + list(2, 3, 4)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>list(1, 2, 3, 2, 3, 4)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set(1, 2, 3) + set(2, 3, 4)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>set(1, 2, 3, 4)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 + "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set(1, 2, 3) + list(2, 3, 4)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION00258200000000000000"></A> <A NAME="5585"></A>
<BR>
Multiplicative, Division and Minus Expressions
</H3>
Multiplicative, division and minus expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions.
When operands have different types, promotionnal mechanisms are the
same as for the additive operator.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>*</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>/</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>-</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>*</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>/</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-</TT> : no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>*</TT> : yes</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>/</TT> : no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer, float, char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>see following table</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-</TT> : substract</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>*</TT> : multiply</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>/</TT> : divide</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3><SPAN><SPAN  CLASS="textit">Possible Operand Combinations</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">first operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">second operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">result type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 - 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-1</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>3 * 2.</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>6.</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2 * 'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>194</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>'a' * 'b'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>9506</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 / 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>0</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 / 2.</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>.5000</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1. / 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>.5000</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1. / 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>.5000</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" * "world"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 - "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION00258300000000000000"></A> <A NAME="5622"></A>
<BR>
Shift, Mod, And, Or, XOr Expressions
</H3>
Shift, modulo, and, or and xor expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions.
Operand types must be <TT>integer</TT> or <TT>char</TT> and the only
possible type promotion is from <TT>char</TT> to <TT>integer</TT>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#171;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#187;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>%</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&amp;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>|</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>^</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&#171;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&#187;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>%</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&amp;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>|</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>^</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#171;</TT> : no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#187;</TT> : no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>% </TT> : no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&amp; </TT> : yes</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>| </TT> : yes</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>^ </TT> : yes</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer, char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#171;</TT> : left shift</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#187;</TT> : right shift</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>% </TT> : modulo</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&amp; </TT> : bitwise and</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>| </TT> : bitwise or</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>^ </TT> : bitwise exclusive or</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 &#171; 4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>16</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>100 &#187; 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>25</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>100 % 13</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>9</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>0xf12 &amp; 0xf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>2</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>0xf12 | 0xf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>3871</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>0xf12 ^ 0xf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>3869</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>'b' % '9'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>8</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2 &#171; 1.2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2 % 3.4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2.1 % 3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION00258400000000000000"></A> <A NAME="5663"></A>
<BR>
Sign Expressions
</H3>
Sign expressions are the expressions using the unary operators <TT>+</TT>
or <TT>-</TT>. 
The expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions.
These unary operators accept only <TT>integer</TT>,
<TT>char</TT> and <TT>float</TT> operands.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>+</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>+</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer, char, float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>see following table</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>sign operator</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Possible Operand Combinations</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer</TT></TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>+12</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>12</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>-100</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-100</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>-123.4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-123.4</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>+'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>97</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>-'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-97</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>+"hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>-null"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION00258500000000000000"></A> <A NAME="5697"></A>
<BR>
Complement Expressions
</H3>
The complement operator performs a bitwise complement on its operand.
The expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions.
This operator accepts only <TT>integer</TT> and <TT>char</TT> operands.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>~</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>~</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer</TT>, <TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>bitwise complement</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>~112</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-113</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>~0</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-1</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>~'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-98</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>~2.3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>~"hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION00259000000000000000"></A> <A NAME="5721"></A>
<BR>
Assignment Expressions
</H2>
The expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions except that the simple assignment operator in OQL is <TT>:=</TT>
instead of <TT>=</TT> in C or C++. The left operand must be a left value.
A left value is an OQL entity which is assignable: for instance any
identifier or a valid path expression.
<BR>
When the assignment is simple and when the left value is an identifier,
no type checking on the right operand is done. For instance, <TT>x := 10</TT>
and <TT>x := "hello"</TT> are always valid expressions. In the case
of the left value is a path expression, the OQL interpreter checks that
the type of the second operand matches the expected type of the first one.
For instance if <TT>p</TT> denotes a <TT>Person</TT> instance,
<TT>p-&gt;age := 32</TT> is certainly valid while <TT>p-&gt;age := "hello"</TT>
raises a type check error.
<BR>
When the assignment is combined with another operation (for instance,
the <TT>-=</TT> operator), the left operand must be initialized and
the interpreter checks that the left and right
operand can be combined through the other operator.
<BR>
<BR>
For instance, the following constructs are valid:
<PRE>
a := 10;
a -= 20;

a := "hello";
a += " world";

p := first(select Person);
p.name := "johnny";

first(select Person.age = 0).name := "baby";
</PRE>
while these ones produce errors:
<PRE>
a := "hello";
a -= 20; // raises the error: operation 'string + integer' is not valid

a := list(1, 2);
a *= 2; // raises the error: operation 'list * integer' is not valid

unset b;
b += 20; // raises the error: uninitialized identifier 'b'

p := first(select Person);
p.age := "baby"; // raises the error: integer expected, got string
</PRE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>:=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>*=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>/=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>%=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>+=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>-=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#171;=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&#187;=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&amp;=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>|=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>^=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>:=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>*=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>/=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>%=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>+=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>-=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>&#171;=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>&#187;=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>&amp;=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>|=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">lvalue</SPAN> <TT>^=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">leftvalue</SPAN> on the left side and <SPAN  CLASS="textit">any type</SPAN>
on the right side</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>the type of the right operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>perform an operation and assignment</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>a := 24</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>24</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>a += 12</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>36</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>a /= 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>18</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>a ^= 100</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>118</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>first(select Person).age := 38</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>38</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" := 4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN> (i.e. <TT>"hello"</TT> is not a leftvalue)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>8 := 5</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN> (i.e. <TT>8</TT> is not a leftvalue)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>unset a; a += 20</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN> (i.e. uninitialized identifier)</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002510000000000000000"></A> <A NAME="5775"></A>
<BR>
Auto Increment &amp; Decrement Expressions
</H2>
The expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions. The operand must be an initialized left value of type
<TT>integer</TT>, <TT>char</TT> or <TT>float</TT>. In case of the
operand is a <TT>char</TT> atom, the result type is an <TT>integer</TT>.
Otherwise, the result type is the type of the operand.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>++</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>-</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expr</SPAN> <TT>-</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expr</SPAN> <TT>++</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>++</TT><SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>-</TT><SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">leftvalue</SPAN> of type <TT>integer</TT>, <TT>char</TT> or <TT>float</TT>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>see following table</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expr</SPAN> <TT>-</TT> : post-decrementation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expr</SPAN> <TT>++</TT> : post-incrementation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>++</TT><SPAN  CLASS="textit">expr</SPAN>  : pre-incrementation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>-</TT><SPAN  CLASS="textit">expr</SPAN>  : pre-incrementation</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Possible Operand Combinations</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer</TT></TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textit">result</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>a := 1; a++</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">initially</SPAN> <TT>a</TT> equals <TT>1</TT>; the result of the evaluation is <TT>1</TT> but after the evaluation,
<TT>a</TT> equals 2</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>-a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>0</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>a++</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>0</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>a</TT> equals <TT>1</TT> after the
evaluation</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002511000000000000000"></A> <A NAME="5809"></A>
<BR>
Comparison Expressions
</H2>
The expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions except that the equal operator could be either <TT>==</TT> or
<TT>=</TT>.

<H3><A NAME="SECTION002511100000000000000"></A> <A NAME="5811"></A>
<BR>
Equal and NotEqual Expressions
</H3>
Operands may have any type at all. If the type of the operands differ (modulo
the type promotion mechanisms for numbers), the
result of the expression <SPAN  CLASS="textit">operand1</SPAN> <TT>==</TT> <SPAN  CLASS="textit">operand2</SPAN> is
always <TT>false</TT> while the result of <SPAN  CLASS="textit">operand1</SPAN> <TT>!=</TT>
<SPAN  CLASS="textit">operand2</SPAN> is always <TT>true</TT>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>==</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>!=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>==</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>!=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>yes</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>equal</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>not equal</TD>
</TR>
</TABLE>
When operands are number of different types, an automatic promotion is
done to the more precise type.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == 1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == 1.0</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 != 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" == "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list(1, 2, 3) == list(1, 2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set(1, 3, 2) == set(1, 2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002511200000000000000"></A> <A NAME="5835"></A>
<BR>
Less and Greater Expressions
</H3>
The comparison operators <TT>&lt;, &lt;=, &gt;</TT> and <TT>&gt;=</TT> are multi-purpose
operators: they are used for
integer, floating point number and character comparison, but also
for list or array term-to-term comparison and for set or bag inclusion.
Their functionality
depends on the type of its operands: they are polymorphic operators.
Note that the choice of the functionality is done at evaluation time, not
at compile time. That means that the functionality of an expression such as
<TT>x &lt; y</TT> is unknown until the evaluation time. Depending on the
dynamic type of the operands <TT>x</TT> and <TT>y</TT>, it can be an
arithmetic comparison (if <TT>x</TT> and <TT>y</TT> are numbers),
a alpha-numeric comparison (if <TT>x</TT> and <TT>y</TT> are strings),
a term-to-term ordered collection comparison (if <TT>x</TT> and <TT>y</TT> are lists or
arrays) or a set or bag inclusion comparison
(if <TT>x</TT> and <TT>y</TT> are sets or bags).

<BR>
<BR>
While arithmetic and alpha-numeric comparisons are trivial and do not
need any suplementary explanations,
the term-to-term ordered collection comparisons needs to be detailed.

<BR>
<BR>
The general algorithm for this functionnality is as follows:
<BR>
<OL>
<LI>let <SPAN  CLASS="textit">l1</SPAN> and <SPAN  CLASS="textit">l2</SPAN> two OQL ordered collections, containing
respectively <SPAN  CLASS="textit">l1_cnt</SPAN> and <SPAN  CLASS="textit">l1_cnt</SPAN> atoms.
</LI>
<LI>let <SPAN  CLASS="textit">op</SPAN> one of the following polymorphic comparison operators: 
 <TT>&lt; &lt;= &gt; &gt;=</TT>,
</LI>
<LI><SPAN  CLASS="textit">l1</SPAN> <SPAN  CLASS="textit">op</SPAN> <SPAN  CLASS="textit">l2</SPAN> is <TT>true</TT> if and only if all the
following conditions are realized:

<OL>
<LI><SPAN  CLASS="textit">l1</SPAN> and <SPAN  CLASS="textit">l2</SPAN> must be of the same collection type,
</LI>
<LI><SPAN  CLASS="textit">l1_cnt</SPAN> <SPAN  CLASS="textit">op</SPAN> <SPAN  CLASS="textit">l2_cnt</SPAN> or <SPAN  CLASS="textit">l1_cnt</SPAN> equals
<SPAN  CLASS="textit">l2_cnt</SPAN>
</LI>
<LI>for each atom <SPAN  CLASS="textit">l1[i]</SPAN> with <SPAN  CLASS="textit">i</SPAN> in <TT>[</TT><SPAN  CLASS="textit">i</SPAN><TT>,</TT><SPAN  CLASS="textit">l1_cnt</SPAN><TT>]</TT>, <SPAN  CLASS="textit">l1[i]</SPAN> <SPAN  CLASS="textit">op</SPAN> <SPAN  CLASS="textit">l2[i]</SPAN>
</LI>
</OL>
</LI>
</OL>
For instance:
<BR><TT>list(1, 2) &lt;= list(0, 2)</TT> is <TT>true</TT>
<BR><TT>list(1, 2) &lt;= list(3)</TT> is <TT>false</TT>
<BR><TT>list(1, 2) &lt;= list(3)</TT> is <TT>false</TT>
<BR><TT>list("aaa", 4) &lt; list("bbbb", 8)</TT> is <TT>true</TT>
<BR><TT>list("aaa", 4, list(1, 2)) &lt; list("b", 8, list(2, 3))</TT> is <TT>true</TT>
<BR><TT>list(set(2, 4), 3) &lt; list(set(4, 2, 3), 4)</TT> is <TT>true</TT>
<BR><TT>list(2, 3) &lt; list("hello", 2)</TT> raises an error
<BR><TT>list(2, 3) &lt; array(2, 4)</TT> raises an error
<BR>
<BR>
Note that the fact that <SPAN  CLASS="textit">l1</SPAN> <TT>&lt;=</TT> <SPAN  CLASS="textit">l2</SPAN> is <TT>false</TT>
does not implie that <SPAN  CLASS="textit">l1</SPAN> <TT>&gt;</TT> <SPAN  CLASS="textit">l2</SPAN> is <TT>true</TT>.
Indeed, <TT>list(2, 3) &lt; list(1, 3, 2)</TT> and
<TT>list(1, 3, 2) &gt;= list(2, 3)</TT> are <TT>false</TT>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&lt;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&lt;=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&gt;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&gt;=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&lt;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&lt;=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&gt;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&gt;=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>integer, float, char, string, list, array, set,
bag</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>the function depends on the operands:</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&lt; </TT> : less than <SPAN  CLASS="textit">or</SPAN> is included in</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&lt;=</TT> : less than or equal <SPAN  CLASS="textit">or</SPAN> is included in or equal</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&gt; </TT> : greater than <SPAN  CLASS="textit">or</SPAN> contains</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&gt;=</TT> : greater than or equal <SPAN  CLASS="textit">or</SPAN> contains or equal</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=4><SPAN><SPAN  CLASS="textit">Possible Operand Combinations</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">first operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">second operand type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textit">result type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">comments</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT>, <TT>char</TT>, <TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>integer</TT>,
<TT>char</TT>, <TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs an arithmetic
comparison</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs an alpha-numeric comparison</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs an inclusion comparison</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs an inclusion comparison</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs an inclusion comparison: the <TT>set</TT> operand is converted to a
<TT>bag</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bag</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>set</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs an inclusion comparison: the <TT>set</TT> operand is converted to a
<TT>bag</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs a term-to-term polymorphic (i.e. numeric, alpha-numeric or inclusion)
comparison</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>array</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>array</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>boolean</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>performs a term-to-term polymorphic comparison</TD>
</TR>
</TABLE>
Note that in case of different operand types, an automatic promotion is
done to the more precise type.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>1 &lt; 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>1 &gt;= 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>2. &lt;= 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>"hello" &lt; "world"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>"hello" &gt;= "world"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>list(1, 2) &lt; list(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>list(1, 2) &lt; list(0, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>list(1, 2) &lt; list(0, 3, 2)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>list(0, 3, 2) &gt;= list(1, 2)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>list(1, 2) &lt; list(2, 3, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>list(1, 2) &lt; list(0)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>set(1, 2) &lt; set(2, 4, 44)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>set(1, 2) &lt; set(2, 1, 44)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>"hello" &gt;= 3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>list(1, 2) &lt; array(2, 4, 44)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>set(1, 2) &lt; bag(2, 1, 44)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002511300000000000000"></A> <A NAME="5877"></A>
<BR>
Regular Expression Operators
</H3>
OQL provides the ODMG OQL regular expression operator <TT>like</TT>
plus four other ones. These four extra operators are based on the regular
expression UNIX library. So, the syntax of the regular expression are
the same as that used by the well known UNIX tools <TT>grep</TT>, <TT>sed</TT>,
and so on. All the regular expression operators takes two string operands:
the first one is the string to compare, the second one is the regular
expression. So, these operators are not commutative.
These operators provide the following functionalities:
<BR><PRE><TT>
<TT>like</TT> 		 : ODMG OQL operator. Returns <TT>true</TT> if the firstoperand matches the regular expression.
<BR>
Otherwise <TT>false</TT> is returned. The regular expression is am SQL regular expression where,
<BR>
for instance, <TT>%</TT> and <TT>_</TT> are wilcard characters.
<BR><TT>~</TT> 		 : This operator hasthe same functionnality as the <TT>like</TT> operator but theregular expression
<BR>
has the UNIX syntax.
<BR><TT>&nbsp;</TT> 		 : Returns <TT>true</TT> if the firstoperand matches the regular expression in a case insensitive way.
<BR>
Otherwise <TT>false</TT> is returned.
<BR><TT>!~</TT> 		 : Returns <TT>true</TT> if the firstoperand does not match the regular expression.
<BR>
Otherwise <TT>false</TT> is returned.
<BR><TT>!~~</TT> 		 : Returns <TT>true</TT> if the firstoperand does not match the regular expression in a case insensitive
<BR>
way. Otherwise <TT>false</TT> is returned.
</TT></PRE>
<SPAN  CLASS="textit">Note that the operator</SPAN> <TT>like</TT> <SPAN  CLASS="textit">uses currently the
UNIX form of regular expressions instead of the SQL form. It will become
ODMG/SQL compliant in a next version</SPAN>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>~</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>~~</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>!~</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>!~~</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>like</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><SPAN  CLASS="textit">expr</SPAN> <TT>~</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><SPAN  CLASS="textit">expr</SPAN> <TT>~~</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><SPAN  CLASS="textit">expr</SPAN> <TT>!~</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><SPAN  CLASS="textit">expr</SPAN> <TT>!~~</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><SPAN  CLASS="textit">expr</SPAN> <TT>like</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255>no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>~</TT> :</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>matches the regular expression</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>&nbsp;</TT> :</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>matches the regular expression, case insensitive</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>!~</TT> :</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>does not match the regular expression</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>!~~</TT> :</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>does not match the regular expression, case insensitive</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>like</TT> :</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>matches the regular expression</TD>
</TR>
</TABLE></TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" ~ "LL"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" ~~ "LL"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" ~ "^LL"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" ~ "^h"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" !~ "^h"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello" ~ ".*ll.*" </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>".*ll.*" ~ "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT> <SPAN  CLASS="textit">because regular
expression should be on the right</SPAN></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002512000000000000000"></A> <A NAME="5915"></A>
<BR>
Logical Expressions
</H2>
OQL provide three logical expressions which can take two form each.
The logical or operator is <TT>||</TT> or <TT>or</TT>.
The logical and operator is <TT>&amp;&amp;</TT> or <TT>and</TT>.
The logical not operator is <TT>!</TT> or <TT>not</TT>.

<BR>
<BR>
The expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions. Note that the ODMG operator ``<TT>||</TT>'' denotes the string concatenation.

<BR>
As for <TT>C</TT> and <TT>C++</TT>, the OQL interpreter
performs a lazy evaluation:

<UL>
<LI><SPAN  CLASS="textit">expr1</SPAN> <TT>||</TT> <SPAN  CLASS="textit">expr2</SPAN>
<BR><SPAN  CLASS="textit">expr2</SPAN> is not evaluated if <SPAN  CLASS="textit">expr1</SPAN> is evaluated to <TT>true</TT>.
</LI>
<LI><SPAN  CLASS="textit">expr1</SPAN> <TT>&amp;&amp;</TT> <SPAN  CLASS="textit">expr2</SPAN>
<BR><SPAN  CLASS="textit">expr2</SPAN> is not evaluated if <SPAN  CLASS="textit">expr1</SPAN> is evaluated to <TT>false</TT>.
</LI>
</UL>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>||</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>&amp;&amp;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>unary, binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>||</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>or</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>&amp;&amp;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>and</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>!</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>not</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>logical or</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>logical and</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>logical not</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>true || false</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>false || false</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>true &amp;&amp; false</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == 2 || 3 == 4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == 2 || 3 == 3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == 2 or 3 == 3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 == 2 || "hello" == "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>(1 == 2 || 2 == 2) &amp;&amp; (a = "hello")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>returns <TT>true</TT>
if <TT>a</TT> equals "hello". <TT>false</TT> otherwise</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>1 || 3 == 3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN>: boolean expected got integer</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>!3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN>: boolean expected got integer</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>!(1 == 1)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>not(1 == 1)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>false</TT></TD>
</TR>
</TABLE>
<H2><A NAME="SECTION002513000000000000000"></A> <A NAME="5954"></A>
<BR>
Conditional Expression
</H2>
The unique conditional expression operator is <TT>?:</TT>.
The expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions. The first operand must be an boolean and the two others
may be of any type. Contrary to <TT>C</TT> and <TT>C++</TT>, the two
last operands does not need to be of the same type.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>?:</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>ternary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxe</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expr</SPAN> <TT>?</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>first operand is boolean, others are any type</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>type of the evaluated operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>conditional evaluation: evaluates and returns the second operand if
the first operand is true; otherwise evaluates and returns the second operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>true ? "hello" : "world"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"hello"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>true ? 2.3 : "world"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2.3</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>1+1 == 2 ? (a := 3.1415926535) : nil</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>3.1515926535</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>1 ? 3 : nil</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">raises an error</SPAN>: boolean expected, got integer.</TD>
</TR>
</TABLE>
<H2><A NAME="SECTION002514000000000000000"></A> <A NAME="5975"></A>
<BR>
Expression Sequences
</H2>
The expression sequence operator - also called comma sequencing - expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions.
This operator <TT>,</TT> takes two operands: it evaluates both of them
and returns the second one.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>,</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxe</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">expr</SPAN> <TT>,</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>type of the second operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>evaluates the first operand, then the second one.
Returns the evaluation of the second one.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>true, "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>"hello"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>a := 2, 4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>4</TT> (<SPAN  CLASS="textit">note that</SPAN> <TT>a</TT> equals
<TT>2</TT>)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>b := 10, a := b+1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>11</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002515000000000000000"></A> <A NAME="5995"></A>
<A NAME="arraydef"></A>
<BR>
Array Deferencing
</H2>
OQL provides polymorphic single and range deferencing. The single deferencing
is used to get one element in an ordered collection or a character in a string
or one element in a non-collection array. The range deferencing is used to
get several elements.
<BR>
The deferencing of ordered collections is introduced in more details
in Section <A HREF="#collexp">5.24</A>.

<H3><A NAME="SECTION002515100000000000000"></A> <A NAME="5997"></A>
<BR>
Single Deferencing
</H3>
The single deferencing operator takes as its first operand an atom of type
<TT>string</TT>, an indexed 
(or ordered) collection (<TT>list</TT> or <TT>array</TT>)
or a non-collection array. The second operand must be of type <TT>integer</TT>.
Depending on the type of the first operand, the returned atom
is as follows:

<OL>
<LI>if the first operand is a string,
the returned atom is the <TT>#</TT><SPAN  CLASS="textit">expr</SPAN> character of the string
where <SPAN  CLASS="textit">expr</SPAN> denotes the second operand.
If <SPAN  CLASS="textit">expr</SPAN> is equal to the length to the string the character
<TT>'&#92;000'</TT> is returned. If it greater than the length the
string an <SPAN  CLASS="textit">out of bounds</SPAN> error is raised.
</LI>
<LI>for an ordered collection, the returned atom is the
<TT>#</TT><SPAN  CLASS="textit">expr</SPAN> item of the collection. If <SPAN  CLASS="textit">expr</SPAN> is greater
than or is equal to the size of the collection, an
<SPAN  CLASS="textit">out of bounds</SPAN> error is raised.
</LI>
<LI>if the first operand is an non-collection array, the returned atom is the
<TT>#</TT><SPAN  CLASS="textit">expr</SPAN> item of the array. If <SPAN  CLASS="textit">expr</SPAN> is greater
than or is equal to the size of the array, an
<SPAN  CLASS="textit">out of bounds</SPAN> error is raised.
</LI>
</OL>
The single deferencing operator may be used as a left value, that means that a single
deferencing expression is assignable. For instance the sequence of
statements:

<PRE>
s := "hello";
s[1] := 'E';
s[4] := 'O';
</PRE>
set the variable <TT>s</TT> to <TT>"hEllO"</TT>.

<BR>
<BR>
The single deferencing operator may be used everywhere in a path expression.
For instance, <TT>first(select Person).other_addrs[2].street[3]</TT>,
denotes the character <TT>#3</TT> of the <TT>street</TT> attribute
in the <TT>#2</TT> <TT>other_addrs</TT> non-collection array attribute of
the first <TT>Person</TT> instance.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>[]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxe</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>[</TT><SPAN  CLASS="textit">expr</SPAN> <TT>]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Commutative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>no</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>first operand: <TT>string</TT>, indexed collection
(<TT>list</TT> or <TT>array</TT>) or non-collection array,
 second operand: <TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>char</TT> if first operand is a string,
otherwise type of the returned item in the indexed collection or non-collection
array.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>[</TT><SPAN  CLASS="textit">expr</SPAN> <TT>]</TT> : returns the character (or item in the
indexed collection or in the non-collection array) number <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Note</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>this operator may be used in the composition of a left value.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textit">result</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>"hello"[0]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>'h'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>a := "hello"; a[1]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>'e'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>a[3]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>l</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>a[6]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textit">raises an error</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>a[0] := 'H'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>'H'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>a</TT> equals
 <TT>"Hello"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>list(1, 2, "hello", 4)[3]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>"hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>list(1, 2, "hello", 4)[4]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textit">raises an error</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>first(select Person).name[2] := 'X'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>'X'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002515200000000000000"></A> <A NAME="6020"></A>
<BR>
Range Deferencing
</H3>
The range deferencing operators, <TT>[:]</TT> and <TT>[?]</TT>,
takes as their first operand an atom of type
<TT>string</TT>, an indexed 
(or ordered) collection (<TT>list</TT> or <TT>array</TT>)
or a non-collection array. The other operands must be of type <TT>integer</TT>.
The <TT>[?]</TT> may have also an unordered collection (<TT>set</TT>
or <TT>bag</TT> as its first operand.
<BR>
<BR>
The operator syntax and semantics are as follows:

<UL>
<LI><SPAN  CLASS="textit">expr</SPAN> <TT>[</TT><SPAN  CLASS="textit">expr1</SPAN><TT>:</TT><SPAN  CLASS="textit">expr2</SPAN><TT>]</TT>

<OL>
<LI>if the first operand is a string,
the returned atom is a list composed of the characters between
the <TT>#</TT><SPAN  CLASS="textit">expr1</SPAN> and the <TT>#</TT><SPAN  CLASS="textit">expr2</SPAN> characters
of the string.
If <SPAN  CLASS="textit">expr1</SPAN> is less than zero or or if <SPAN  CLASS="textit">expr2</SPAN> is greater than the
length of the string an <SPAN  CLASS="textit">out of bounds</SPAN> error is raised.
</LI>
<LI>for an ordered collection, the returned atom is a list composed
of the items between the <TT>#</TT><SPAN  CLASS="textit">expr1</SPAN> and the
<TT>#</TT><SPAN  CLASS="textit">expr2</SPAN> items
of the collection. If <SPAN  CLASS="textit">expr1</SPAN> is less than zero or if
i <SPAN  CLASS="textit">expr2</SPAN> iss greater than or is equal to the size of the collection, an
<SPAN  CLASS="textit">out of bounds</SPAN> error is raised.
</LI>
<LI>if the first operand is an non-collection array, the returned atom
is a list composed of the items between the <TT>#</TT><SPAN  CLASS="textit">expr1</SPAN> and the
<TT>#</TT><SPAN  CLASS="textit">expr2</SPAN> items of the array.
If <SPAN  CLASS="textit">expr1</SPAN> is less than zero or if
i <SPAN  CLASS="textit">expr2</SPAN> iss greater than or is equal to the size of the collection, an
<SPAN  CLASS="textit">out of bounds</SPAN> error is raised.
</LI>
</OL>
</LI>
<LI><SPAN  CLASS="textit">expr</SPAN> <TT>[?]</TT>

<OL>
<LI>if the first operand is a string,
the returned atom is a list composed of all the characters of the
string, including the last character <TT>'&#92;000'</TT>.
</LI>
<LI>for an ordered or an unordered collection, the returned atom is a list composed
of all the items of the collection. If the collection is a list, the
list itself is returned. If the collection is an array, this operator
has the same functionnality as the <TT>listtoarray</TT> library function.
</LI>
<LI>if the first operand is an non-collection array, the returned atom
is a list composed of the all the items of the array.
</LI>
</OL>
</LI>
</UL>
Contrary to the single deferencing operator,
the range deferencing operator cannot be used as a left value.
<BR>
<BR>
The range deferencing operators may be used everywhere in a path expression.
For instance, <TT>first(select Person).children[?].name[?]</TT>,
denotes the list of all characters of the <TT>name</TT> attribute
in all the <TT>children</TT> of the first <TT>Person</TT> instance.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>[:]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>[?]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>[</TT><SPAN  CLASS="textit">expr</SPAN> <TT>:</TT><SPAN  CLASS="textit">expr</SPAN> <TT>]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>[?]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ternary or unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>first operand: <TT>string</TT> or indexed collections
(<TT>list</TT> or <TT>array</TT>), second operand and third operand:
<TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>a list of <TT>char</TT> if first operand is a string,
otherwise a list of returned items in the indexed collection or
non-collection array.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>[</TT><SPAN  CLASS="textit">expr1</SPAN><TT>:</TT><SPAN  CLASS="textit">expr2</SPAN><TT>]</TT> :
returns a lits of characters (or items in collection) indexed
from <SPAN  CLASS="textit">expr1</SPAN> to <SPAN  CLASS="textit">expr2</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>[?]</TT> :
returns a list of all characters (or items in collection)</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>"hello"[0:2]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list('h', 'e', 'l')</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>"hello"[?]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list('h', 'e', 'l', 'l', 'o', '&#92;000')</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>list(1, 2, "hello", 4)[2:3]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list("hello", 4)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>array(1, 2, "hello", 4)[?]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list(1, 2, "hello", 4)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>first(select Person).name[?]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list('j', 'o', 'h', 'n', '&#92;000')</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>list(select class.type = "user")[0:4].name</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list("Employee", "Address", "Person")</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002516000000000000000"></A> <A NAME="6047"></A>
<BR>
Identifier Expressions
</H2>
We call an identifier expression an unary or binary expression whose operands
must be identifiers. There are height identifier operators: <TT>::</TT>,
<TT>isset</TT>, <TT>unset</TT>,  <TT>&amp;</TT> (identical to <TT>refof</TT>),
 <TT>*</TT> (identical to <TT>valof</TT>), <TT>scopeof</TT>, <TT>push</TT>
and <TT>pop</TT>.

<BR>
<BR>
As all these operators take identifiers as their operands,
we skip the second table (operand combinations) while introducing these
operators.

<H3><A NAME="SECTION002516100000000000000">
<TT>::</TT> Operator</A>
</H3> <A NAME="6052"></A>
The <TT>::</TT> unary/binary operator (called scope operator) is used to
define a global or particular scope for a variable.

<BR>
The unary version of this operator denotes a global scope.
For instance, <TT>::alpha</TT> denotes the global variable <TT>alpha</TT>.
In the body of a function, identifiers denote local variables; outside
the body of a function identifiers denote global variables, that means
that, in this context, the global scope operator is not mandatory.
If one wants to use a global variable in the body of a function, the
global scope operator is mandatory.
Refer to the Function Definition Statement Section for more information
about local function variables.
<BR>
<BR>
The binary version of this operator denotes a particular scope.
For instance, <TT>Person::checkName</TT> denotes the class attribute
or method of the class <TT>Person</TT>.

<BR>
<BR><SPAN  CLASS="textit">note</SPAN>: class (or static) attributes are not currently well supported
by the OQL interpreter. Class attributes are only supported in some
specific query expressions (refer to the Query Expression Section).

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>::</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>::</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>identifier::identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>unary and binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>identifier </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>value of the identifier if used as a right value;
identifier reference if used as a left value</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>defines a global or particular scope for the identifier.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=119><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=119><TT>::a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>the value of the global variable <TT>a</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=119><TT>::alpha := 1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>sets the value of the global variable
<TT>alpha</TT> to <TT>1</TT>, returns <TT>1</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=119><TT>Person::checkName("wayne")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>calls the class method
<TT>checkName</TT> in the class <TT>Person</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=119><TT>2::alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002516200000000000000">
<TT>isset</TT> Operator</A>
</H3> <A NAME="6075"></A>
The <TT>isset</TT> operator is used to check whether a variable
is already set or not. It returns <TT>true</TT> is the variable is
set, <TT>false</TT> otherwise.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>isset</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>isset</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>identifier </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>evaluated to <TT>true</TT> if the identifier is set, <TT>false</TT> otherwise</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>isset oql$variables</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>isset a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>returns <TT>true</TT> if <TT>a</TT> is set, <TT>false</TT> otherwise</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>isset 1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002516300000000000000">
<TT>unset</TT> Operator</A>
</H3> <A NAME="6098"></A>
The <TT>unset</TT> operator is used to unset an variable. It returns the
<TT>nil</TT> atom.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>unset</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>unset</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>identifier </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>unset the identifier</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>unset a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>unset ::a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>unset 2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002516400000000000000">
<TT>refof</TT> Operator</A>
</H3> <A NAME="6125"></A>
The <TT>&amp;</TT> (identical to <TT>refof</TT>) operator is used to get the 
reference of an identifier. This operator is essentially used when
one calls a function or method which updates one or more given parameters.
For instance, let the function <TT>swap(x, y)</TT> which swaps the value
of its two parameters. One needs to give the references of the
variables that one wants to swap. For instance:

<PRE>
i := "ii";
j := "jj";

swap(&amp;i, &amp;j);
</PRE>
After the call to <TT>swap</TT>, the variable <TT>i</TT> equals
<TT>jj</TT> while the variable <TT>j</TT> equals <TT>ii</TT>.
<BR>
The reverse operator <TT>*</TT> (described following section) is used in
the swap function.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>refof</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>&amp;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>refof</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>&amp;</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>identifier </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>evaluates the expression to the identifier reference; returned an
identifier atom</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>&amp;alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>alpha</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>refof alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>alpha</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002516500000000000000">
<TT>valof</TT> Operator</A>
</H3> <A NAME="6151"></A>
The <TT>*</TT> (identical to <TT>valof</TT>) operator is used to get
the value of the identifier pointed by a reference.
For instance, after the two following expressions:

<PRE>
alpha := 1;
ralpha := &amp;alpha;
</PRE>
<TT>*ralpha</TT> equals <TT>1</TT>.
<BR>
<BR>
This operator may be used in the composition of a left value, for instance:

<PRE>
alpha := 1;
ralpha := &amp;alpha;
*ralpha := 2; // now, alpha equals 2
*ralpha += 8; // now, alpha equals 10
</PRE>
But this operator is essentially used in the body of functions or methods which
update one or more given parameters, for instance, the function <TT>swap</TT>
described in the previous section is as follows:

<PRE>
function swap(x, y) {
    v := *x;
   *x := *y;
   *y := v;
}
</PRE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>valof</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>*</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>valof</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>*</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>identifier </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>value of the identifier</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the value of the identifier denotes by the operand</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>*alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>if <TT>alpha</TT> value is an atom identifier <SPAN  CLASS="textit">x</SPAN>,
returns the value of <SPAN  CLASS="textit">x</SPAN>, otherwise an error is thrown</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>x := 12; alpha := &amp;x; *x</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>*x</TT> returns <TT>12</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002516600000000000000">
<TT>scopeof</TT> Operator</A>
</H3> <A NAME="6175"></A>
The <TT>scopeof</TT> operator returns the string <TT>"global"</TT> or
<TT>"local"</TT> depending whether the identifier is global or local.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>scopeof</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>scopeof</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>identifier </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the scope of the identifier.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>scopeof ::alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>returns <TT>"global"</TT> for any <TT>alpha</TT> if
it set; otherwise an error is thrown</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>scopeof alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>returns <TT>"global"</TT> or <TT>"local"</TT>
depending on the context.</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002516700000000000000">
<TT>push</TT> Operator</A>
</H3> <A NAME="6199"></A>
The <TT>push</TT> operator is used to push an identifier on a new local
table. This operator is rarely used.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>push</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>push</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>push</TT> <SPAN  CLASS="textit">identifier</SPAN> <TT>:=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>unary and binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>first operand <TT>identifier</TT>, optionnal second operand:
<SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>identifier or any type in case of an assignment</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>push the identifier on to the symbol table stack. An assignment
can be performed at the same time. Returns the identifier or the
value of the expression assignment.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>push a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>pushes <TT>a</TT> on a new local symbol table.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>push a := 10</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>pushes <TT>a</TT> on a new local symbol table
and assigns its value to <TT>10</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002516800000000000000">
<TT>pop</TT> Operator</A>
</H3> <A NAME="6226"></A>
The <TT>pop</TT> operator is used to pop an identifier from a local table.
It is used after a push. For instance:

<PRE>
a := "hello";
a;             // a equals "hello"

push a := 10;
a;             // a equals 10

pop a;
a;             // a equals "hello"
</PRE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>pop</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>pop</TT> <SPAN  CLASS="textit">identifier</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>identifier </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>the type of the value of the identifier</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>pop the identifier from the symbol table stack</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>pop a</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>returns the value of <TT>a</TT> if it is set; otherwise
an error is returned</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002517000000000000000"></A> <A NAME="6247"></A>
<BR>
Path Expressions
</H2>
The path expression operator <TT>-&gt;</TT> (identical to <TT>.</TT>) is used
to <SPAN  CLASS="textit">navigate</SPAN> from an object
and read the right data one needs. This operator enables us to go
inside complex objects, as well as to follow simple relationships.
For instance, if <TT>p</TT> denotes a <TT>Person</TT> instance,
<TT>p.spouse</TT> denotes the <TT>spouse</TT> attribute of this person.
<BR>
The more complex expression <TT>p.spouse.address.street</TT> denotes
the <TT>street</TT> in the <TT>address</TT> of <TT>spouse</TT> of the
person <TT>p</TT>. This notation is very intuitive because it looks like the
well known <TT>C</TT>, <TT>C++</TT> and <TT>Java</TT> syntaxes.
<BR>
<BR>
The path expression operator may composed a left value, for instance:
<PRE>
p.spouse.name := "mary";
</PRE>
set the <TT>name</TT> of the <TT>spouse</TT> of the person <TT>p</TT>
to <TT>mary</TT>.
<BR>
<BR>
This operator may be combined with the array deferencing operators, for
instance:
<PRE>
p.spouse.name[2];
p.spouse.name[2] := 'A';
p.spouse.other_addrs[2].street[3] := 'C';
p.spouse.children[?];
p.spouse.children[?].name;
</PRE>
The path expression operator may be also used to navigate through
<TT>struct</TT> atom, for instance:
<TT>(struct(a : 1, b : "hello")).b</TT> returns <TT>"hello"</TT>. Note
that because of the precedence of operators, parenthesis are necessary
around the literal <TT>struct</TT> construct.
<BR>
Finally, the path operator may be applied to a collection; in this
case a collection of the same type of this operand is returned.
For instance:
<BR><TT>(select Person).name</TT> returns a <TT>bag</TT> of <TT>string</TT>.
<BR><TT>(select distinct Person).age</TT> returns a <TT>set</TT> of
<TT>int</TT>.
<BR>
Note that the path expression operator is used frequently in the query
expressions as shown in a next section.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>.</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>-&gt;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>.</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>-&gt;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>first operand: <TT>oid</TT> or <TT>object</TT>,
second operand: identifier</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>type of the attribute denoted by the second operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>returns the attribute value denoted by second operand of the object
denoted by the first operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>The first operand must denote an E<SMALL>YE</SMALL>DB instance (object or literal) of
an agregat including the attribute denoted by the second operand.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Note</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>these two operators are identical</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">result</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">comments</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>p-&gt;name</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">the value of attribute</SPAN>
<TT>name</TT> <SPAN  CLASS="textit">in the object denoted by</SPAN> <TT>p</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>p</TT> must denote an E<SMALL>YE</SMALL>DB instance (object or literal) of
an agregat including the attribute <TT>name</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>first(select x Person x from x.lastname = "wayne")-&gt;lastname</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"wayne"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002518000000000000000"></A> <A NAME="6270"></A>
<BR>
Function Call
</H2>
OQL allows one to call an OQL function with or without parameters.
The operator for function call is <TT>()</TT>.
<BR>
A function call may be the first term of a path expression, for instance:
<TT>first(select Person)-&gt;name</TT>.
<BR>
Contrary to the method invocation, there are no function overloading
mechanisms: that means, that one cannot have differents functions with
the same name and a different signature.
To take benefit of the overloading mechanisms, one must use methods.

<BR><SPAN  CLASS="textit">Note</SPAN>: contrary to the ODMG 3 specifications, one currently needs
to use parenthesis to invoke a method even if the method has no arguments.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>()</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxe</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>(</TT><SPAN  CLASS="textit">expr_list</SPAN><TT>)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>n-ary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>first operand: <TT>identifier</TT>,
other operands: <SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Returned type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>type of the returned atom by the function call</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>calls the OQL function denoted by the first operand using the other operands
as arguments. The number of operands must be equal to the number of
arguments of the OQL function plus one</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>fact(10)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>3628800</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>fact(fact(3))</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>720</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>toUpper("hello world")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"HELLO WORLD"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>toUpper("hello") + "world"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"HELLOworld"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>interval(1, 5)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>list(1, 2, 3, 4, 5)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>swap(&amp;i, &amp;j)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>first(select Person).spouse.name</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>"mary"</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002519000000000000000"></A> <A NAME="6286"></A>
<BR>
Method Invocation
</H2>

<H3><A NAME="SECTION002519100000000000000"></A> <A NAME="6288"></A>
<BR>
Instance Method Invocation
</H3>
OQL allows one to call a instance method with or without parameters.
The method can be written in C++ or in OQL.
As in C++, method calls use a combination of the path expression operator and
the function call operator.
<BR>
<BR>
As in <TT>C++</TT> or <TT>Java</TT>, methods can be overloaded: that
means that one can have differents methods with the same name and a
different signature or differents methods with the same name
and the same signature in a class hierarchy.
The choice of the method to invoke
is done at evaluation time not at compile time.
For instance let two
methods <TT>Person Person::f(in int, in int)</TT> and <TT>int Person::f(in float, in string)</TT>,
the method to be invoked in the expression <TT>p-&gt;f(x, y)</TT> is decided
at evaluation time according to the true types of <TT>x</TT> and <TT>y</TT>:

<PRE>
p := first(select Person);

x := 1; y := 2;

p-&gt;f(x, y); // X::f(in int, in int) is invoked
p-&gt;f(x, y)-&gt;name; // this is valid because p-&gt;f(x, y) returns a Person

x := 1.3; y := "hello";

p-&gt;f(x, y); // X::f(in float, in string) is invoked
p-&gt;f(x, y)-&gt;name; // this is not valid because p-&gt;f(x, y) returns an integer
</PRE>
A major contribution of object orientation is the possibility of manipulating
polymorphic objects and thanks to the late binding mechanism
to carry out generic actions on the elements of these objects.
<BR>
For instance, let the two
methods <TT>void Person::doit(in int)</TT>
and <TT>void Employee::doit(in int)</TT>,
the method to be invoked in the expression <TT>p-&gt;doit(x)</TT> is decided
at evaluation time according to the true type of <TT>p</TT>:

<PRE>
p := new Person();
p-&gt;doit(1); // Person::doit(in int) is invoked

p := new Employee();
p-&gt;doit(1); // Employee::doit(in int) is invoked
</PRE>
To invoke a method, the following conditions must be realize:

<OL>
<LI>the object or oid on which the method is applied must be
an instance of a class, for instance <TT>X</TT>.
</LI>
<LI>the name of the invoked method, the number and the type of arguments
must be compatible with an existing method in the class <TT>X</TT>,
</LI>
<LI>the result type must match the expected type in the expression.
</LI>
</OL>
For instance, let the methods <TT>int compute(in int, int float)</TT> and
<TT>int compute(in int, in float, in int[], out string)</TT>
in the class <TT>X</TT>.
To invoke the first method on an instance of <TT>X</TT>, one needs to
apply the method <TT>compute</TT> to an instance of <TT>X</TT>
with one integer and one float, for instance:

<PRE>
x := new X();

x.compute(1, 2.3);
x.compute(a := fact(10), float(fib(10)));
</PRE>
To invoke the second method on an instance of <TT>X</TT>, one needs to
apply the method <TT>compute</TT> to an instance of <TT>X</TT>
with an integer, a float, an ordered collection of integer and a reference
to a variable, for instance:

<PRE>
x.compute(1, 23.4, list(1, 2, 3, 4), &amp;a);
</PRE>
The following table shows the mapping (which defines the compatibility)
between the ODL and the OQL types.

<BR>
<BR>

<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">ODL/OQL Mapping</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>ODL Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>OQL Type</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>int16</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>int16</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>int16</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit">n</SPAN> <TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>int32</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>int32</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>int32</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit">n</SPAN> <TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>int64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>int64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>int64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit">n</SPAN> <TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>byte</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>byte</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>byte</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit"></SPAN> <TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit"></SPAN> <TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit"></SPAN> <TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit"></SPAN> <TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>oid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit"></SPAN> <TT>oid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>object *</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>oid</TT> of any class</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>object *</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>object *</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit">n</SPAN> <TT>oid</TT> of any class</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>X *</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes a class instance</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>oid</TT> of class <TT>X</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>X *</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes a class instance</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>X *</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes a class instance</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit"></SPAN> <TT>oid</TT> of class <TT>X</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>X *[]</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes a class instance</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>ordered collection of <TT>oid</TT> of class <TT>X</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>X *[]</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes a class instance</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>X *[]</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes a class instance</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit">n</SPAN> ordered collection of <TT>oid</TT> of class <TT>X</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>in</TT> <TT>X[]</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes any ODL type</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">ordered collection</SPAN> of atoms bound to <TT>X</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>out</TT> <TT>X[]</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes any ODL type</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>inout</TT> <TT>X[]</TT> (<TT>X</TT> <SPAN  CLASS="textit">denotes any ODL type</SPAN>)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>identifier</TT> initialized to a<SPAN  CLASS="textit">n</SPAN> <SPAN  CLASS="textit">ordered collection</SPAN> of atoms bound to <TT>X</TT></TD>
</TR>
</TABLE>
<SPAN  CLASS="textit">Note</SPAN>: contrary to the ODMG 3 specifications, one currently needs
to use parenthesis to invoke a method even if the method has no arguments.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operators</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>.</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>-&gt;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>.</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>(</TT><SPAN  CLASS="textit">expr_list</SPAN><TT>)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>-&gt;</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>(</TT><SPAN  CLASS="textit">expr_list</SPAN><TT>)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>n-ary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>first operand: <TT>oid</TT> or <TT>object</TT>,
second operand: identifier, other operands: any type</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>type of the atom returned by the method call</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>invokes the method denoted by the second operand applied to the
object denoted by the first operand, using the other operands as arguments.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>The first operand must denote an E<SMALL>YE</SMALL>DB instance (object or literal) of
an agregat including the method whose name is the second operand.
The number of arguments and the type of arguments must match one of
the methods included in the class of the object denoted by the first operand.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Note</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>these two operators are identical</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">result</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">comments</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>p-&gt;getOid()</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">the value of the oid of object denoted by</SPAN>
<TT>p</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>as <TT>getOid()</TT> is a native method of the class
<TT>object</TT>, each object can call
this method</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>img-&gt;compute(1, 2.3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">the value returned by the method call</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>the first operand must denote an E<SMALL>YE</SMALL>DB instance (object or literal) of
an agregat including the method whose name is <TT>compute</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>first(select Person.name = "wayne").getSpouse()</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">the value returned by the method call</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002519200000000000000"></A> <A NAME="6772"></A>
<BR>
Class Method Invocation
</H3>
OQL allows one to call a class method with or without parameters.
The method can be written in C++ or in OQL.
As in C++, method calls use a combination of the scope operator and
the function call operator.
To invoke a class method, the following conditions must be realize:

<OL>
<LI>the name of the invoked method, the number and the type of arguments
must be compatible with an existing method in the class <TT>X</TT>,
</LI>
<LI>the result type must match the expected type in the expression.
</LI>
</OL>
The overloading and the late binding mechanisms are the same as for
the instance method invocations.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>::</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxe</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>identifier::identifier(</TT><SPAN  CLASS="textit">expr_list</SPAN><TT>)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>n-ary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>first operand: <TT>identifier</TT>,
second operand: <TT>identifier</TT>,
other operands: <SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>type of the atom returned by the method call</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>invokes the class method denoted by the second operand applied to the
class denoted by the first operand, using the other operands as arguments.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>The first operand must denote an E<SMALL>YE</SMALL>DB class of
an agregat including the class method whose name is the second operand.
The number of arguments and the type of arguments must match one of
the class methods included in the class denoted by the first operand.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">result</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">comments</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>EyeDB::getVersion()</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>2.8.8</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>getVersion()</TT> is a native static method of the class <TT>EyeDB</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>Person::checkName("johnny")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><SPAN  CLASS="textit">the value returned by the method call</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>the class method <TT>checkName</TT> must exist in the class <TT>Person</TT>
and must take one and only one input string argument.</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002520000000000000000"></A> <A NAME="6790"></A>
<BR>
Eval/Unval Operators
</H2>

<H3><A NAME="SECTION002520100000000000000">
<TT>eval</TT> Operator</A>
</H3> <A NAME="6795"></A>
One major feature of OQL is that one can invoke its evaluator using
the <TT>eval</TT> operator. This allows us to build OQL constructs at
runtime and perform their evaluation. This is very useful, for instance,
when we want to build a query expression where the projection or
the <TT>from</TT> reference sets are is unknown. For instance, the following
function allows us to retrieve the values of the attribute <SPAN  CLASS="textit">attrname</SPAN>
in the class <SPAN  CLASS="textit">classname</SPAN>:

<PRE>
function getValues(classname, attrname) {
  cmd := "select x." + attrname + " from " + classname + " x";
  return (eval cmd);
}
</PRE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>eval</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntaxe</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>eval string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string </TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>calls the OQL evaluator on the string operand. The string operand
can contain any OQL valid construct: an expression, a statement or a
sequence of statements.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>eval "10"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>10</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>eval "a := 100"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>result is <TT>100</TT>; the variable <TT>a</TT>
is set to <TT>100</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>eval "a := &#92;"hello&#92;"; b := a + &#92;"world&#92;""</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>result is <TT>"hello world"</TT>; the variable <TT>a</TT> is set to <TT>"hello"</TT>; the variable <TT>b</TT> is set to <TT>"hello world"</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002520200000000000000">
<TT>unval</TT> Operator</A>
</H3> <A NAME="6815"></A>
The <TT>unval</TT> is the inverse of the <TT>unval</TT> in the sense
that it takes any valid OQL expression and returns the string representation;
the comments and, when not necessary,
the spaces and tabulations are skipped.
For instance, the construct <TT>unval a := 10</TT> returns
<TT>"(a:=10)"</TT>.
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>unval</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>unval</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>returns the string expression</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>unval 10</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"10"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>unval alpha += 10 - beta + 1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"(alpha:=(alpha+((10-beta)+1)))"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>eval unval alpha := "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns <TT>"hello"</TT>;
<TT>alpha</TT> is set to <TT>"hello"</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002521000000000000000"></A> <A NAME="6833"></A>
<BR>
Set Expressions
</H2>
OQL allows us to perform the following operations on <TT>set</TT>s and
<TT>bag</TT>s: union, intersection,
difference and inclusion. The operands can be sets or bags.
For all these operators, when the operand's collection types are different
(<TT>bag</TT> and <TT>set</TT>), the set is first converted to a bag and
the result is a bag.

<H3><A NAME="SECTION002521100000000000000">
<TT>union</TT> Operator</A>
</H3>
The <TT>union</TT> operator performs the union of two <TT>set</TT>s or
<TT>bag</TT>s.
This operator has the same precedence as the logical or operator.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>union</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>union</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>set</TT> or <TT>bag</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>set</TT> if both two operands are of type
<TT>set</TT>, <TT>bag</TT> otherwise</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>returns the union of the two operands.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) union set(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2, 3)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) union bag(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>bag(1, 2, 2, 3)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list(1, 2) union bag(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002521200000000000000">
<TT>intersect</TT> Operator</A>
</H3>
The <TT>intersect</TT> operator performs the intersection of two
<TT>set</TT>s or <TT>bag</TT>s.
This operator has the same precedence as the logical and operator.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>intersect</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>intersect</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>set</TT> or <TT>bag</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>set</TT> if both two operands are of type
<TT>set</TT>, <TT>bag</TT> otherwise</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>returns the intersection of the two operands.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><TT>set(1, 2) intersect set(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(2)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><TT>set(1, 2) intersect bag(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>bag(2)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><TT>bag(1, 2, 2, 3) intersect bag(2, 3, 2)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>bag(2, 2, 3)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><TT>list(1, 2) intersect bag(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002521300000000000000">
<TT>except</TT> Operator</A>
</H3>
The <TT>except</TT> operator performs the difference between two
<TT>set</TT>s or <TT>bag</TT>s.
This operator has the same precedence as the logical or operator.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>except</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>except</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>set</TT> or <TT>bag</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>set</TT> if both two operands are of type
<TT>set</TT>, <TT>bag</TT> otherwise</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>returns the difference of the two operands.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) except set(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) except bag(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>bag(1)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2, 10) except bag(12)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>bag(1, 2, 10)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>list(1, 2) except bag(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002521400000000000000">
Inclusion Operators</A>
</H3>	
The inclusion operators for <TT>set</TT>s and <TT>bag</TT>s are
the comparison operators <SPAN  CLASS="textit">less than/greater than</SPAN> introduced in a
previous section.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>&lt;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>&lt;=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>&gt;</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>&gt;=</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>&lt;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>&lt;=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>&gt;</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">expr</SPAN> <TT>&gt;=</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>set</TT> or <TT>bag</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">coll1</SPAN> <TT>&lt;</TT> <SPAN  CLASS="textit">coll2</SPAN> : returns <TT>true</TT> if and only
if <SPAN  CLASS="textit">coll1</SPAN> is included in <SPAN  CLASS="textit">coll2</SPAN> but not equal to <SPAN  CLASS="textit">coll2</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">coll1</SPAN> <TT>&gt;</TT> <SPAN  CLASS="textit">coll2</SPAN> : returns <TT>true</TT> if and only
if <SPAN  CLASS="textit">coll2</SPAN> is included in <SPAN  CLASS="textit">coll1</SPAN> and not equal to <SPAN  CLASS="textit">coll1</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">coll2</SPAN> <TT>&lt;=</TT> <SPAN  CLASS="textit">coll1</SPAN> : returns <TT>true</TT> if and only
if <SPAN  CLASS="textit">coll1</SPAN> is included in <SPAN  CLASS="textit">coll2</SPAN> or equal to <SPAN  CLASS="textit">coll2</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SPAN  CLASS="textit">coll1</SPAN> <TT>&gt;=</TT> <SPAN  CLASS="textit">coll2</SPAN> : returns <TT>true</TT> if and only
if <SPAN  CLASS="textit">coll2</SPAN> is included in <SPAN  CLASS="textit">coll1</SPAN> or equal to <SPAN  CLASS="textit">coll1</SPAN></TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) &lt; set(2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) &lt; set(2, 3, 1)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) &lt; bag(2, 3, 1)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) &lt;= bag(2, 1)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>set(1, 2) &gt;= bag(2, 1)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>false</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002522000000000000000"></A> <A NAME="6911"></A>
<BR>
Object Creation
</H2>
OQL allows us to create persistent or transient objects using the
<TT>new</TT> operator.
The general syntax for an object creation is as follows:
<BR>  [<TT>new</TT>] [<TT>&lt;</TT>[<SPAN  CLASS="textit">expr</SPAN>]<TT>&gt;</TT>] 
<SPAN  CLASS="textit">class_name</SPAN><TT>(</TT>{<SPAN  CLASS="textit">path_expression</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN> }<TT>)</TT>
<BR>
<OL>
<LI>the operator <TT>new</TT> is optionnal: when the operator is missing,
the construct is called an implicit <TT>new</TT> construct. When
the optionnal following construct ``<TT>&lt;</TT>[<SPAN  CLASS="textit">expr</SPAN>]<TT>&gt;</TT>'' is
not used, there is
no functionnal differences between using <TT>new</TT> or not.
</LI>
<LI>the optionnal construct after the <TT>new</TT> operator indicates
the target location of the object to create:

<OL>
<LI>if this construct is omitted, the object will be a 
persistent object created in the current default database,
</LI>
<LI>if this construct is under the form <TT>&lt;</TT><SPAN  CLASS="textit">expr</SPAN><TT>&gt;</TT>,
the OQL interpreter expects for a database object handle as the result
of the expression evaluation. This database will be used as the target
location. For instance:

<PRE>
new &lt; oql$db &gt; Person();
</PRE>
will create a <TT>Person</TT> instance in the database pointed by
<TT>oql$db</TT>, which is in fact the current database.
</LI>
<LI>if this construct is under the form <TT>&lt;&gt;</TT>,
the object will be a transient object.
</LI>
</OL>
</LI>
<LI>the <SPAN  CLASS="textit">class_name</SPAN> indicates the name of a valid user
type in the context of the current database.
</LI>
<LI>the <SPAN  CLASS="textit">path_expression</SPAN> indicates an attribute name or
a sequence of attributes using the optional array operator, for instance
the following path expressions are valid for an object construction:

<PRE>
name
lastname
addr.street
addr.town[3]
spouse.name
</PRE>
</LI>
<LI>the <SPAN  CLASS="textit">expr</SPAN> behind <SPAN  CLASS="textit">path_expression</SPAN> is any OQL expression
as soon as its result type matches the expected type of the <SPAN  CLASS="textit">path_expression</SPAN>.
</LI>
<LI>the order of evaluation of the expressions is in the
{<SPAN  CLASS="textit">path_expression</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN>} sequence is from left
to right.
</LI>
<LI>the expression returns the oid of the created object.
</LI>
</OL>
For instance:

<UL>
<LI><TT>new Person()</TT> creates a person with all its attributes
unitialized,
</LI>
<LI><TT>Person()</TT> creates a person with all its attributes
unitialized,
</LI>
<LI><TT>new Person(name : "john")</TT> creates a person with its
attribute <TT>name</TT> initialized to <TT>john</TT>,
</LI>
<LI><TT>Person(name : "john")</TT> creates a person with its
attribute <TT>name</TT> initialized to <TT>john</TT>,
</LI>
<LI><TT>new Person(name : "john", age : 32, spouse : new Person(name :
"mary"))</TT> creates a person named <TT>mary</TT> and a person named
<TT>john</TT>, age <TT>32</TT> whose <TT>spouse</TT> is the person
<TT>mary</TT>.
</LI>
</UL>
The <TT>new</TT> operator can also be used to create basic type
object. Note that in this case, the operator is mandatory.
The syntax for basic type creation is as follows:
<BR>  <TT>new</TT> [<TT>&lt;</TT>[<SPAN  CLASS="textit">expr</SPAN>]<TT>&gt;</TT>] <SPAN  CLASS="textit">basic_type</SPAN>
<TT>(</TT><SPAN  CLASS="textit">value</SPAN><TT>)</TT>.

<OL>
<LI>where <SPAN  CLASS="textit">basic_type</SPAN> denotes an ODL basic type.
It may be one of the following type:
<TT>int32</TT>, <TT>int16</TT>, <TT>int32</TT>,
<TT>char</TT>, <TT>byte</TT>, <TT>float</TT> or <TT>oid</TT>. Note
that the type <TT>string</TT> is not allowed here.
</LI>
<LI>the <SPAN  CLASS="textit">value</SPAN> must be an atomic value of an OQL type mapped
from the ODL basic type
</LI>
</OL>
For instance:

<UL>
<LI><TT>new int(2)</TT>
</LI>
<LI><TT>new float(2.3)</TT>
</LI>
<LI><TT>new float(2)</TT>
</LI>
<LI><TT>new char('a')</TT>
</LI>
<LI><TT>new oid(first(select Person))</TT>
</LI>
</UL>
Finally, the <TT>new</TT> operator can be also used to create collections.
The syntax for collection creation is as follows:
<BR>  [<TT>new</TT>] [<TT>&lt;</TT>[<SPAN  CLASS="textit">expr</SPAN>]<TT>&gt;</TT>] <SPAN  CLASS="textit">coll_type</SPAN><TT>&lt;</TT>
<SPAN  CLASS="textit">class_name</SPAN> [, <SPAN  CLASS="textit">coll_name]</SPAN><TT>&gt; (</TT>[<SPAN  CLASS="textit">collection of elements</SPAN>]<TT>)</TT>

<OL>
<LI>the <TT>new</TT> operator is optionnal,
</LI>
<LI>where <SPAN  CLASS="textit">coll_type</SPAN> denotes type of the collection:
<TT>set</TT>, <TT>bag</TT>, <TT>array</TT> or <TT>list</TT>,
</LI>
<LI>the <SPAN  CLASS="textit">class_name</SPAN> denotes the name of the class
of the elements of the collection, for instance <TT>Person*</TT>,
<TT>Car*</TT>,
</LI>
<LI><SPAN  CLASS="textit">coll_name</SPAN> is an optionnal string which denotes the name
of the collection to create,
</LI>
<LI>the optionnal <SPAN  CLASS="textit">collection of elements</SPAN> within parenthesis
contains the elements (generally oids) to insert initially in
the created collection,
</LI>
<LI>the expression returns the oid of the created collection.
</LI>
</OL>
For instance:

<UL>
<LI><TT>new set&lt;Person *&gt;()</TT> creates an empty <TT>set</TT> of persons,
</LI>
<LI><TT>new set&lt;Person *&gt;(list(select Person))</TT> creates a <TT>set</TT> containing
all the persons in the database,
</LI>
<LI><TT>new set&lt;Person *, "all babies"&gt;(list(select Person.age &lt; 1))</TT> creates a <TT>set</TT> named <TT>all babies</TT> containing
all the persons whose age is less than <TT>1</TT>.
</LI>
<LI><TT>new array&lt;Car *&gt;()</TT> creates an empty <TT>array</TT> of cars.
</LI>
<LI><TT>new array&lt;int&gt;(list(1, 2, 3, 4)</TT> creates an <TT>array</TT>
of integers initially containing <TT>1, 2, 3, 4</TT>.
</LI>
<LI><TT>new set&lt;int *&gt; (list(new int(2), new int(10)))</TT> creates
a <TT>set</TT> of integer objects containing initially two
integer objects.
</LI>
</UL>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>new</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>new</TT> [<TT>&lt;</TT>[<SPAN  CLASS="textit">expr</SPAN>]<TT>&gt;</TT>] 
<SPAN  CLASS="textit">class_name</SPAN><TT>(</TT>{<SPAN  CLASS="textit">path_expression</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN> }<TT>)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>n-ary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT> or <TT>object</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>creates an persistent or transient object</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><PRE>
john := new Person(name: "john",
                   lastname: "wayne",
                   age : fib(10));
</PRE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the oid of the created <TT>Person</TT> instance</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><PRE>
new Person(name: "mary",
           lastname: "poppins",
           addr.town : "jungle",
           addr.street[0] : 'a',
           addr.street[1] : 'b',
           spouse : john,
           spouse.age : 72
           );
</PRE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the oid of the created <TT>Person</TT> instance</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002523000000000000000"></A> <A NAME="6942"></A>
<BR>
Object Deletion
</H2>
The <TT>delete</TT> unary operator is used to delete persistent
objects.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>delete</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>delete</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT> or <TT>object</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>the operand type</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>delete a transient or persistent object</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">expression</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">result</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>delete first(select Person)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the oid of the deleted <TT>Person</TT> instance</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>delete new Person()</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the oid of the deleted <TT>Person</TT> instance</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>for (x in (select Person) delete x</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the oids of the deleted <TT>Person</TT> instances</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002524000000000000000"></A> <A NAME="6958"></A>
<A NAME="collexp"></A>
<BR>
Collection Expressions
</H2>
OQL introduces a few operators for object collection manipulation:
one of them is the array deferencing operator ``<TT>[]</TT>''
(<A HREF="#arraydef">5.15</A>) that
is overloaded for ordered collection manipulation.
<BR>
Some them are ODMG OQL compliant, the others are E<SMALL>YE</SMALL>DB extensions.
Object collections may be persistent or transient, orderered or not.
These operators allows us to make the following kind of operations:

<OL>
<LI>gets the contents of a collection: operator <TT>contents</TT>,
</LI>
<LI>get an element at a given position in an ordered collection:
operator <TT>[]</TT> (ODMG compliant),
</LI>
<LI>get elements at some given positions in an ordered collection:
operators <TT>[:]</TT> (ODMG compliant) and <TT>[?]</TT>,
</LI>
<LI>checks if an element is in a collection: operator <TT>in</TT> (ODMG
compliant),
</LI>
<LI>add an element in an unordered collection:
operator <TT>add/to</TT>
</LI>
<LI>suppress an element from an unordered collection:
operator <TT>suppress/from</TT>,
</LI>
<LI>set or suppress an element in an ordered at a given position:
operator <TT>[]</TT>,
</LI>
<LI>set or suppress elements in an ordered at a given position:
operators <TT>[:]</TT> and <TT>[?]</TT>,
</LI>
<LI>append an element in an ordered collection:
operator <TT>append/to</TT>,
</LI>
<LI>checks if a given condition is realized for at least one
element in a collection: operator <TT>in</TT> (ODMG compliant),
</LI>
<LI>checks if a given condition is realized for all
elements in a collection: operator <TT>for/all</TT> (ODMG compliant),
</LI>
<LI>checks if a given condition is realized for a given
number range of elements in a collection: operator extended <TT>for</TT>.
</LI>
</OL>
In all the following examples, the OQL variables <TT>p0</TT> denotes
the first <TT>Person</TT> instance in the database:
<TT>p0 := first(select Person)</TT>.
<BR>
<BR><B>Important Note</B>: although they are reference in the following
descriptions of collection operators,
the object collections <TT>list</TT> are not
implemented in the current version of E<SMALL>YE</SMALL>DB. 

<H3><A NAME="SECTION002524100000000000000">
<TT>contents</TT> Operator</A>
</H3> <A NAME="6967"></A>
The <TT>contents</TT> unary operator is used to give the contents of
a given ordered or unordered object collection. It returned an OQL
collection of the same type of the object collection: <TT>set</TT>,
<TT>bag</TT>, <TT>array</TT> or <TT>list</TT>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>contents</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>contents</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT> or <TT>object</TT> collection</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>a collection of objects</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the contents of an object collection</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>contents(p0.children)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>an <TT>array</TT> of <TT>Person</TT> <TT>oid</TT>s</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>select contents(x.children) from Person x</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns a <TT>list</TT> of <TT>array</TT>s of <TT>Person</TT> <TT>oid</TT>s.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>contents(list(1, 2, 3))</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN>: 
<TT>oid or object expected, got list</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524200000000000000">
<TT>in</TT> Operator</A>
</H3> <A NAME="6990"></A>
The <TT>in</TT> operator is used to check if a given element is
in ordered or unordered object collection.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>in</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">expr</SPAN> <TT>in</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: <SPAN  CLASS="textit">any type</SPAN>,
second operand: <TT>oid</TT> or <TT>object</TT> collection</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns <TT>true</TT> if the first operand belongs to the collection
pointed by the second operand; <TT>false</TT> otherwise</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>first(select Person.name = NULL) in p0.children</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns true if the first <TT>Person</TT> instance
whose <TT>name</TT> is unitialized
is in the <TT>array</TT> of <TT>children</TT> of the first <TT>Person</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>first(select Car.brand = "renault") in p0.cars</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns true if the first <TT>Car</TT> instance whose
<TT>brand</TT> equals <TT>renault</TT>
is in the <TT>set</TT> of <TT>cars</TT> of the first <TT>Person</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524300000000000000">
<TT>add/to</TT> Operator</A>
</H3> <A NAME="7013"></A>
The <TT>add/to</TT> operator is used to add an element in an
unordered collection (<TT>set</TT> or <TT>bag</TT>).

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>add/to</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>add</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>to</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: <SPAN  CLASS="textit">any type</SPAN>,
second operand: <TT>oid</TT> or <TT>object</TT> unorderered collection
(<TT>set</TT> or <TT>bag</TT>)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>type of the first operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>adds the first operand to the non-indexed collection (i.e. bag or set)
pointed by the second operand; returns the first operand.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>add new Car(num : 100) to
p0.cars</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the created <TT>Car</TT> oid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>add new Person(name : "john") to
p0.children</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN>: <TT>cannot used non indexed insertion in an array</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>add new Car() to new set&lt;Car *&gt;()</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the just created car; but we have <SPAN  CLASS="textit">lost</SPAN> the
oid of the just created <TT>set</TT> of cars!</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>add new Person() to (c := new bag&lt;Person *&gt;())</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the just created person; the created bag has been kept in
the OQL variable <TT>c</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524400000000000000">
<TT>[]</TT> Operator</A>
</H3> <A NAME="7036"></A>
The polymorphic <TT>[]</TT> operator is used to set or get an element in an
ordered collection (<TT>array</TT> or <TT>list</TT>) at a given position:
it can be used in a right or left value.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>[]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">expr</SPAN> <TT>[</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: collection <TT>array</TT> or
<TT>list</TT>, second operand: <TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>the type of the element,</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>gets the element in the collection pointed by the first operand
at the position pointed by the second operarand. If used at a left
value, gets a reference to that element.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[0]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the child at position #0 in <TT>p0.children</TT> collection.
Returns <TT>nil</TT> if there is no child at this position</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[0] := Person(name : "john")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the created <TT>Person</TT> oid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[12039] := Person(name : "henry")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the created <TT>Person</TT> oid. This expression is valid in
any cas as the collection <TT>array</TT>s automatically increased its
size</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>(array&lt;Person *&gt;())[0] := new Car(num : 100)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the just created person; but the created array has been ``<SPAN  CLASS="textit">lost</SPAN>''
as it is not tied to any instance and as we did not bind it to any
OQL variable</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>(c := array&lt;Person *&gt;())[0] := new Car(num : 100)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the just created person; the created array has been kept in
the OQL variable <TT>c</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.cars[1] := Car(num : 100)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN>: <TT>array expected, got set</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524500000000000000">
<TT>[:]</TT> Operator</A>
</H3> <A NAME="7059"></A>
The polymorphic <TT>[:]</TT> operator is used to set or get some elements in an
ordered collection (<TT>array</TT> or <TT>list</TT>) at some given positions:
it can be used in a right or left value.
When used in a right value, the returned atom is a <TT>set</TT> of
<TT>struct</TT> with the two attributes <TT>index</TT> and <TT>value</TT>.
In each <TT>struct</TT> element returned, the value of <TT>index</TT> is
the position of the element, the value of <TT>value</TT> is the element
value. Note the returned <TT>struct</TT> elements are not ordered according
to the element postions; it is why a <TT>set</TT> is returned.
When used as a left value, the returned atom is a <TT>set</TT> of
references on the elements .

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>[:]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">expr</SPAN> <TT>[</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>ternary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: collection <TT>array</TT> or
<TT>list</TT>, second and third operands: <TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>the type of the element,</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>gets the elements in the collection pointed by the first operand
at the position range pointed by the second and third operarands.
If used at a left value, gets references to that elements.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[0:1]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns a set of <TT>struct</TT> including the children and the position
of the children position #0 and #1 in the <TT>p0.children</TT> collection.
For instance: <TT>set(struct(index : 0, value : 3874.33.293847:oid),
struct(index : 1, value : 2938.33.1928394:oid))</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Returns <TT>nil</TT> if there is no child at these positions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[0:4] := Person(name : "john")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Sets all the children at the position #0 to #4 to a new <TT>Person</TT> instance.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>returns the created <TT>Person</TT> oid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[12000:12039] := Person(name : "henry")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the created <TT>Person</TT> oid. This expression is valid in
any cas as the collection <TT>array</TT>s automatically increased its
size</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>(array&lt;Person *&gt;(list(Person())))[0]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the just created person within the just created array.
But the array is ``<SPAN  CLASS="textit">lost</SPAN>''
as it is not tied to any instance and as we did not bind it to any
OQL variable</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>(x := array&lt;Person *&gt;(list(Person())))[0]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the just created person; the created array has been kept in
the OQL variable <TT>c</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524600000000000000">
<TT>[?]</TT> Operator</A>
</H3> <A NAME="7082"></A>
The polymorphic <TT>[?]</TT> operator is used to set or get all the
elements in an ordered collection (<TT>array</TT> or <TT>list</TT>).
It can be used in a right or left value.
When used in a right value, the returned atom is a <TT>set</TT> of
<TT>struct</TT> with the two attributes <TT>index</TT> and <TT>value</TT>.
In each <TT>struct</TT> element returned, the value of <TT>index</TT> is
the position of the element, the value of <TT>value</TT> is the element
value. Note the returned <TT>struct</TT> elements are not ordered according
to the element postions; it is why a <TT>set</TT> is returned.
<BR>
When used as a left value, the returned atom is a <TT>set</TT> of
references on the elements .

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>[?]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">expr</SPAN> <TT>[?]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>collection <TT>array</TT> or
<TT>list</TT>,</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>a set of <TT>struct</TT> or a set of references</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>gets all the elements in the collection pointed by the first operand
If used at a left value, gets references to that elements.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[?]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns a set of <TT>struct</TT> including the children and the position
of all the children in the <TT>p0.children</TT> collection.
For instance: <TT>set(struct(index : 0, value : 3874.33.293847:oid),
struct(index : 1, value : 2938.33.1928394:oid))</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Returns <TT>nil</TT> if the collection is empty</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>p0.children[?] := Person(name : "john")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Sets all the children to a new <TT>Person</TT> instance.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>returns the created <TT>Person</TT> oid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>(array&lt;Person *&gt;(list(Person(), Person())))[?]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns a <TT>set</TT> of <TT>struct</TT> including 
the just created <TT>Person</TT> instances in the just created array.</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524700000000000000">
<TT>append/to</TT> Operator</A>
</H3> <A NAME="7103"></A>
The <TT>append/to</TT> operator is used to append an element
to an ordered collection (<TT>list</TT> or <TT>array</TT>).

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>append</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>append</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>to</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: <SPAN  CLASS="textit">any type</SPAN>,
second operand: <TT>oid</TT> or <TT>object</TT> denoting an ordered collection</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">any type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>appends the element denoted by the first operand
to the indexed collection (i.e. list or array)
denoted by the second operand.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>append Person() to p0.children</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the created <TT>Person</TT> instance</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>append Car()to p0.cars</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN>: <TT>array or list expected, got set&lt;Person*&gt;</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524800000000000000">
<TT>suppress/from</TT> Operator</A>
</H3> <A NAME="7126"></A>
The <TT>suppress/from</TT> operator is used to suppress an element from
an ordered collection (<TT>set</TT> or <TT>bag</TT>).

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>suppress/from</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>suppress</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>from</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>binary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: <SPAN  CLASS="textit">any type</SPAN>, second operand:
<TT>oid</TT> or <TT>object</TT> collection</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>type of the first operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>suppress the first operand from the non-indexed collection (i.e. bag or set)
pointed by the second operand; returns the first operand.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>suppress (select Car.num = 1000) from p0.cars</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the suppressed car if it was found in the collection; otherwise, <SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>suppress new Car() from p.cars</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN>: <TT>item '71238.13.3959935:oid' not found in collection</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>suppress p0 from p0.children</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN>: <TT>cannot used non indexed suppression in an array</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002524900000000000000">
<TT>empty</TT> Operator</A>
</H3> <A NAME="7151"></A>
The <TT>empty</TT> operator is used to empty an ordered or an
unordered collection.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>empty</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>empty</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT> or <TT>object</TT> collection</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>empty the collection 
pointed by the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>empty(first (select Person).children)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>empty(first (select Person).cars)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>empty new set&lt;Car *&gt;(list(new Car()))</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>nil</TT>; this expression creates a collection of <TT>Car</TT>
containing initially a new <TT>Car</TT>, and empty it!</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION0025241000000000000000">
<TT>in</TT> Operator</A>
</H3> <A NAME="7173"></A>
The <TT>in</TT> operator is used to check if a given condition is
realized for at least one element in an ordered or unordered collection.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>in</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">identifier</SPAN> <TT>in</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>ternary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: <TT>identifier</TT>, second operand:
<TT>oid</TT> or <TT>object</TT> collection,
third operand: boolean</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns <TT>true</TT> if it exists in the collection pointed by
the second operand an element for which the third operand is 
evaluated to <TT>true</TT>.</TD>
</TR>
</TABLE>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>x in p0.children: x.name = "mary"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT> or <TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>x in p0.cars: x.num &lt; 100 and
x.num &gt;= 90</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT> or <TT>false</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION0025241100000000000000">
<TT>for</TT> Operator</A>
</H3> <A NAME="7196"></A>
The <TT>for/all</TT> operator is used to check
if a given condition is realized for all
elements in an ordered or unordered collection.
This operator is ODMG compliant.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>for/all</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>for</TT> <TT>all</TT> <SPAN  CLASS="textit">identifier</SPAN> <TT>in</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>ternary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: <TT>identifier</TT>, second operand:
<TT>oid</TT> or <TT>object</TT> collection,
third operand: boolean</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns <TT>true</TT> if for all items contained in the collection pointed by
the second operand the third operand is evaluated to <TT>true</TT>.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>for all x in p0.children: x.name == "john"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT> or <TT>false</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>for all x in p0.cars: x.num % 10</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT> or <TT>false</TT></TD>
</TR>
</TABLE>
The <TT>for</TT>/<SPAN  CLASS="textit">cardinality</SPAN> operator is used to check if
a given condition is realized for a given
number range of elements in an orderer or unordered collection.
Note that this operator is the generalisation of the <TT>in</TT>
and <TT>for/all</TT> operators:
<BR><TT>for &lt;0:$&gt;</TT> is equivalent to <TT>in</TT>
<BR><TT>for &lt;$&gt;</TT> is equivalent to <TT>for all</TT>
<BR>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>for</TT><SPAN  CLASS="textit">cardinality</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntaxes</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>for</TT> <TT>&lt;</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>&gt;</TT> <SPAN  CLASS="textit">identifier</SPAN> 
  <TT>in</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>for</TT> <TT>&lt;</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>&gt;</TT> <SPAN  CLASS="textit">identifier</SPAN> 
  <TT>in</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>:</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>5-ary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Types</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first and optional second operands: <TT>integer</TT> or <TT>$</TT>,
where <TT>$</TT> denotes the collection cardinality,
third operand: <TT>oid</TT> or <TT>object</TT>,
fourth operand: <TT>identifier</TT>,
fifth operand: <TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns <TT>true</TT> if the number of items in the collection pointed by
the third operand for which the third operand is evaluated to <TT>true</TT>
is in the interval <TT>[</TT>first operand<TT>,</TT> second operand<TT>]</TT>.</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>for &lt;0:4&gt; x in p0.children: x.name == "john"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT> if at most 4 children have their name equals to <TT>john</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>for &lt;4&gt; x in p0.children: x.name == "john"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>true</TT> if one an only one children have its name equals to <TT>john</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>for &lt;0:$&gt; x in p0.cars: x.num = 10</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>equivalent to <TT>in</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>for &lt;$&gt; x in p0.cars: x.num = 10</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>equivalent to <TT>for/all</TT></TD>
</TR>
</TABLE>
<H2><A NAME="SECTION002525000000000000000"></A> <A NAME="7238"></A>
<BR>
Exception Expressions
</H2>
Currently, E<SMALL>YE</SMALL>DB OQL does not provide full support for exception
management as there is no <TT>try/catch</TT> operator.
Nevertheless, the <TT>throw</TT> operator allows us to raise
an error message, for instance:
<PRE>
if (!check(p))
  throw "variable p is not correct".
</PRE>
The <TT>throw</TT> operator stops the current thread of statements
and returns the error message at the uppest level. In the following
code:
<PRE>
a := 1;
throw "this is an error";
b := 2;
</PRE>
the variable <TT>a</TT> will be assigned to <TT>1</TT>, but the
variable <TT>b</TT> will not be assigned to <TT>2</TT> as the
<TT>throw</TT> expression deroutes the normal thread of statements.
The <TT>throw</TT> operator is often used in the body of functions,

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>throw</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>throw</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>raises an error message</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>throw "error message"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>nil</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>throw "error #1: " + msg</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>nil</TT></TD>
</TR>
</TABLE>
<H2><A NAME="SECTION002526000000000000000"></A> <A NAME="7255"></A>
<A NAME="fundefexp"></A>
<BR>
Function Definition Expressions
</H2>
As introduced previously, OQL supports functions. There are two types of
functions definition syntax:
function definition expression and function definition statements.
The first ones, exposed in this section, are more restrictive than the
second ones, as their definition can contain only one expression.
The second ones contain an unbounded sequence of statements.

<BR>
The function definition expressions are ODMG compatible and are called
<SPAN  CLASS="textit">Named Query Definition</SPAN> in the ODMG standard.
To define such a function, one must use the operator <TT>define/as</TT>.
The general syntax for a definition function expression is:
<BR>
<BR><TT>define</TT> <SPAN  CLASS="textit">identifier</SPAN> [<TT>(</TT><SPAN  CLASS="textit">arglist</SPAN><TT>)</TT>] <TT>as</TT> <SPAN  CLASS="textit">expr</SPAN>.

<BR>
<BR>
For instance:
<PRE>
define div2(x) as x/2;
div2(10); // returns 5

define pimul(x) as x * 3.1415926535;
pimul(23); // returns 72.256631

define getOnePerson(name) as first(select Person.name = name);
getOnePerson("john"); // returns an oid or nil
</PRE>
As the last operand of the <TT>define/as</TT> operator is any OQL
expression, it can be a sequence of expressions by using the
comma sequencing operator. Therefore, the following construct is valid:
<PRE>
define getit(age) as ::getit_call++,
                     list_of_persons := select Person.age &gt;= age,
                     (count(list_of_persons) &gt; 0 ? list_of_persons[0] : nil);

getit(10); // returns the first Person whose age is greater or equal to
              10, or nil
getit_call; // equals 1
list_of_persons; // raises an error: uninitialized identifier 'list_of_persons

getit(20);
getit_call; // equals 2
</PRE>
Several comments about this code:

<OL>
<LI><TT>::getit_call</TT> denotes a global variable, while
<TT>list_of_persons</TT> denotes a variable local to the function:
the variable scoping has previously been introduced in the identifier
expressions, and will be explained again in the function definition statements
Section.
</LI>
<LI>as there are no iteration expression (for instance a <TT>for</TT> or
<TT>while</TT> expression) and as a function definition expression can
contain only one expression, one cannot use a function definition expression
with iteration statements.
To use an iteration statement, one needs to use a function definition
statement.
</LI>
<LI>when one needs to define a function with a sequence
of expressions, it may be easier and more readable to use a
function definition statement instead of a function definition expression.
The <SPAN  CLASS="textit">statement</SPAN> version of the previous function is:
<PRE>
function getit(age) {
  ::getit_call++;
  list_of_persons := select Person.age &gt;= age;
  if (count(list_of_persons))
    return list_of_persons[0];
}
</PRE>
which is - for <TT>C</TT>, <TT>C++</TT> or <TT>Java</TT> programmers -
a more natural construct.
</LI>
</OL>
Finally, the function definition allows us for recursive definitions,
for instance:
<PRE>
define fib(n) as (n &lt; 2 ? n : fib(n-2) + fib(n-1));
fib(10); // returns 55
</PRE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>define/as</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>define</TT> <SPAN  CLASS="textit">identifier</SPAN> [<SPAN  CLASS="textit">arglist</SPAN>] <TT>as</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>n-ary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>first operand: <TT>identifier</TT>,
last operand: <SPAN  CLASS="textit">any type</SPAN>, other operands: <TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>identifier</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>defines a function</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>define Persons as select Person</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Persons</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>define fact(n) as (n &lt; 2 ? n : n * fact(n-1))</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>fact</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002527000000000000000"></A> <A NAME="7275"></A>
<BR>
Conversion Expressions
</H2>
The conversion unary operators <TT>string</TT>,
<TT>int</TT>, <TT>char</TT>, <TT>float</TT>, <TT>oid</TT> and
<TT>ident</TT> allows us to make the following conversions:

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><SPAN  CLASS="textit">Operator</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><SPAN  CLASS="textit">From</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><SPAN  CLASS="textit">To</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">Returned Atom</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><SPAN  CLASS="textit">any type</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the string representation
of the operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the <TT>int</TT> operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand casted to an <TT>int</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand casted to an <TT>int</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand converted to an <TT>int</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the <TT>char</TT> operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand casted to a <TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>textttchar</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand casted to a <TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand converted to a <TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the <TT>float</TT> operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>char</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand casted to a <TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand casted to a <TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>float</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the operand converted to a <TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the <TT>oid</TT> operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the <TT>string</TT> operand converted to an <TT>oid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>ident</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>ident</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>ident</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the <TT>ident</TT> operand</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>string</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><TT>ident</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>the <TT>string</TT> operand converted to an <TT>ident</TT></TD>
</TR>
</TABLE>
These operators are used to perform an explicit conversion such
as convert the string <TT>"123"</TT> to the integer <TT>123</TT>,
or to perform an explicit cast for numbers such as
casting the integer <TT>10</TT> to the float <TT>10.0</TT>.
These operators evaluate first their operand before
performing the conversion.
If the operand type is valid, no error is raised even if its format
is not valid, for instance: <TT>int "alpha"</TT> returns <TT>0</TT>,
while <TT>oid "aoaoai"</TT> returns <TT>NULL</TT>.
Note that because of the precedence of these operators, parenthesis
are necessary to make a conversion of a non-primary operand. For
instance, <TT>string 1+2</TT> is not valid: you should use
<TT>string (1+2)</TT>.

<H3><A NAME="SECTION002527100000000000000">
<TT>string</TT> operator</A>
</H3> <A NAME="7282"></A>
The <TT>string</TT> operator evaluates its operand and returns its string representation.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>any type</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the string representation of any atom</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string 123.3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"1203.300000"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string 'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"a"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string first(select Person)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"71211.13.1486847:oid"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string &amp;alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"::alpha"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string list(1, 2, 3+2)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"list(1, 2, 5)"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string (list("hello", 30) + list(10))</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"list("hello", 30, 10)"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string (1+3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"4"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>string 1+3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002527200000000000000">
<TT>int</TT> operator</A>
</H3> <A NAME="7304"></A>
The <TT>int</TT> operator evaluates its operand and converts or
casts it to an integer.
<BR>
If the operand is the string, it converts it using the <TT>atoi</TT> C
function. If the string is not a valid integer, it returns a <TT>0</TT>.
<BR>
If the operand is a char or float, it casts it to an integer.
<BR>
If the operand is an integer, it returns it.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>int</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>int</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>int</TT>, <TT>char</TT>, <TT>float</TT> or
<TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>int</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the integer conversion or cast of the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>int 123.3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>int 12</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>12</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>int 'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>97</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>int "123"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>int ("123" + "12")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>12312</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>int alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the value of <TT>alpha</TT> converted
or casted to an integer</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>int list(1, 2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002527300000000000000">
<TT>char</TT> operator</A>
</H3> <A NAME="7326"></A>
The <TT>char</TT> operator evaluates its operand and converts or
casts it to a <TT>char</TT>.
<BR>
If the operand is the string of length one, it returns the character of
this string. If the string has several characters, it returns a
<TT>'&#92;000</TT>.
<BR>
If the operand is a integer or float, it casts it to a character.
<BR>
If the operand is a character integer, it returns it.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>char</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>int</TT>, <TT>char</TT>, <TT>float</TT> or
<TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>char</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the character conversion or cast of the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>char 123.3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>{</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>char 'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>'a'</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>char alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the value of <TT>alpha</TT> converted
or casted to a character</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>char "a"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>'a'</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>char "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>'^@'</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>char list(1, 2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002527400000000000000">
<TT>float</TT> operator</A>
</H3> <A NAME="7348"></A>
The <TT>float</TT> operator evaluates its operand and converts or
casts it to a float.
<BR>
If the operand is the string, it converts it using the <TT>atof</TT> C
function. If the string is not a valid float, it returns a <TT>0.0</TT>.
<BR>
If the operand is a integer or float, it casts it to a float.
<BR>
If the operand is a float, it returns it.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>float</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>int</TT>, <TT>char</TT>, <TT>float</TT> or
<TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>float</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the float conversion or cast of the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float 123.0</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123.0</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float 123.3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123.3</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float 'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>97.000</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float "123.0000000"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123.0</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float ("123." + "12")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123.12</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float "hello"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>0.0</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>the value of <TT>alpha</TT> converted
or casted to a float</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>float list(1, 2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002527500000000000000">
<TT>oid</TT> operator</A>
</H3> <A NAME="7370"></A>
The <TT>oid</TT> operator evaluates its string operand and returns
the corresponding oid. If the string does not denote a valid oid,
the <TT>NULL</TT> oid is returned.
<BR>
If the operand is an oid, it returns it.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT> or <TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the oid denoted by the string operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>oid "234.34.33:oid"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>234.34.33:oid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>oid 234.34.33:oid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>234.34.33:oid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>oid first(select Person)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>returns the first person oid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>oid 'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>
<H3><A NAME="SECTION002527600000000000000">
<TT>ident</TT> operator</A>
</H3> <A NAME="7392"></A>
The <TT>ident</TT> operator evaluates its string operand and returns
the corresponding identifier.
If the operand is an identifier, it returns it.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>ident</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>ident</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>ident</TT> or <TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the identifier denoted by the string operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ident "alpha"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>alpha</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ident "alpha#1x"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>alpha#1x</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ident "alpha" := 123</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123</TT>, <TT>alpha</TT> has been
assigned to <TT>123</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>valof &amp;(ident "alpha")</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>123</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ident 'a'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002528000000000000000"></A> <A NAME="7411"></A>
<BR>
Type Information Expressions
</H2>
OQL provides two type information unary operators: <TT>typeof</TT> and
<TT>classof</TT>. The first one takes any operand type, while the
second one takes an oid or an object operand.
Note that because of the precedence of these operators, parenthesis
are necessary to get type information about a non-primary operand. For
instance, <TT>typeof 1+2</TT> is not valid: you should use
<TT>typeof (1+2)</TT>.

<P>

<H3><A NAME="SECTION002528100000000000000">
<TT>typeof</TT> operator</A>
</H3> <A NAME="7416"></A>
The <TT>typeof</TT> operator is used to get the type of any OQL atom.
It evaluates its operand and returns the string type of its operand.
For instance: <TT>typeof 1</TT> returns <TT>"int"</TT> while
<TT>typeof "hello"</TT> returns <TT>"string"</TT>.
<BR>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>typeof</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>typeof</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>any type</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the type of the atom</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>typeof "alpha"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"string"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>typeof (1+20.)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"float"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>typeof list(1, 2, 3)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"list"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>typeof first(select Person)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"oid"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>typeof 1+3049</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>typeof alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>type of the value of <TT>alpha</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>typeof &amp;alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ident</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002528200000000000000">
<TT>classof</TT> operator</A>
</H3> <A NAME="7438"></A>

<P>

<H3><A NAME="SECTION002528300000000000000">
<TT>typeof</TT> operator</A>
</H3> <A NAME="7445"></A>
The <TT>classof</TT> operator is used to get the class of any oid
or object.
It evaluates its operand and returns the string class of its operand.
For instance: <TT>classof first(select Person)</TT> returns <TT>"Person"</TT> while
<TT>typeof new Car()</TT> returns <TT>"Car"</TT>.
<BR>
<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>classof</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>classof</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>oid</TT> or <TT>object</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the class of the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>classof first(select class)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"basic_class"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>classof (c := new Car(num : 10))</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"Car"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>classof NULL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>""</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>classof first(select Person).spouse</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>"Person"</TT> or <TT>NULL</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>classof 1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002529000000000000000"></A> <A NAME="7464"></A>
<BR>
Query Expressions
</H2>
The <TT>select</TT> operator is used to perform queries in a database.
The general syntax of this operator is as follows:
<BR>
<BR><TT>select</TT> [<TT>distinct</TT>] <SPAN  CLASS="textit">projection</SPAN> [<TT>from</TT> <SPAN  CLASS="textit">fromList</SPAN> 
[<TT>where</TT> <SPAN  CLASS="textit">predicat</SPAN>] [<TT>order by</TT> <SPAN  CLASS="textit">orderExprList</SPAN>
[<TT>asc|desc</TT>]]

<OL>
<LI><TT>distinct</TT> means that duplicates must be eliminated,
</LI>
<LI><SPAN  CLASS="textit">projection</SPAN> is an expression using the variables
defined in the <SPAN  CLASS="textit">fromList</SPAN>,
</LI>
<LI><SPAN  CLASS="textit">fromList</SPAN> is a sequence of comma-separated items
under one of the following forms:
<BR>  <SPAN  CLASS="textit">var</SPAN> <TT>in</TT> <SPAN  CLASS="textit">expr</SPAN>
<BR>  <SPAN  CLASS="textit">expr</SPAN> <TT>as</TT> <SPAN  CLASS="textit">var</SPAN>
<BR>  <SPAN  CLASS="textit">expr</SPAN> <SPAN  CLASS="textit">var</SPAN>
<BR>
where <SPAN  CLASS="textit">expr</SPAN> is an expression of type <TT>collection</TT> or
is a class name, and <SPAN  CLASS="textit">var</SPAN> is the name of a variable.
</LI>
<LI><SPAN  CLASS="textit">predicat</SPAN> is a boolean expression using the variables
defined in the <SPAN  CLASS="textit">fromList</SPAN>,
</LI>
<LI><SPAN  CLASS="textit">orderExprList</SPAN> is a comma-separated list of sortable
expressions (i.e. atomic type).
</LI>
<LI><TT>asc</TT> means that the order should be performed in an ascendant
way (the default) and <TT>desc</TT> means the inverse.
</LI>
</OL>

<P>

<H3><A NAME="SECTION002529100000000000000">
ODMG vs. E<SMALL>YE</SMALL>DB OQL Query Expressions</A>
</H3> <A NAME="7468"></A>
As explained in the Section <SPAN  CLASS="textit">OQL vs. ODMG 3 OQL</SPAN>,
there are a few differences between ODMG OQL and E<SMALL>YE</SMALL>DB OQL query expressions:

<UL>
<LI>the <TT>having/group</TT> clause is not
supported in the current implementation.
</LI>
<LI>in the current implementation,
one cannot use implicit <TT>from</TT> clause (i.e. <TT>from</TT>
clause without variables). ODMG OQL supports constructs such as:
<TT>from Person</TT> without any variable. This implementation does not.
</LI>
<LI>contrary to ODMG OQL, the <TT>from</TT> clause is optionnal,
A <TT>select</TT> expression which does not use the <TT>from</TT> is
called an implicit <TT>select</TT> expression.
</LI>
<LI>in a <TT>from</TT> clause such as ``<TT>x in expr</TT>'', ``<TT>expr</TT>'' can
be the name of a class. In this case, the interpreter understand
this as the extent of this class. ODMG OQL does not support that.
</LI>
<LI>the SQL specific agregate operators <TT>min(*)</TT>,
<TT>max(*)</TT>, <TT>count(*)</TT>, <TT>sum(*)</TT> and <TT>avg(*)</TT>
are not supported
</LI>
<LI>the <TT>order by</TT> clause is more restrictive than
in the ODMG OQL specifications (see below).
</LI>
<LI>the <TT>select *</TT> is not supported in the current implementation.
</LI>
</UL>

<P>

<H3><A NAME="SECTION002529200000000000000">
The general <TT>select</TT> syntax</A>
</H3> <A NAME="7478"></A>
Rather than introducing the <TT>select</TT> operator in a formal way by
using a lot mathematical symbols, we introduce it first, in an unformal way,
and then, through query examples.
<BR>
<BR>
The unformal description of the query process is as follows:

<OL>
<LI>The <TT>from</TT> clause
determine the sets of objects on which the query will be applied.
For instance, in the <TT>from</TT> clause,
``<TT>x in Person, y in x.children</TT>'', the sets on which
the query will be applied are
all the <TT>Person</TT> instances bound to the variable <TT>x</TT>
and the children of these instances, bound to the variable
<TT>y</TT>.
</LI>
<LI>These sets of objects are filtered by retaining only the objects
that satisfy the predicat in the <TT>where</TT> clause. These result objects
are gathered into a <TT>bag</TT>. If no <TT>where</TT> clause is there, all objects are
retained.
</LI>
<LI>If an <TT>order by</TT> clause is present, a sort is performed
using to the following process:

<OL>
<LI>each order expression must be of a sortable type: number (<TT>int</TT>,
<TT>char</TT> or <TT>float</TT>) or <TT>string</TT>. If not, an
error is raised.
</LI>
<LI>the <TT>bag</TT> is ordered into a <TT>list</TT> according to
the first order expression. Then identical atoms are ordered again using
the second order expression and so on.
</LI>
<LI>there is a restriction in the current implementation:
each expression in the <SPAN  CLASS="textit">orderExprList</SPAN> must be present
in the <SPAN  CLASS="textit">projection</SPAN> expression. If not present, an
error is raised.
</LI>
</OL>
</LI>
<LI>The <SPAN  CLASS="textit">projection</SPAN> expression is evaluated for each
object in the <TT>collection</TT> and the results of these evaluations are gathered
into a <TT>bag</TT>.
</LI>
<LI>If the keyword <TT>distinct</TT> is there, the eventual duplicates are
eliminated.
</LI>
<LI>Finally, if the <TT>order by</TT> clause is present, the
result <TT>bag</TT> is converted to a <TT>list</TT>;
if the <TT>distinct</TT> keyword is there without an <TT>order by</TT>,
the <TT>bag</TT> is converted to a <TT>set</TT>; and if neither
<TT>order by</TT> nor <TT>distinct</TT> are used, we get a <TT>bag</TT>.
</LI>
</OL>
The following table presents several examples:

<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">Simple <TT>select/from</TT> Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>select x from Person x</TT>
<BR>
returns a <TT>bag</TT> containing
all the <TT>Person</TT> <TT>oid</TT>s in the database
<BR>
<TT>select x.name from Person x</TT>
<BR>
returns a <TT>bag</TT>
containing the name of every <TT>Person</TT> instance in the database
<BR>
<TT>select struct(name: x.name, age: x.age) from Person x</TT>
<BR>
returns a <TT>bag</TT>
containing <TT>struct</TT> elements including the name and age of every <TT>Person</TT> instance in the database
<BR>
<TT>select list(x, x.name) from Person x where x.name ~ "h"</TT>
<BR>
returns a <TT>bag</TT> of <TT>list</TT> elements
containing the <TT>oid</TT> and the name of every <TT>Person</TT> instances 
whose name matches the regular expression <TT>"h"</TT>
<BR>
<TT>select list(x, x.name) from Person x where x.name ~ "h" order by x.name</TT>
<BR>
same as previous example, but the result is a <TT>list</TT> ordered
by the name of the persons
<BR>
<TT>select x from Person x where x.spouse.name = "john" or x.age &lt; 10</TT>
<BR>
returns
a bag of <TT>Person</TT> instances whose spouse name is equal to <TT>"john"</TT> or
the age is less than <TT>10</TT>
<BR>
<TT>select x from Person x order by x.name</TT>
<BR>
current implementation restriction: <SPAN  CLASS="textit">raises an error</SPAN>: <TT>x.name not found in projection</TT>
<BR></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002529300000000000000"></A> <A NAME="7489"></A>
<BR>
Arrays and collections in query expressions
</H3>
OQL provide supports for performing direct queries through non-collection array and
collection attributes without explicit joins.
To perform such queries, one must use the operators <TT>[]</TT>,
<TT>[?]</TT> or <TT>[:]</TT>.
All the operators may be used for non-collection arrays. For
collections (<TT>list</TT>, <TT>set</TT>, <TT>bag</TT> and <TT>array</TT>),
only the operator <TT>[?]</TT> is valid.
<BR>
The operator <TT>[]</TT> denotes an element in a non-collection array.
<BR>
The operator <TT>[:]</TT> denotes a range of elements in a non-collection array.
<BR>
The operator <TT>[?]</TT> denotes all elements in a non-collection array
or in a collection.
The following table presents several examples:
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">Array and Collection based Query Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>select x.name from Person x where x.name[0] = 'j'</TT>
<BR>
returns all
the <TT>Person</TT> instances whose name begins with a <TT>'j'</TT>
<BR>
<TT>select x from Person x where x.other_addrs[0].street ~~ "par." </TT>
<BR>
returns all the <TT>Person</TT> instances whose first <TT>other_addrs</TT>
street matches the regular expression <TT>"par."</TT>
<BR>
<TT>select x from Person x where x.other_addrs[?].street ~~ "par.." </TT>
<BR>
returns all the <TT>Person</TT> instances whose any <TT>other_addrs</TT>
street matches the regular expression <TT>"par.."</TT>
<BR>
<TT>select x from Person x where x.other_addrs[1:3].street ~~ "par.." </TT>
<BR>
returns all the <TT>Person</TT> instances whose the first, second
or third <TT>other_addrs</TT>
street matches the regular expression <TT>"par.."</TT>
<BR>
<TT>select x from Person x where x.children[?].name = "johnny"</TT>
<BR>
returns
all the persons whose one of its children is called <TT>"johnny"</TT>
<BR>
<TT>select x from Person x where x.cars[?].num &lt; 100 or x.children[?].name = "mary"</TT>
<BR>
returns all the persons whose one of its cars has a number less
than  <TT>100</TT> or a child called <TT>"mary"</TT>
<BR>
<TT>select x from Person x where x.children[1].name = "johnny"</TT>
<BR>
although the <TT>children</TT> is a collection array, an error is raised.
This is a current limitation of the implementation that will disapear
soon
<BR></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002529400000000000000">
The Implicit <TT>select</TT> syntax</A>
</H3> <A NAME="7494"></A>
An implicit <TT>select</TT> expression is a <TT>select</TT> expression
with neither a <TT>from</TT> nor an explicit <TT>where</TT> clause.
In fact, the <TT>where</TT> clause may be included in the <SPAN  CLASS="textit">projection</SPAN>
expression.
<BR>
This particular syntax has the advantage
to be more compact and more simple than the general syntax, but
some queries cannot be performed:

<OL>
<LI>queries performing an explicit join,
</LI>
<LI>queries having <TT>or</TT> or <TT>and</TT> in their <TT>where</TT>
clause.
</LI>
</OL>
The following table presents several examples:
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">Simple Implicit <TT>select</TT> Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>select 1</TT>
<BR>
returns <TT>1</TT>
<BR>
<TT>select Person</TT>
<BR>
returns a <TT>bag</TT> containing all <TT>Person</TT>
instances in the database
<BR>
<TT>select Person.name</TT>
<BR>
returns a <TT>bag</TT>
containing the name of every <TT>Person</TT> instances in the database
<BR>
<TT>select Person.name = "john"</TT>
<BR>
returns a <TT>bag</TT>
containing the <TT>oid</TT>s of every <TT>Person</TT> instances 
whose name is equal to <TT>"john"</TT>
<BR>
<TT>(select distinct Person.name = "john").age</TT>
<BR>
returns a <TT>set</TT>
containing the age of every <TT>Person</TT> instances 
whose name is equal to <TT>"john"</TT>
<BR>
<TT>select Person.name = "john" or Person.age = 10</TT>
<BR><SPAN  CLASS="textit">raises an error</SPAN>: <TT>use select/from/where clause</TT>
<BR>
<TT>select Person.name order by Person.name</TT>
<BR>
returns a <TT>list</TT> containing of the sorted names of all <TT>Person</TT>
instances
<BR></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002529500000000000000"></A> <A NAME="7501"></A>
<BR>
Querying the schema
</H3>
As every abstraction is an object, one can perform queries on the schema
and classes. For instance, to get the <TT>oid</TT>s of all the
existing classes in a schema:
<BR><TT>select schema</TT> which is equivalent to <TT>select class</TT>.
<BR>
In the E<SMALL>YE</SMALL>DB object model, the class <TT>class</TT> has the following
native attributes (some are inherited from the <TT>object</TT> class):

<OL>
<LI><TT>class</TT> (inherited from <TT>object</TT>) is the class
of this class,
</LI>
<LI><TT>protection</TT> (inherited from <TT>object</TT>) is the 
protection object of this class,
</LI>
<LI><TT>type</TT> is the type of the class: <TT>"system"</TT> or
<TT>"user"</TT>.
</LI>
<LI><TT>name</TT> is the name of this class,
</LI>
<LI><TT>parent</TT> is the parent class of this class,
</LI>
<LI><TT>extent</TT> is the extent collection of this class: contains
all the object instances of this class,
</LI>
<LI><TT>components</TT> is the collection of components of this class:
contains the constraints, the methods, the triggers, the index.
</LI>
</OL>
Queries can be performed according to one or more of the previous
attributes.
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">Query Schema Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>select class.name = "Person"</TT>
<BR>
returns a <TT>bag</TT> containing the class whose name is <TT>"Person"</TT>
<BR>
<TT>select class.type = "user"</TT>
<BR>
returns all the user classes
<BR>
<TT>select x from class x where x.name ~ "P" and
x.type = "user"</TT>
<BR>
returns the user classes whose name
matches the given regular expression
<BR>
<TT>select class.parent.name = "Person"</TT>
<BR>
returns a <TT>bag</TT> containing the sub-classes of the class <TT>Person</TT>
<BR></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002529600000000000000"></A> <A NAME="7506"></A>
<BR>
How queries are optimized?
</H3>
E<SMALL>YE</SMALL>DB queries implementation make an heavy use of index.
Index may be used as terminal index or as non-terminal index:
terminal index are those used at the end of a path expression, and
the other are those used inside a path expression.
<BR>
<BR>
For instance, assuming that each attribute in our schema is indexed,
the query <TT>select Person.name = "john"</TT> uses
the index on the attribute <TT>name</TT> as
a terminal index.
<BR>
<BR>
The query <TT>select Person.spouse.age &lt; 23</TT> uses
the index on the attribute <TT>age</TT> as a terminal
index, and the index on the indirect attribute <TT>spouse</TT>
as a non-terminal index, while the query <TT>select Person.spouse
= 6252.3.48474:oid</TT> uses the index on the <TT>spouse</TT> attribute as a
terminal index.
<BR>
<BR>
The query <TT>select Person.children[?].spouse.name = "mary"</TT>
uses the index of the attributes <TT>name</TT>, <TT>spouse</TT>
and of the literal collection attribute <TT>children</TT>.

<BR>
<BR>
The queries with a <TT>where</TT> clause containing logical <TT>and</TT>
constructs are optimized so to take advantage of the index. For instance,
assuming that there is an index on the <TT>name</TT> attribute and no
index on the <TT>age</TT> attribute, the query
<TT>select x from Person x where x.age = 100 and x.name = "john"</TT>
will perform first the query on the <TT>name</TT> attribute and then
filter the result according to the given predicat on the <TT>age</TT>
attribute.
<BR>
If the two expressions around the logical <TT>and</TT> operator
have an index or if none of the two expression has a index,
the interpreter performs first the left part and then the second part.
So, in this case, the order of the two expressions around the <TT>and</TT>
is important.

<BR>
<BR>
Finally, the query <TT>select Person.name</TT> reads directly the index
of the <TT>name</TT> attribute, instead of reading the name of each
<TT>Person</TT> instance.

<BR>
<BR>
Nevertheless, currently, there are some constructs that the OQL interpreter
does not interpret cleverly and where index are not used.
This is unfortanely the case of the join constructs such as:
<BR><TT>select x from Person x, x.spouse y where y.name = "mary"</TT>.
<BR>
This construct will not make use of the index on the <TT>spouse</TT> attribute
(but it will use the index of the <TT>name</TT> attribute).
Fortunately, in a lot of cases, join queries may be replaced by a path expression query, for
instance:
<BR><TT>select x from Person x where x.spouse.name = "mary"</TT> is the
alternate form the previous join query.
<BR>
<BR>
This alternate form (path-expression oriented) is the preferred one, because:
<BR>  - it is more intuitive,
<BR>  - it is more <SPAN  CLASS="textit">object oriented</SPAN> (please forget relationnal!),
<BR>  - it is more compact,
<BR>  - it uses index properly.
<BR>
<BR>
Of course, the last reason is not a good reason as a proper query
implementation should use index whatever the used syntax.
The implementation will be improved in a next version.

<BR>
<BR>
Note that query optimisations are fragile and do not believe that
the OQL interpreter knows your data better than you. So, the two following
simple rules should be applied:

<OL>
<LI>when path expression oriented queries are enough, do not use
join constructs,
</LI>
<LI>in a <TT>and</TT> expression within a <TT>where</TT> clause, put
the expression which denotes the most little set of instances on
the left side of the <TT>and</TT>. In some particular cases, the
OQL interpreter knows how to optimize the <TT>and</TT>, but in
most of the cases, it does not.
</LI>
</OL>
Some experimental hints can be added to an <TT>and</TT> expression
in the <TT>where</TT> clause to help the interpreter to do the
things better, but there are currentlty too much experimental to
be documented here.

<P>

<H2><A NAME="SECTION002530000000000000000"></A> <A NAME="7511"></A>
<BR>
Miscellenaous Expressions
</H2>
A few OQL operators cannot be easily classified in one of the previous
categories. We choose to classify them in the miscellenaous operators.
These operators are: <TT>bodyof</TT>, <TT>structof</TT>, <TT>[!]</TT> and
<TT>import</TT>.

<P>

<H3><A NAME="SECTION002530100000000000000">
<TT>bodyof</TT> operator</A>
</H3> <A NAME="7516"></A>
The <TT>bodyof</TT> operaror is used to get the body of an OQL function.
For instance, let the function <TT>fib</TT>:
<TT>define fib(n) as (n &lt; 2 ? n : fib(n-2) + fib(n-1))</TT>.
The expression <TT>bodyof fib</TT> will return:
<TT>"fib(n) ((n&lt;2)?n:(fib((n-2))+fib((n-1))))"</TT>.
This operator could be applied to expression-functions (i.e. functions
defined with the <TT>define/as</TT> operator) or statement-functions (i.e.
functions defined with the <TT>function</TT> operator).

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>bodyof</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>classof</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>ident</TT> denoting a function</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the body of the function</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bodyof is_int</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>"is_int(x) ((typeof x)=="integer")"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bodyof first</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><TT>"first(l) { if (((!is_list(l))&amp;&amp;(!is_array(l)))) return l; start:=0; f:=nil; for (x in l) if ((start==0)) { start:=1; f:=x; break; }; ; return f; }"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>bodyof 1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=255><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002530200000000000000">
<TT>structof</TT> operator</A>
</H3> <A NAME="7538"></A>
The <TT>structof</TT> is used to get the meta-type of a <TT>struct</TT> atom.
The meta-type of a <TT>struct</TT> atom is the list of the attributes
of this <TT>struct</TT>. For instance, the meta-type of 
<TT>struct(a : 1, b : "hello")</TT> is the list composed of the two
attribute <TT>a</TT> and <TT>b</TT>. The following expression
<TT>structof struct(a : 1, b : "hello")</TT> returns
<TT>list("a", "b")</TT>.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>structof</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>structof</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>struct</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>a <TT>list</TT> of <TT>string</TT>s</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns the meta-type of the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>structof struct(alpha : 1, beta : 2)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>list("alpha", "beta")</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>structof first(select struct(x: x.firstname) from Person x)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>list("x")</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>structof 1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002530300000000000000">
<TT>[!]</TT> operator</A>
</H3> <A NAME="7560"></A>
The <TT>[!]</TT> is used to get the length (or size) of an ordered
or unordered collection, a string or a struct.
For instance, <TT>"hello"[!]</TT> returns <TT>5</TT>,
while <TT>list(1, 2, 3)[!]</TT> returns <TT>3</TT>.
Note that this operator is far more efficient than the <TT>strlen</TT>
library function.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>[!]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">expr</SPAN> <TT>[!]</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT>, <TT>collection</TT> or
<TT>struct</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>a <TT>int</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>returns length of the operand</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>(select Person)[!]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>the number of person instances</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>(struct(a: 1, b:2, c: "hello"))[!]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>3</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>("hello"+"world")[!]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><TT>10</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>"hello"+"world"[!]</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><SPAN  CLASS="textit">raises an error</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002530400000000000000">
<TT>import</TT> operator</A>
</H3> <A NAME="7582"></A>
The <TT>import</TT> operator is used to import an OQL file in the
current OQL session. Its operand is a string which denote the absolute
path (i.e. beginning with a <TT>/</TT>) or relative path
(i.e. not beginning with a <TT>/</TT>) 
 of the file to import. When the path is relative, the OQL interpreter
will look in every directories pointed by the E<SMALL>YE</SMALL>DB configuration variable
<TT>oqlpath</TT>. By default, <TT>oqlpath</TT> is equal to
<TT>%root%/etc/oql</TT>. If the file name has no <TT>.oql</TT> extension,
the OQL interpreter will automatically adds one.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">General Information</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operator</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>import</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Syntax</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>import</TT> <SPAN  CLASS="textit">expr</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>unary</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Operand Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Result Type</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>a <TT>string</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>Function</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>import the file</TD>
</TR>
</TABLE>

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><SPAN  CLASS="textit">Expression Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>import "stdlib"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><TT>"/usr/local/eyedb/etc/so/stdlib.oql"</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><TT>import "roudoudou"</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><SPAN  CLASS="textit">raises an error</SPAN>: <TT>cannot find file 'roudoudou'</TT></TD>
</TR>
</TABLE>

<P>

<P>

<H2><A NAME="SECTION002531000000000000000"></A> <A NAME="7602"></A>
<BR>
Selection Statements
</H2>
The selection statement is based on the <TT>if/else</TT> constructs.
<BR>
<BR><B>Syntax</B>: <TT>if</TT> <TT>(</TT> <SPAN  CLASS="textit">cond_expr</SPAN> <TT>)</TT> <SPAN  CLASS="textit">statement1</SPAN> [<TT>else</TT> <SPAN  CLASS="textit">statement2</SPAN>]
<BR>
where <SPAN  CLASS="textit">cond_expr</SPAN> is a boolean expression, and <SPAN  CLASS="textit">statement1</SPAN>
and <SPAN  CLASS="textit">statement2</SPAN> may be any statement: an expression
statement, an iteration statement, a compound statement, a selection statement,
a function definition statement, a jump statement or an empty statement.
<BR>
<BR><B>Semantics</B>: if the boolean expression <SPAN  CLASS="textit">cond_expr</SPAN> is
evaluated to <TT>true</TT>, the statement <SPAN  CLASS="textit">statement1</SPAN> is executed.
Otherwise, if an <TT>else</TT> part is there, the statement <SPAN  CLASS="textit">statement2</SPAN>
is executed. The statements 1 and 2 may be any statement: an expression
statement, iteration statement, compound statement, selection statement,
function definition statement, jump statement or empty statement.
<BR>
Note that a selection statement does not return any atom
<BR>
<BR>
The following table presents several examples of <TT>if/else</TT> statements:
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit"><TT>if/else</TT> Statement Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>if (true) a := 1;</TT>
<BR>
the variable <TT>a</TT> is assigned to <TT>1</TT>
<BR>
<TT>if (1) b := 2;</TT>
<BR>
an error is raised: <TT>boolean expected for condition</TT>
<BR>
<TT>if (check(10) &gt; 54) {a := 1; b := 2;} else {c := 2; d := 2}</TT>
<BR>
here compound statements are used, because several expression statements
need to be executed
<BR>
<TT>if ((check(10) &gt; 54 || alpha &lt; 2) &amp;&amp; beta &gt; 2.3 ) {callme(2);}</TT>
<BR>
use of a composite conditional expression
<BR>
<TT>if (a == 1) b := 2; else if (b == 3) {c := 2; return 4;} else if (check(1)) return 2; else return 3;</TT>
<BR>
selection statements are combined
<BR></TD>
</TR>
</TABLE>  

<P>

<H2><A NAME="SECTION002532000000000000000"></A> <A NAME="7604"></A>
<BR>
Iteration Statements
</H2>
The iteration statements are based on the following constructs:

<UL>
<LI><TT>while</TT>
</LI>
<LI><TT>do/while</TT>
</LI>
<LI><TT>for</TT> C, C++, Java form
</LI>
<LI><TT>for</TT> collection form
</LI>
</UL>
<H3><A NAME="SECTION002532100000000000000">
<TT>while</TT> statement</A>
</H3> <A NAME="7611"></A>
<B>Syntax</B>: <TT>while</TT> <TT>(</TT> <SPAN  CLASS="textit">cond_expr</SPAN> <TT>)</TT> <SPAN  CLASS="textit">statement</SPAN>
<BR>
where <SPAN  CLASS="textit">cond_expr</SPAN> is a boolean expression, and <SPAN  CLASS="textit">statement</SPAN>
any statement: an expression
statement, an iteration statement, a compound statement, a selection statement,
a function definition statement, a jump statement or an empty statement.
<BR>
<BR><B>Semantics</B>: The statement is executed while the boolean expression
<TT>cond_expr</TT> is evaluated to <TT>true</TT>.
Note that a <TT>while</TT> statement does not return any atom
<BR>
<BR>
The following table presents several examples of <TT>while</TT> statements:
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit"><TT>while</TT> Statement Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>while (true) a++;</TT>
<BR><TT>a</TT> is increment definitively!
<BR>
<TT>while (n-) a++;</TT>
<BR>
an error is raised: <TT>boolean expected, got integer</TT>
<BR>
<TT>while (n- &gt; 0) a++;</TT>
<BR>
this is better
<BR>
<TT>while (n++ &lt;= 100 || stop) {if (!perform(a++)) break; check(a);}</TT>
<BR>
note the usage of a compound statement and of the <TT>break</TT>
<BR>
<TT>while (name != "john") {l := (select Person.name = name); name := get_name();}</TT>
<BR><SPAN  CLASS="textit">no comments</SPAN>
<BR></TD>
</TR>
</TABLE>  

<P>

<H3><A NAME="SECTION002532200000000000000">
<TT>do/while</TT> statement</A>
</H3> <A NAME="7618"></A>
<B>Syntax</B>: <TT>do</TT> <SPAN  CLASS="textit">statement</SPAN> <TT>while</TT> <TT>(</TT> <SPAN  CLASS="textit">cond_expr</SPAN> <TT>)</TT>
<BR>
where <SPAN  CLASS="textit">cond_expr</SPAN> is a boolean expression, and <SPAN  CLASS="textit">statement</SPAN>
any statement: an expression
statement, an iteration statement, a compound statement, a selection statement,
a function definition statement, a jump statement or an empty statement.
<BR>
<BR><B>Semantics</B>: The statement is executed at least once.
Then while the boolean expression
<TT>cond_expr</TT> is evaluated to <TT>true</TT>, the statement is executed.
Note that a <TT>do/while</TT> statement does not return any atom
<BR>
<BR>
The following table presents several examples of <TT>do/while</TT> statements:
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit"><TT>do/while</TT> Statement Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>do a++; while (true);</TT>
<BR><TT>a</TT> is increment definitively!
<BR>
<TT>do a=+; while (n-);</TT>
<BR>
an error is raised: <TT>boolean expected, got integer</TT>
<BR>
<TT>do a++; while (n- &gt; 0);</TT>
<BR>
this is better
<BR>
<TT>do {if (!perform(a++)) break; check(a);} while (n++ &lt;= 100 || stop);</TT>
<BR>
note the usage of a compound statement and of the <TT>break</TT>
<BR>
<TT>do {l := (select Person.name = name); name := get_name();} while (name != "john");</TT>
<BR><SPAN  CLASS="textit">no comments</SPAN>
<BR></TD>
</TR>
</TABLE>  

<P>

<H3><A NAME="SECTION002532300000000000000">
C-<TT>for</TT> statement</A>
</H3> <A NAME="7625"></A>
<B>Syntax</B>: <TT>for</TT> <TT>(</TT> [<SPAN  CLASS="textit">expr1</SPAN>] <TT>;</TT> [<SPAN  CLASS="textit">cond_expr</SPAN>] <TT>;</TT> [<SPAN  CLASS="textit">expr2</SPAN>] <TT>)</TT> <SPAN  CLASS="textit">statement</SPAN>
<BR>
where <SPAN  CLASS="textit">cond_expr</SPAN> is a boolean expression, <SPAN  CLASS="textit">expr1</SPAN> and
<SPAN  CLASS="textit">expr2</SPAN> are any expressionss and <SPAN  CLASS="textit">statement</SPAN>
any statement: an expression
statement, an iteration statement, a compound statement, a selection statement,
a function definition statement, a jump statement or an empty statement.
<BR>
<BR><B>Semantics</B>: The expression <SPAN  CLASS="textit">expr1</SPAN> is evaluated.
While the boolean expression
<TT>cond_expr</TT> is evaluated to <TT>true</TT>, the statement is
executed and the expression <SPAN  CLASS="textit">expr2</SPAN> is evaluated.
<BR>
Note that a C-<TT>for</TT> statement does not return any atom
<BR>
<BR>
The following table presents several examples of C-<TT>for</TT> statements:
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">C-<TT>for</TT> Statement Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>for (x := 0; x &lt; 100; x++) a++;</TT>
<BR>
increment <TT>a</TT> an hundred times
<BR>
<TT>for (x := 0, y := 1; x &lt; 100 &amp;&amp; check(y); x++) {y := get(y); if (y == 9999) break;}</TT>
<BR>
a more complex example
<BR>
<TT>for (x := 100; x; x-) perform(x);</TT>
<BR>
raises an error: <TT>boolean expected, got integer</TT>
<BR>
<TT>for (x := 0;;) doit();</TT>
<BR>
note that there is neither a conditionnal expression, nor a second expression
<BR>
<TT>for (;;) doit();</TT>
<BR>
same as <TT>while(true)</TT>
<BR></TD>
</TR>
</TABLE>  

<P>

<H3><A NAME="SECTION002532400000000000000">
collection-<TT>for</TT> statement</A>
</H3> <A NAME="7632"></A>
<B>Syntax</B>: <TT>for</TT> <TT>(</TT> <SPAN  CLASS="textit">var</SPAN> <TT>in</TT> <SPAN  CLASS="textit">expr</SPAN> <TT>)</TT> <SPAN  CLASS="textit">statement</SPAN>
<BR>
where <SPAN  CLASS="textit">cond_expr</SPAN> is a boolean expression, <SPAN  CLASS="textit">var</SPAN> denotes
the name of a variable, <SPAN  CLASS="textit">expr</SPAN> is an expression of type
collection and <SPAN  CLASS="textit">statement</SPAN>
any statement: an expression
statement, an iteration statement, a compound statement, a selection statement,
a function definition statement, a jump statement or an empty statement.
<BR>
<BR><B>Semantics</B>: 
For each element in the collection denoted by <SPAN  CLASS="textit">expr</SPAN>, the
variable <SPAN  CLASS="textit">var</SPAN> is assigned to this element and the statement
is executed. 
Note that a collection-<TT>for</TT> statement does not return any atom
<BR>
<BR>
The following table presents several examples of collection-<TT>for</TT> statements:
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>
<DIV ALIGN="CENTER">
<SPAN  CLASS="textit">collection-<TT>for</TT> Statement Examples</SPAN>
</DIV></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><TT>for (x in list(1, 2, 3)) a += x;</TT>
<BR>
increments <TT>a</TT> with <TT>1, 2</TT> and <TT>3</TT>
<BR>
<TT>for (x in (select Person)) names += x.name;</TT>
<BR>
concatenates all the person names
<BR>
<TT>for (x in (select Person.name = "john")) if (x.age &lt; 10 || x.spouse.age &lt; 10) throw "cannot mary children!!";</TT>
<BR>
a moralistic example
<BR>
<TT>for (x in 1) doit();</TT>
<BR>
raises an error: <TT>boolean expected, got integer</TT>
<BR></TD>
</TR>
</TABLE>  

<P>

<H2><A NAME="SECTION002533000000000000000"></A> <A NAME="7636"></A>
<BR>
Jump Statements
</H2>
There are two jump statements based on the keywords
<TT>break</TT> and <TT>return</TT>.

<P>

<H3><A NAME="SECTION002533100000000000000">
<TT>break</TT> Statement</A>
</H3> <A NAME="7641"></A>
The syntax for <TT>break</TT> statement is:
<BR><TT>break</TT> <SPAN  CLASS="textit">statement</SPAN>
<BR>
where <SPAN  CLASS="textit">statement</SPAN> is an optional integer expression statement
indicating the break level.
If not specified, the break level is <TT>1</TT>.
The <TT>break</TT> statement may appear only within an iteration statement:
<TT>while</TT>, <TT>do/while</TT>, <TT>for</TT> statements.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><TT>break</TT> <SPAN  CLASS="textit">Statement Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">Statement</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">Comments</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>break;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN>: <TT>break operator &#171;break; &#187; : level 1 is too deep.</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>break 3;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN>: <TT>break operator &#171;break; &#187; : level 3 is too deep.</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>for (x := 0; ; x++) if (x == 30) break;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>break the loop when <TT>x</TT> is equal to <TT>30</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>while (true) {x++; if (!check(x)) break;}</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>break the loop when <TT>check(x)</TT> is not true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>while (true) {x++; if (!check(x)) break 2;}</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN>: <TT>break operator &#171;break; &#187; : level 2 is too deep.</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>while (true) {x++; while (x &lt; 100) if (!check(&amp;x)) break 2;}</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>break the two loop when <TT>check(&amp;x)</TT> is not true</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION002533200000000000000">
<TT>return</TT> Statement</A>
</H3> <A NAME="7653"></A>
The syntax for <TT>return</TT> statement is:
<TT>return</TT> [<SPAN  CLASS="textit">statement</SPAN>]
<BR>
where <SPAN  CLASS="textit">statement</SPAN> is an optional expression statement
indicating the atom to return. The atom to return may be of any type.
If not specified, no atom is returned.
The <TT>return</TT> statement may appear only within a function definition statement.

<BR><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN><TT>return</TT> <SPAN  CLASS="textit">Statement Examples</SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">Statement</SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">Comments</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>return;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN>: <TT>return operator &#171;return; &#187; : return must be performed in a function</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>function fact(n) {return n * fact(n-1);}</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>ok.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>function f(x) {if (g(x)) return x+1; return x+2;}</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>ok.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>function f(b) {if (b) return list(1, 2, 3); return bag(1);}</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>ok.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>function f(b) {if (b) return list(1, 2, 3); return bag(1);}</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>ok.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>define as f(x) (if (x) return x)</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SPAN  CLASS="textit">raises an error</SPAN>: <TT>syntax error</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION002534000000000000000"></A> <A NAME="7661"></A>
<BR>
Function Definition Statements
</H2>
As introduced previously, OQL supports functions. There are two sorts of
functions definition syntax:
function definition expression and function definition statements.
The first ones, exposed in Section <A HREF="#fundefexp">5.26</A> can contain only one
expressions. That means that they cannot include neither selection,
neither statements, neither jump statements.
Furthermore, as only one expression is allowed, functions that need
several expressions, one must use the comma sequencing operaot to
seperate the expressions, thus making this code not always readable.

<BR>
We introduce here the more general form of function definitions which 
overrides the limitations of the previous form.
The general form of function defintion statements is:
<TT>function</TT> <SPAN  CLASS="textit">identifier</SPAN> <TT>(</TT>[<SPAN  CLASS="textit">arglist</SPAN>]<TT>)</TT>
<SPAN  CLASS="textit">compound_statement</SPAN>

<OL>
<LI><SPAN  CLASS="textit">identifier</SPAN> denotes any valid OQL identifier, except a keyword
</LI>
<LI><SPAN  CLASS="textit">arglist</SPAN> is an optional comma-separated list
of identifiers
optionally followed, for default arguments, by a ``<TT>?</TT>''
and an <SPAN  CLASS="textit">expr</SPAN>, for instance:
<BR><TT>(</TT><SPAN  CLASS="textit">var1</SPAN><TT>,</TT> <SPAN  CLASS="textit">var2</SPAN><TT>,</TT> <SPAN  CLASS="textit">var3</SPAN><TT>?</TT> 
<SPAN  CLASS="textit">expr</SPAN><TT>,</TT> <SPAN  CLASS="textit">var4</SPAN><TT>?</TT> <SPAN  CLASS="textit">expr</SPAN><TT>)</TT>
</LI>
<LI><SPAN  CLASS="textit">compound_statement</SPAN> is a optionnal semicolon-separated
list of statements surrounded by braces.
</LI>
</OL>
For instance:
<PRE>
function f(x, y, z ? oql$maxint) {
  if (x &gt; y)
    throw "error #1";
  return x - y * 2 / z;
}
</PRE>
<H3><A NAME="SECTION002534100000000000000"></A> <A NAME="7666"></A>
<BR>
Argument Types/Return Type
</H3>
Functions are not typed. That means that neither the
return type nor the argument types may be given.
It is why there is no function overloading mechanisms. To take
benefit of the overloading mechanisms, one must use  methods.
<BR>
Nevertheless, it is possible to add type checking by using
library functions such as <TT>is_int</TT>, <TT>is_string</TT>...
combined with the <TT>assert</TT> or the <TT>assert_msg</TT>
library functions.
For instance, to check that the first argument is an integer
and the second one a collection:
<PRE>
function doit(n, coll) {
   assert_msg(is_int(n), "doit: argument #1: integer expected");
   assert_msg(is_coll(coll), "doit: argument #2: collection expected");
   // body of the function
}
</PRE>
The <TT>assert_msg</TT> check that its first argument is equal to
<TT>true</TT>, otherwiser an exception containing the second argument
string is thrown:
<PRE>
doit(1, list(1, 2, 3)); // ok

doit(1.2, list(1)); // raises the error:
                    // assertion failed: 'doit: argument #1: integer expected'
</PRE>

<P>

<H3><A NAME="SECTION002534200000000000000">
Arguments <TT>in</TT>, <TT>out</TT> and <TT>inout</TT></A>
</H3> <A NAME="7673"></A>
Furthermore, one cannot specify that an argument is an input
argument (<TT>in</TT>), an output argument (<TT>out</TT>) or
an input/output argument (<TT>inout</TT>).
In a function call, expressions and variables are always passed
by value not by reference, this means that the call to
``<TT>perform(x, y)</TT>'' cannot modify neither <TT>x</TT> nor <TT>y</TT>.
(<SPAN  CLASS="textit">In fact, yes it can! It is explained below. But forget it for now</SPAN>).
<BR>
So, to modify variable through a function call, one needs to give the
reference (or address) of this variable, not its value.
In this case, the function must execute specific code dealing with
address variables instead of their values.
<BR>
The <TT>refof</TT> operator, introduced in a previous section, gives
the reference of an identifier.
Remember that the expression <TT>refof</TT> <TT>x</TT> returns
the identifier <TT>x</TT>.
To make a function call using references one must do:
<TT>swap(refof x, refof y)</TT> or
the equivalent more compact form <TT>swap(&amp;x, &amp;y)</TT>.
<BR>
Contrary to C++, reference manipulation is not transparent in OQL:
to access the value of a reference, one must use the <TT>valof</TT> operator
(i.e. <TT>*</TT> operator).
The <TT>swap</TT> function which swaps its two <TT>inout</TT> arguments
has already been introduced:
<PRE>
function swap(rx, ry) {
    v := *rx;
  *rx := *ry;
  *ry := v;
}
</PRE>
The arguments have been prefixed by <TT>r</TT> to
indicate that they are references.
So, the function call <TT>swap(&amp;x, &amp;y)</TT> will swap properly
the variables <TT>x</TT> and <TT>y</TT>.
<BR>
One can add type checking in the <TT>swap</TT> function, as follows:
<PRE>
function swap(rx, ry) {
  assert_msg(is_ident(rx), "swap: argument #1 identifier expected");
  assert_msg(is_ident(ry), "swap: argument #2 identifier expected");
    v := *rx;
  *rx := *ry;
  *ry := v;
}
</PRE>

<P>

<H3><A NAME="SECTION002534300000000000000"></A> <A NAME="7681"></A>
<BR>
Return Value
</H3>
By default, a statement-oriented function returns no atom. To make a
function returning an atom, one must use the <TT>return</TT> statement
previously introduced. As a function has no specified returned
type, it may contained several <TT>return</TT> statements returning
atom of different types:
<PRE>
function perform(x) {
  if (x == 1)
    return "hello";
  if (x == 2)
    return list(1, 2, 3) + list(4, 20);
  if (x == 3)
    return 2;
  if (x == 4)
    return 'a';
}

alpha := perform(1); // alpha is equal to "hello"
alpha := perform(3); // alpha is equal to 2
alpha := perform(8); // alpha is equal to nil
</PRE>

<P>

<H3><A NAME="SECTION002534400000000000000"></A> <A NAME="7683"></A>
<BR>
Default Arguments
</H3>
OQL provides support for default arguments in a function definition
statement.
The syntax for a default argument is: ``<TT>var</TT> <TT>?</TT> <SPAN  CLASS="textit">expr</SPAN>''
or ``<TT>var</TT> <TT>:=</TT> <SPAN  CLASS="textit">expr</SPAN>''.
<BR>
As in C and C++, the arguments with a default value must not followed
by any argument with default values.
For instance, <TT>function f(x, y, z := "alpha")</TT> is valid
while <TT>function f(x, y, z := "alpha", t)</TT> is not valid.

<P>

<H3><A NAME="SECTION002534500000000000000"></A> <A NAME="7685"></A>
<BR>
Unval Arguments
</H3>
Sometimes, it is interesting to prevent the evaluation of some input
arguments. For instance, let the function <TT>if_then_else</TT> which takes
three arguments:

<OL>
<LI><TT>cond</TT>: a boolean expression,
</LI>
<LI><TT>then_expr</TT>: expression of any type; is evaluated and returned
if and only if the condition is evaluated to <TT>true</TT>
</LI>
<LI><TT>else_expr</TT>: expression of any type; is evaluated and returned
if and only if the condition is evaluated to <TT>false</TT>
</LI>
</OL>
It is clear that the following function definition:
<PRE>
function if_then_else(cond, then_expr, else_expr) {
   if (cond)
     return then_expr;
   return else_expr;
</PRE>
is not correct as, although it returns the correct expression,
the <TT>then_expr</TT> <SPAN  CLASS="textit">and</SPAN> the <TT>else_expr</TT> will be evaluated.
For instance, <TT>if_then_else(x &lt; 10, ::a := 2, ::b := 3)</TT> will
return <TT>2</TT> if <TT>x</TT> is less than <TT>10</TT>, otherwise
it will return <TT>3</TT>, but in any case, <TT>a</TT> will be assigned
to <TT>2</TT> and <TT>b</TT> will be assigned to <TT>3</TT>.

<BR>
So, one needs a way to tell the interpreter that we do not want to evaluate
the second and the third argument. The special character <TT><SPAN CLASS="MATH"><IMG
 WIDTH="8" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img1.png"
 ALT="$\vert$"></SPAN></TT>
before an argument means that this argument must not be evaluated.
In this case, this argument is substitued by the string representation of
the expression.
For instance, let the function <TT>if_then_else</TT>:
<PRE>
function if_then_else(cond, |then_expr, |else_expr) {
   // ...
}
</PRE>
when performing the call ``<TT>if_then_else(x &lt; 10, ::a := 2, ::b := 3)</TT>'':

<OL>
<LI>the value of <TT>cond</TT> in the body of the function will be
<TT>true</TT> or <TT>false</TT>,
</LI>
<LI>the value of <TT>then_expr</TT> in the body of the function will be
<TT>"::a:=2"</TT>
</LI>
<LI>the value of <TT>else_expr</TT> in the body of the function will be
<TT>"::b:=3"</TT>
</LI>
</OL>
The correct implementation of this function is as follows:
<PRE>
function if_then_else(cond, |then_expr, |else_expr) {
   if (cond)
     return eval then_expr;
   return eval else_expr;
}
</PRE>

<P>

<H3><A NAME="SECTION002534600000000000000"></A> <A NAME="7691"></A>
<BR>
Scope of Variables
</H3>
In the body of a function defintion, every variable on the left side of an
assignment has a local scope except if this variable is prefixed by
the global scope operator <TT>::</TT>.
That means, that after the following statement sequence:
<PRE>
a := 2;

function doit() {
   a := 1;
}
</PRE>
the variable <TT>a</TT> is still equal to <TT>2</TT>. While after:

<H3><A NAME="SECTION002534700000000000000"></A> <A NAME="7693"></A>
<BR>
Recursivity
</H3>
<PRE>
a := 2;

function doit() {
   ::a := 1;
}
</PRE>
the variable <TT>a</TT> is equal to <TT>1</TT>.

<P>

<H3><A NAME="SECTION002534800000000000000"></A> <A NAME="7695"></A>
<BR>
Particularity
</H3>
One can define a statement-oriented function inside the body of
a statement-oriented function, for instance:
<PRE>
function compute(amount_in_euro, usdollar_per_euro) {

  function euro2usdollar(euro, usd ? usdollar_per_euro) {
      return euro * usd;
  }

  x := euro2usdollar(euro * 1.24);
  x += euro2usdollar(1000);

  return x * .120;
}
</PRE>

<P>
Note that the function defined in the body of the function <TT>compute</TT>
has a global scope, that means that after one execution of <TT>compute</TT>
the function is available at the global level of the OQL session.
It is possible, that in a future version, the functions defined in
the body of a function definition will have a local scope.

<P>

<H3><A NAME="SECTION002534900000000000000">
The <TT>oql$functions</TT> Variable</A>
</H3> <A NAME="7700"></A>
The <TT>oql$functions</TT> value is a list whose elements are the name of all
the OQL functions
defined in the current OQL session. Each you add a user function,
this variable is updated.
At the beginning of a session,
the value of 
<BR>
textttoql$functions is:
<PRE>
list(is_int, is_char, is_double, is_string, is_oid, is_num, is_bool, is_bag,
     is_set, is_array, is_list, is_coll, is_struct, is_empty, void, assert,
     assert_msg, min, max, first, last, cdr, count, interval, sum, avg, is_in,
     distinct, flatten, flatten1, tolower, toupper, tocap, toset, tolist,
     tobag, toarray, listtoset, bagtoset, arraytoset, listtobag, settobag,
     arraytobag, bagtolist, settolist, arraytolist, bagtoarray, settoarray,
     listtoarray, strlen, substring, forone, forall, delete_from, get_from,
     ifempty, null_ifempty, getone)
</PRE>
For instance, to put the complete definition of all
these functions into the variable <TT>functionString</TT>:
<PRE>
 functionString := "";
 for (x in oql$functions)
   functionString += "FUNCTION " x + ": " +  bodyof x + "\n";
</PRE>
The next section provides a few statement-oriented and
expression-oriented function definitions.

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html517"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html513"
  HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html507"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html515"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html518"
  HREF="node8.html">Quick Reference Manual</A>
<B> Up:</B> <A NAME="tex2html514"
  HREF="node2.html">The Object Query Language</A>
<B> Previous:</B> <A NAME="tex2html508"
  HREF="node6.html">Language Concepts</A>
 &nbsp; <B>  <A NAME="tex2html516"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
EyeDB manual
</ADDRESS>
</BODY>
</HTML>
