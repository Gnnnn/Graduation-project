<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>eyedb: odl.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>odl.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* </span>
<a name="l00002"></a>00002 <span class="comment">   EyeDB Object Database Management System</span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1994-2008 SYSRA</span>
<a name="l00004"></a>00004 <span class="comment">   </span>
<a name="l00005"></a>00005 <span class="comment">   EyeDB is free software; you can redistribute it and/or</span>
<a name="l00006"></a>00006 <span class="comment">   modify it under the terms of the GNU Lesser General Public</span>
<a name="l00007"></a>00007 <span class="comment">   License as published by the Free Software Foundation; either</span>
<a name="l00008"></a>00008 <span class="comment">   version 2.1 of the License, or (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment">   </span>
<a name="l00010"></a>00010 <span class="comment">   EyeDB is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment">   Lesser General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment">   </span>
<a name="l00015"></a>00015 <span class="comment">   You should have received a copy of the GNU Lesser General Public</span>
<a name="l00016"></a>00016 <span class="comment">   License along with this library; if not, write to the Free Software</span>
<a name="l00017"></a>00017 <span class="comment">   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA </span>
<a name="l00018"></a>00018 <span class="comment">*/</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/*</span>
<a name="l00021"></a>00021 <span class="comment">   Author: Eric Viara &lt;viara@sysra.com&gt;</span>
<a name="l00022"></a>00022 <span class="comment">*/</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;odl.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;misc.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;eyedb/internals/ClassPeer.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;eyedb/internals/ObjectPeer.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;oql_p.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;CollectionBE.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;eyedblib/butils.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;oqlctb.h&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">using</span> std::ostringstream;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#define NO_DIRECT_SET</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor">#define NEW_REORDER</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#define NEW_DIFF_RELSHIP</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="keyword">namespace </span>eyedb {
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   LinkedList *odl_decl_list;
<a name="l00046"></a>00046   ProgLang odl_lang = (ProgLang)0;
<a name="l00047"></a>00047   <span class="keywordtype">int</span> odl_error;
<a name="l00048"></a>00048   <span class="keywordtype">int</span> odl_diff;
<a name="l00049"></a>00049   <span class="keyword">const</span> <span class="keywordtype">char</span> *odl_rootclass;
<a name="l00050"></a>00050   LinkedList qseq_list;
<a name="l00051"></a>00051   odlAgregatClass *odlAgregatClass::superclass;
<a name="l00052"></a>00052   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> odlAgregatClass::class_count;
<a name="l00053"></a>00053   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *odl_prefix;
<a name="l00054"></a>00054   <span class="keyword">static</span> std::string odl_db_prefix;
<a name="l00055"></a>00055   <span class="keyword">static</span> Bool odl_gencode = False;
<a name="l00056"></a>00056   Bool odl_system_class = False;
<a name="l00057"></a>00057   Bool odl_rmv_undef_attrcomp = False;
<a name="l00058"></a>00058   Bool odl_update_index = False;
<a name="l00059"></a>00059   Bool odl_dynamic_attr = False;
<a name="l00060"></a>00060   Bool odl_class_enums = False;
<a name="l00061"></a>00061   Bool odl_sch_rm = False;
<a name="l00062"></a>00062   Bool odl_smartptr = False;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   LinkedList odl_cls_rm;
<a name="l00065"></a>00065   <span class="keyword">static</span> Bool odl_not_check_missing = IDBBOOL(getenv(<span class="stringliteral">&quot;EYEDBNOCHECKMISSING&quot;</span>));
<a name="l00066"></a>00066   FILE *odl_fd = stdout;
<a name="l00067"></a>00067   <span class="keyword">static</span> FILE *odl_fdnull = fopen(<span class="stringliteral">&quot;/dev/null&quot;</span>, <span class="stringliteral">&quot;rw&quot;</span>);
<a name="l00068"></a>00068   LinkedList odlAgregatClass::declared_list;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> odlUPDLIST[] = <span class="stringliteral">&quot;eyedb:odl:update:list&quot;</span>;
<a name="l00071"></a>00071   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> odlSELF[] = <span class="stringliteral">&quot;eyedb:odl:self&quot;</span>;
<a name="l00072"></a>00072   <span class="keywordtype">char</span> odlMTHLIST[] = <span class="stringliteral">&quot;eyedb:odl:method&quot;</span>;
<a name="l00073"></a>00073   <span class="keywordtype">char</span> odlGENCOMP[] = <span class="stringliteral">&quot;eyedb:odl:gencomp&quot;</span>;
<a name="l00074"></a>00074   <span class="keywordtype">char</span> odlGENCODE[] = <span class="stringliteral">&quot;eyedb:odl:gencode&quot;</span>;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="preprocessor">#define odlUPDLIST(M) ((LinkedList *)(M)-&gt;getUserData(odlUPDLIST))</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#define odlMTHLIST(C) ((LinkedList *)(C)-&gt;getUserData(odlMTHLIST))</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079   FILE *
<a name="l00080"></a>00080   run_cpp(FILE *fd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags,
<a name="l00081"></a>00081           <span class="keyword">const</span> <span class="keywordtype">char</span> *file);
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   <span class="keyword">static</span>
<a name="l00084"></a>00084   Database *odl_get_dummy_db(Schema *m)
<a name="l00085"></a>00085   {
<a name="l00086"></a>00086     <span class="keyword">static</span> Database *dumdb;
<a name="l00087"></a>00087     <span class="keywordflow">if</span> (!dumdb) {
<a name="l00088"></a>00088       dumdb = <span class="keyword">new</span> Database(<span class="stringliteral">&quot;dummy&quot;</span>);
<a name="l00089"></a>00089       dumdb-&gt;setSchema(m);
<a name="l00090"></a>00090     }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="keywordflow">return</span> dumdb;
<a name="l00093"></a>00093   }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00096"></a>00096   magorder_error(<span class="keyword">const</span> Class *cls, <span class="keyword">const</span> <span class="keywordtype">char</span> *attrname, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l00097"></a>00097   {
<a name="l00098"></a>00098     <span class="keywordflow">if</span> (attrname)
<a name="l00099"></a>00099       odl_add_error
<a name="l00100"></a>00100         (std::string(<span class="stringliteral">&quot;attribute: &quot;</span>) + cls-&gt;getName() + <span class="stringliteral">&quot;::&quot;</span> +
<a name="l00101"></a>00101          attrname + <span class="stringliteral">&quot; cannot have several &quot;</span> + type + <span class="stringliteral">&quot; specifications\n&quot;</span>);
<a name="l00102"></a>00102     <span class="keywordflow">else</span>
<a name="l00103"></a>00103       odl_add_error
<a name="l00104"></a>00104         (std::string(<span class="stringliteral">&quot;class: &quot;</span>) + cls-&gt;getName() +
<a name="l00105"></a>00105          <span class="stringliteral">&quot; cannot have several &quot;</span> + type + <span class="stringliteral">&quot; specifications\n&quot;</span>);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     <span class="keywordflow">return</span> 0;
<a name="l00108"></a>00108   }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   <span class="keyword">static</span> std::string odl_str_error;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="keywordtype">void</span>
<a name="l00113"></a>00113   odl_add_error(Status s)
<a name="l00114"></a>00114   {
<a name="l00115"></a>00115     ostringstream ostr;
<a name="l00116"></a>00116     ostr &lt;&lt; s;
<a name="l00117"></a>00117     odl_str_error += ostr.str();
<a name="l00118"></a>00118     <span class="keywordflow">if</span> (odl_str_error[odl_str_error.size()-1] != <span class="charliteral">&apos;\n&apos;</span>)
<a name="l00119"></a>00119       odl_str_error += <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00120"></a>00120     odl_error++;
<a name="l00121"></a>00121   }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="keywordtype">void</span>
<a name="l00124"></a>00124   odl_add_error(<span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00125"></a>00125   {
<a name="l00126"></a>00126     va_list ap, aq;
<a name="l00127"></a>00127     va_start(ap, fmt);
<a name="l00128"></a>00128     va_copy(aq, ap);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="keywordtype">char</span> *s = eyedblib::getFBuffer(fmt, ap);
<a name="l00131"></a>00131     vsprintf(s, fmt, aq);
<a name="l00132"></a>00132     va_end(ap);
<a name="l00133"></a>00133     odl_str_error += s;
<a name="l00134"></a>00134     odl_error++;
<a name="l00135"></a>00135   }
<a name="l00136"></a>00136 
<a name="l00137"></a>00137   <span class="keywordtype">void</span>
<a name="l00138"></a>00138   odl_add_error(<span class="keyword">const</span> std::string &amp;s)
<a name="l00139"></a>00139   {
<a name="l00140"></a>00140     odl_str_error += s;
<a name="l00141"></a>00141     odl_error++;
<a name="l00142"></a>00142   }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="keyword">static</span> Status
<a name="l00145"></a>00145   odl_status_error(<span class="keywordtype">int</span> r = 0)
<a name="l00146"></a>00146   {
<a name="l00147"></a>00147     <span class="keywordflow">if</span> (odl_error)
<a name="l00148"></a>00148       <span class="keywordflow">return</span> <a class="code" href="classeyedb_1_1Exception.html#abef1b4931e6b7c02fc77915f5ffdb502" title="Not yet documented.">Exception::make</a>(IDB_ERROR, odl_str_error.c_str());
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (odl_str_error != std::string(<span class="stringliteral">&quot;&quot;</span>))
<a name="l00151"></a>00151       fprintf(stderr, <span class="stringliteral">&quot;%s\n&quot;</span>, odl_str_error.c_str());
<a name="l00152"></a>00152     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r)
<a name="l00153"></a>00153       <span class="keywordflow">return</span> <a class="code" href="classeyedb_1_1Exception.html#abef1b4931e6b7c02fc77915f5ffdb502" title="Not yet documented.">Exception::make</a>(IDB_ERROR, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     <span class="keywordflow">return</span> Success;
<a name="l00156"></a>00156   }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="keyword">static</span> Class *
<a name="l00159"></a>00159   getClass(Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix)
<a name="l00160"></a>00160   {
<a name="l00161"></a>00161     Class *cls;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     cls = m-&gt;<a class="code" href="classeyedb_1_1Object.html#a7d3e24a2bc7b368c8c39458ab0c3313e" title="Not yet documented.">getClass</a>(name);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     <span class="keywordflow">if</span> (cls) <span class="keywordflow">return</span> cls;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     <span class="keywordflow">return</span> m-&gt;<a class="code" href="classeyedb_1_1Object.html#a7d3e24a2bc7b368c8c39458ab0c3313e" title="Not yet documented.">getClass</a>(makeName(name, prefix));
<a name="l00168"></a>00168   }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00171"></a>00171   odl_copy_attr_comp_sets(Class *ocls, Class *cls)
<a name="l00172"></a>00172   {
<a name="l00173"></a>00173     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attr_cnt;
<a name="l00174"></a>00174     Attribute **attrs = (Attribute **)cls-&gt;getAttributes(attr_cnt);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; attr_cnt; i++)
<a name="l00177"></a>00177       {
<a name="l00178"></a>00178         <span class="keyword">const</span> Attribute *oattr = ocls-&gt;getAttribute(attrs[i]-&gt;getName());
<a name="l00179"></a>00179         <span class="keywordflow">if</span> (oattr) {
<a name="l00180"></a>00180           <span class="comment">/*</span>
<a name="l00181"></a>00181 <span class="comment">            printf(&quot;%s::%s attr_comp_set_oid %s -&gt; %s\n&quot;,</span>
<a name="l00182"></a>00182 <span class="comment">            oattr-&gt;getAttrCompSetOid().toString(),</span>
<a name="l00183"></a>00183 <span class="comment">            attrs[i]-&gt;getAttrCompSetOid().toString(),</span>
<a name="l00184"></a>00184 <span class="comment">            attrs[i]-&gt;getDynClassOwner()-&gt;getName(),</span>
<a name="l00185"></a>00185 <span class="comment">            attrs[i]-&gt;getName());</span>
<a name="l00186"></a>00186 <span class="comment">          */</span>
<a name="l00187"></a>00187           attrs[i]-&gt;setAttrCompSetOid(oattr-&gt;getAttrCompSetOid());
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189       }
<a name="l00190"></a>00190   }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_in(<span class="keyword">const</span> std::vector&lt;Class *&gt; &amp;rm_v, Class *cls) {
<a name="l00193"></a>00193     std::vector&lt;Class *&gt;::const_iterator begin = rm_v.begin();
<a name="l00194"></a>00194     std::vector&lt;Class *&gt;::const_iterator end = rm_v.end();
<a name="l00195"></a>00195     <span class="keywordflow">while</span> (begin != end) {
<a name="l00196"></a>00196       <span class="keywordflow">if</span> (cls == *begin)
<a name="l00197"></a>00197         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00198"></a>00198       ++begin;
<a name="l00199"></a>00199     }
<a name="l00200"></a>00200     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00201"></a>00201   }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00204"></a>00204   odl_check_removed(Schema *m, LinkedList *&amp;list)
<a name="l00205"></a>00205   {
<a name="l00206"></a>00206     <span class="keywordflow">if</span> (odl_sch_rm) {
<a name="l00207"></a>00207       <span class="keywordflow">if</span> (!list)
<a name="l00208"></a>00208         list = <span class="keyword">new</span> LinkedList();
<a name="l00209"></a>00209       <span class="keyword">const</span> LinkedList *cls_list = m-&gt;getClassList();
<a name="l00210"></a>00210       odlUpdateHint *rmHints = <span class="keyword">new</span> odlUpdateHint(odlUpdateHint::Remove);
<a name="l00211"></a>00211       Class *cls;
<a name="l00212"></a>00212       <span class="comment">// bug corrected 21/01/06</span>
<a name="l00213"></a>00213 <span class="preprocessor">#if 1</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>      std::vector&lt;Class *&gt; rm_v;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cnt = 0;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218       <span class="keywordflow">do</span> {
<a name="l00219"></a>00219         LinkedListCursor c(cls_list);
<a name="l00220"></a>00220         cnt = 0;
<a name="l00221"></a>00221         <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)cls)) {
<a name="l00222"></a>00222           <span class="keywordflow">if</span> (cls-&gt;isSystem() || is_in(rm_v, cls))
<a name="l00223"></a>00223             <span class="keywordflow">continue</span>;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225           Class **subclasses;
<a name="l00226"></a>00226           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subclass_cnt;
<a name="l00227"></a>00227           cls-&gt;getSubClasses(subclasses, subclass_cnt);
<a name="l00228"></a>00228           <span class="keywordtype">bool</span> subclass_notin = <span class="keyword">false</span>;
<a name="l00229"></a>00229           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; subclass_cnt; n++) {
<a name="l00230"></a>00230             <span class="keywordflow">if</span> (subclasses[n] != cls &amp;&amp; !is_in(rm_v, subclasses[n])) {
<a name="l00231"></a>00231               subclass_notin = <span class="keyword">true</span>;
<a name="l00232"></a>00232               <span class="keywordflow">break</span>;
<a name="l00233"></a>00233             }
<a name="l00234"></a>00234           }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236           <span class="keywordflow">if</span> (!subclass_notin) {
<a name="l00237"></a>00237             rm_v.push_back(cls);
<a name="l00238"></a>00238             cnt++;
<a name="l00239"></a>00239           }
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242       } <span class="keywordflow">while</span>(cnt);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244       std::vector&lt;Class *&gt;::iterator begin = rm_v.begin();
<a name="l00245"></a>00245       std::vector&lt;Class *&gt;::iterator end = rm_v.end();
<a name="l00246"></a>00246       <span class="keywordflow">while</span> (begin != end) {
<a name="l00247"></a>00247         cls = *begin;
<a name="l00248"></a>00248         odlClassSpec *clsspec = <span class="keyword">new</span> odlClassSpec(cls-&gt;getName(), 0,
<a name="l00249"></a>00249                                                  cls-&gt;getName(), 0);
<a name="l00250"></a>00250         <span class="keyword">new</span> odlAgregatClass(rmHints, odl_Struct,  clsspec,
<a name="l00251"></a>00251                             <span class="keyword">new</span> odlDeclRootList());
<a name="l00252"></a>00252         ++begin;
<a name="l00253"></a>00253       }
<a name="l00254"></a>00254 <span class="preprocessor">#else</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>      LinkedListCursor c(cls_list);
<a name="l00256"></a>00256       <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)cls)) {
<a name="l00257"></a>00257         <span class="keywordflow">if</span> (cls-&gt;isSystem())
<a name="l00258"></a>00258           <span class="keywordflow">continue</span>;
<a name="l00259"></a>00259         odlClassSpec *clsspec = <span class="keyword">new</span> odlClassSpec(cls-&gt;getName(), 0,
<a name="l00260"></a>00260                                                  cls-&gt;getName(), 0);
<a name="l00261"></a>00261         <span class="keyword">new</span> odlAgregatClass(rmHints, odl_Struct,  clsspec,
<a name="l00262"></a>00262                             <span class="keyword">new</span> odlDeclRootList());
<a name="l00263"></a>00263       }
<a name="l00264"></a>00264 <span class="preprocessor">#endif</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span>
<a name="l00266"></a>00266       <span class="keywordflow">return</span>;
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268     
<a name="l00269"></a>00269     <span class="keywordflow">if</span> (odl_cls_rm.getCount() == 0)
<a name="l00270"></a>00270       <span class="keywordflow">return</span>;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     <span class="keywordflow">if</span> (!list)
<a name="l00273"></a>00273       list = <span class="keyword">new</span> LinkedList();
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="keywordtype">char</span> *name;
<a name="l00276"></a>00276     LinkedListCursor c(odl_cls_rm);
<a name="l00277"></a>00277     odlUpdateHint *rmHints = <span class="keyword">new</span> odlUpdateHint(odlUpdateHint::Remove);
<a name="l00278"></a>00278     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> * &amp;)name)) {
<a name="l00279"></a>00279       <span class="comment">//printf(&quot;adding declaration %s for removal\n&quot;, name);</span>
<a name="l00280"></a>00280       odlClassSpec *clsspec = <span class="keyword">new</span> odlClassSpec(name, 0, name, 0);
<a name="l00281"></a>00281       <span class="keyword">new</span> odlAgregatClass(rmHints, odl_Struct,
<a name="l00282"></a>00282                           clsspec,
<a name="l00283"></a>00283                           <span class="keyword">new</span> odlDeclRootList());
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="keyword">static</span> Bool
<a name="l00288"></a>00288   odl_check_renamed_from(Schema *m, LinkedList *list, Class *cls)
<a name="l00289"></a>00289   {
<a name="l00290"></a>00290     LinkedListCursor clx(list);
<a name="l00291"></a>00291     odlDeclaration *decl;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="keywordflow">while</span> (clx.getNext((<span class="keywordtype">void</span> *&amp;)decl))
<a name="l00294"></a>00294       <span class="keywordflow">if</span> (decl-&gt;asAgregatClass()) {
<a name="l00295"></a>00295         odlUpdateHint *upd_hints = decl-&gt;asAgregatClass()-&gt;upd_hints;
<a name="l00296"></a>00296         <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::RenameFrom &amp;&amp;
<a name="l00297"></a>00297             !strcmp(upd_hints-&gt;detail, cls-&gt;getName()))
<a name="l00298"></a>00298           <span class="keywordflow">return</span> True;
<a name="l00299"></a>00299       }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     <span class="keywordflow">return</span> False;
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00305"></a>00305   odl_check_missing(Schema *m, LinkedList *list)
<a name="l00306"></a>00306   {
<a name="l00307"></a>00307     LinkedListCursor cm(m-&gt;getClassList());
<a name="l00308"></a>00308     Class *cls;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordflow">while</span> (cm.getNext((<span class="keywordtype">void</span> *&amp;)cls))
<a name="l00311"></a>00311       {
<a name="l00312"></a>00312         <span class="keywordflow">if</span> (cls-&gt;isPartiallyLoaded())
<a name="l00313"></a>00313           {
<a name="l00314"></a>00314             Status s = m-&gt;manageClassDeferred(cls);
<a name="l00315"></a>00315             <span class="keywordflow">if</span> (s)
<a name="l00316"></a>00316               {
<a name="l00317"></a>00317                 odl_add_error(s);
<a name="l00318"></a>00318                 <span class="keywordflow">break</span>;
<a name="l00319"></a>00319               }
<a name="l00320"></a>00320           }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         <span class="keywordflow">if</span> (cls-&gt;isSystem() || cls-&gt;asCollectionClass())
<a name="l00323"></a>00323           <span class="keywordflow">continue</span>;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         LinkedListCursor cl(list);
<a name="l00326"></a>00326         odlDeclaration *decl;
<a name="l00327"></a>00327         Bool found = False;
<a name="l00328"></a>00328         <span class="keywordflow">while</span> (cl.getNext((<span class="keywordtype">void</span> *&amp;)decl))
<a name="l00329"></a>00329           <span class="keywordflow">if</span> (!strcmp(decl-&gt;getName(), cls-&gt;getName()) ||
<a name="l00330"></a>00330               (decl-&gt;getAliasName() &amp;&amp;
<a name="l00331"></a>00331                !strcmp(decl-&gt;getAliasName(), cls-&gt;getName())))
<a name="l00332"></a>00332             {
<a name="l00333"></a>00333               found = True;
<a name="l00334"></a>00334               <span class="keywordflow">break</span>;
<a name="l00335"></a>00335             }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337         <span class="keywordflow">if</span> (!found)
<a name="l00338"></a>00338           {
<a name="l00339"></a>00339 <span class="preprocessor">#define MANAGE_MISSING_CLASSES</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span>            <span class="comment">// disconnected the 21/05/2001</span>
<a name="l00341"></a>00341             <span class="comment">// because this put the bordel in the components of missing</span>
<a name="l00342"></a>00342             <span class="comment">// classes (index, methods, constraints)!</span>
<a name="l00343"></a>00343 <span class="preprocessor">#ifdef MANAGE_MISSING_CLASSES</span>
<a name="l00344"></a>00344 <span class="preprocessor"></span>
<a name="l00345"></a>00345             <span class="keywordflow">if</span> (!odl_gencode) { <span class="comment">// add not declared class on the fly</span>
<a name="l00346"></a>00346               <span class="keywordflow">if</span> (!odl_check_renamed_from(m, list, cls)) {
<a name="l00347"></a>00347 <span class="preprocessor">#if 0</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span>                list-&gt;insertObject
<a name="l00349"></a>00349                   (<span class="keyword">new</span> odlAgregatClass(0, odl_Declare,
<a name="l00350"></a>00350                                        <span class="keyword">new</span> odlClassSpec(cls-&gt;getName(), 0, 0, 0),
<a name="l00351"></a>00351                                        <span class="keyword">new</span> odlDeclRootList()));
<a name="l00352"></a>00352 <span class="preprocessor">#else</span>
<a name="l00353"></a>00353 <span class="preprocessor"></span>                <span class="keyword">new</span> odlAgregatClass(0, odl_Declare,
<a name="l00354"></a>00354                                     <span class="keyword">new</span> odlClassSpec(cls-&gt;getName(), 0, 0, 0),
<a name="l00355"></a>00355                                     <span class="keyword">new</span> odlDeclRootList());
<a name="l00356"></a>00356 <span class="preprocessor">#endif</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>                <span class="comment">//printf(&quot;declaring %p %s\n&quot;, cls, cls-&gt;getName());</span>
<a name="l00358"></a>00358               }
<a name="l00359"></a>00359             }
<a name="l00360"></a>00360             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!odl_not_check_missing)
<a name="l00361"></a>00361 <span class="preprocessor">#endif</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>              odl_add_error(<span class="stringliteral">&quot;class %s is missing in ODL\n&quot;</span>, cls-&gt;getName());
<a name="l00363"></a>00363           }
<a name="l00364"></a>00364       }
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="keyword">static</span> Bool
<a name="l00368"></a>00368   odl_has_attribute(<span class="keyword">const</span> Class *origcls, <span class="keyword">const</span> Class *cls,
<a name="l00369"></a>00369                     <span class="keyword">const</span> <span class="keywordtype">char</span> *attrname)
<a name="l00370"></a>00370   {
<a name="l00371"></a>00371 <span class="preprocessor">#if 1</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>    <span class="keywordflow">return</span> True;
<a name="l00373"></a>00373 <span class="preprocessor">#endif</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!cls)
<a name="l00375"></a>00375       <span class="keywordflow">return</span> False;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377     <span class="keywordflow">if</span> (cls-&gt;getAttribute(attrname))
<a name="l00378"></a>00378       {
<a name="l00379"></a>00379         odl_add_error(<span class="stringliteral">&quot;attribute &apos;%s&apos; exists both in class &apos;%s&apos; and its &quot;</span>
<a name="l00380"></a>00380                       <span class="stringliteral">&quot;superclass &apos;%s&apos;\n&quot;</span>,
<a name="l00381"></a>00381                       attrname,  origcls-&gt;getName(), cls-&gt;getName());
<a name="l00382"></a>00382         <span class="keywordflow">return</span> True;
<a name="l00383"></a>00383       }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     <span class="keywordflow">return</span> odl_has_attribute(origcls, cls-&gt;getParent(), attrname);
<a name="l00386"></a>00386   }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00390"></a>00390   odl_check_attributes(<span class="keyword">const</span> Class *cls)
<a name="l00391"></a>00391   {
<a name="l00392"></a>00392     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attr_cnt;
<a name="l00393"></a>00393     Attribute **attrs = (Attribute **)cls-&gt;getAttributes(attr_cnt);
<a name="l00394"></a>00394   
<a name="l00395"></a>00395     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; attr_cnt; i++)
<a name="l00396"></a>00396       {
<a name="l00397"></a>00397         <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l00398"></a>00398         <span class="keywordflow">if</span> (!attr-&gt;isNative() &amp;&amp; attr-&gt;getClassOwner()-&gt;compare(cls))
<a name="l00399"></a>00399           odl_has_attribute(cls, cls-&gt;getParent(), attr-&gt;getName());
<a name="l00400"></a>00400       }
<a name="l00401"></a>00401   }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="keywordtype">int</span>
<a name="l00404"></a>00404   odl_realize(Database *db, Schema *m, LinkedList *list,
<a name="l00405"></a>00405               <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l00406"></a>00406               <span class="keyword">const</span> <span class="keywordtype">char</span> *package, Bool diff)
<a name="l00407"></a>00407   {
<a name="l00408"></a>00408     <span class="keywordflow">if</span> (!prefix)    prefix = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (!db_prefix) db_prefix = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00410"></a>00410     <span class="keywordflow">if</span> (!package)   <span class="keyword">package </span>= &quot;&quot;;
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     odl_prefix = prefix;
<a name="l00413"></a>00413     odl_db_prefix = db_prefix;
<a name="l00414"></a>00414 
<a name="l00415"></a>00415     odl_check_removed(m, list);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417     <span class="keywordflow">if</span> (list &amp;&amp; list-&gt;getCount()) {
<a name="l00418"></a>00418       odlDeclaration *decl;
<a name="l00419"></a>00419       
<a name="l00420"></a>00420       m-&gt;setUserData(odlUPDLIST, <span class="keyword">new</span> LinkedList());
<a name="l00421"></a>00421       
<a name="l00422"></a>00422       odl_check_missing(m, list);
<a name="l00423"></a>00423       <span class="keywordflow">if</span> (odl_error)
<a name="l00424"></a>00424         <span class="keywordflow">return</span> 1;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426       LinkedListCursor curs(list);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428       <span class="keywordflow">while</span> (curs.getNext((<span class="keywordtype">void</span>* &amp;)decl))
<a name="l00429"></a>00429         decl-&gt;record(db, m, prefix, db_prefix);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431       <span class="keywordflow">if</span> (odl_error)
<a name="l00432"></a>00432         <span class="keywordflow">return</span> 1;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434       curs.restart();
<a name="l00435"></a>00435       <span class="keywordflow">while</span> (curs.getNext((<span class="keywordtype">void</span>* &amp;)decl))
<a name="l00436"></a>00436         decl-&gt;realize(db, m, prefix, package, diff);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438       <span class="keywordflow">if</span> (odl_error)
<a name="l00439"></a>00439         <span class="keywordflow">return</span> 1;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="preprocessor">#ifdef NEW_REORDER</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span>      curs.restart();
<a name="l00443"></a>00443       <span class="keywordflow">while</span> (curs.getNext((<span class="keywordtype">void</span>* &amp;)decl))
<a name="l00444"></a>00444         <span class="keywordflow">if</span> (decl-&gt;asAgregatClass())
<a name="l00445"></a>00445           decl-&gt;asAgregatClass()-&gt;preManage(m);
<a name="l00446"></a>00446 <span class="preprocessor">#endif</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span>
<a name="l00448"></a>00448       <span class="keywordflow">if</span> (odl_error)
<a name="l00449"></a>00449         <span class="keywordflow">return</span> 1;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451       curs.restart();
<a name="l00452"></a>00452       <span class="keywordflow">while</span> (curs.getNext((<span class="keywordtype">void</span>* &amp;)decl))
<a name="l00453"></a>00453         <span class="keywordflow">if</span> (decl-&gt;asAgregatClass())
<a name="l00454"></a>00454           decl-&gt;asAgregatClass()-&gt;postRealize(db, m, prefix);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456       <span class="keywordflow">if</span> (odl_error)
<a name="l00457"></a>00457         <span class="keywordflow">return</span> 1;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459       curs.restart();
<a name="l00460"></a>00460       <span class="keywordflow">while</span> (curs.getNext((<span class="keywordtype">void</span>* &amp;)decl))
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (decl-&gt;asAgregatClass())
<a name="l00462"></a>00462           decl-&gt;asAgregatClass()-&gt;manageDifferences(db, m, diff);
<a name="l00463"></a>00463     }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     <span class="keyword">const</span> LinkedList *_class = m-&gt;getClassList();
<a name="l00466"></a>00466     LinkedListCursor curs(_class);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468     Class *cl;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (!odl_error &amp;&amp; !odl_diff)
<a name="l00471"></a>00471       <span class="keywordflow">while</span> (curs.getNext((<span class="keywordtype">void</span> *&amp;)cl)) {
<a name="l00472"></a>00472         Status status = cl-&gt;checkInverse(m);
<a name="l00473"></a>00473         <span class="keywordflow">if</span> (status)
<a name="l00474"></a>00474           odl_add_error(status);
<a name="l00475"></a>00475       
<a name="l00476"></a>00476         odl_check_attributes(cl);
<a name="l00477"></a>00477       
<a name="l00478"></a>00478         <span class="keywordflow">if</span> (cl-&gt;getUserData())
<a name="l00479"></a>00479           odl_copy_attr_comp_sets((Class *)cl-&gt;getUserData(), cl);
<a name="l00480"></a>00480       }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="keywordflow">if</span> (odl_error) {
<a name="l00483"></a>00483       odl_add_error(<span class="stringliteral">&quot;%d error%s found, compilation aborted\n&quot;</span>,
<a name="l00484"></a>00484                     odl_error, (odl_error &gt; 1 ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;&quot;</span>));
<a name="l00485"></a>00485       <span class="keywordflow">return</span> 1;
<a name="l00486"></a>00486     }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488     <span class="keywordflow">return</span> 0;
<a name="l00489"></a>00489   }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00492"></a>00492   get_superclass_name(<span class="keyword">const</span> <span class="keywordtype">char</span> *prefix = <span class="stringliteral">&quot;&quot;</span>)
<a name="l00493"></a>00493   {
<a name="l00494"></a>00494     <span class="keyword">static</span> <span class="keywordtype">char</span> *spname;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="keywordflow">if</span> (!odlAgregatClass::superclass || spname)
<a name="l00497"></a>00497       <span class="keywordflow">return</span> spname;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499     <span class="keyword">const</span> <span class="keywordtype">char</span> *name = odlAgregatClass::superclass-&gt;getName();
<a name="l00500"></a>00500     <span class="keywordflow">if</span> (prefix &amp;&amp; *prefix)
<a name="l00501"></a>00501       {
<a name="l00502"></a>00502         spname = (<span class="keywordtype">char</span> *)malloc(strlen(prefix)+strlen(name)+1);
<a name="l00503"></a>00503         strcpy(spname, prefix);
<a name="l00504"></a>00504         strcat(spname, name);
<a name="l00505"></a>00505       }
<a name="l00506"></a>00506     <span class="keywordflow">else</span>
<a name="l00507"></a>00507       spname = strdup(name);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509     <span class="keywordflow">return</span> spname;
<a name="l00510"></a>00510   }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512   <span class="keywordtype">int</span>
<a name="l00513"></a>00513   odl_generate_code(Database *db, Schema *m, ProgLang lang,
<a name="l00514"></a>00514                     LinkedList *list,
<a name="l00515"></a>00515                     <span class="keyword">const</span> <span class="keywordtype">char</span> *package, <span class="keyword">const</span> <span class="keywordtype">char</span> *schname,
<a name="l00516"></a>00516                     <span class="keyword">const</span> <span class="keywordtype">char</span> *c_namespace,
<a name="l00517"></a>00517                     <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix, Bool _export,
<a name="l00518"></a>00518                     <span class="keyword">const</span> GenCodeHints &amp;gc_hints)
<a name="l00519"></a>00519   {
<a name="l00520"></a>00520     odl_gencode = True;
<a name="l00521"></a>00521     odl_class_enums = gc_hints.class_enums;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523     <span class="keywordflow">if</span> (odl_realize(db, m, list, prefix, db_prefix, package))
<a name="l00524"></a>00524       <span class="keywordflow">return</span> 1;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526     Class *superclass = NULL;
<a name="l00527"></a>00527     <span class="keywordflow">if</span> (odlAgregatClass::superclass) {
<a name="l00528"></a>00528       superclass = m-&gt;getClass(get_superclass_name(odl_prefix));
<a name="l00529"></a>00529       <span class="keywordflow">if</span> (odlAgregatClass::superclass-&gt;getAgregSpec() == odl_RootClass)
<a name="l00530"></a>00530         superclass-&gt;setIsRootClass();
<a name="l00531"></a>00531     }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     Status status = m-&gt;generateCode
<a name="l00534"></a>00534       (lang, package, schname,
<a name="l00535"></a>00535        c_namespace, prefix, db_prefix, gc_hints,
<a name="l00536"></a>00536        _export,
<a name="l00537"></a>00537        superclass,
<a name="l00538"></a>00538        &amp;qseq_list);
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="keywordflow">if</span> (status) {
<a name="l00541"></a>00541       odl_add_error(status);
<a name="l00542"></a>00542       <span class="keywordflow">return</span> 1;
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     <span class="keywordflow">return</span> 0;
<a name="l00546"></a>00546   }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="preprocessor">#define SWAP_CLSNAMES</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>
<a name="l00550"></a>00550   odlClassSpec::odlClassSpec(<span class="keyword">const</span> <span class="keywordtype">char</span> *_aliasname, <span class="keyword">const</span> <span class="keywordtype">char</span> *_parentname,
<a name="l00551"></a>00551                              <span class="keyword">const</span> <span class="keywordtype">char</span> *_classname, odlCollImplSpec *_coll_impl_spec)
<a name="l00552"></a>00552   {
<a name="l00553"></a>00553     <span class="keywordflow">if</span> (getenv(<span class="stringliteral">&quot;SYSTEM_UPDATE&quot;</span>))
<a name="l00554"></a>00554       {
<a name="l00555"></a>00555         classname = (_aliasname ? strdup(_aliasname) : strdup(_classname));
<a name="l00556"></a>00556         aliasname = 0;
<a name="l00557"></a>00557       }
<a name="l00558"></a>00558     <span class="keywordflow">else</span>
<a name="l00559"></a>00559       {
<a name="l00560"></a>00560 <span class="preprocessor">#ifdef SWAP_CLSNAMES</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span>        classname = (_classname ? strdup(_classname) : strdup(_aliasname));
<a name="l00562"></a>00562         aliasname = strdup(_aliasname);
<a name="l00563"></a>00563 <span class="preprocessor">#else</span>
<a name="l00564"></a>00564 <span class="preprocessor"></span>        classname = strdup(_classname);
<a name="l00565"></a>00565         aliasname = (_aliasname ? strdup(_aliasname) : 0);
<a name="l00566"></a>00566 <span class="preprocessor">#endif</span>
<a name="l00567"></a>00567 <span class="preprocessor"></span>      }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     parentname = (_parentname ? strdup(_parentname) : 0);
<a name="l00570"></a>00570     coll_impl_spec = _coll_impl_spec;
<a name="l00571"></a>00571   }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00574"></a>00574   rename_classes(Schema *m)
<a name="l00575"></a>00575   {
<a name="l00576"></a>00576     Class *cl;
<a name="l00577"></a>00577     LinkedListCursor c(m-&gt;getClassList());
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)cl))
<a name="l00580"></a>00580       <span class="keywordflow">if</span> (cl-&gt;asAgregatClass())
<a name="l00581"></a>00581         cl-&gt;asAgregatClass()-&gt;completeInverse(m);
<a name="l00582"></a>00582 
<a name="l00583"></a>00583     LinkedListCursor cx(m-&gt;getClassList());
<a name="l00584"></a>00584 
<a name="l00585"></a>00585     <span class="keywordflow">while</span> (cx.getNext((<span class="keywordtype">void</span> *&amp;)cl)) {
<a name="l00586"></a>00586       <span class="keywordflow">if</span> (strcmp(cl-&gt;getAliasName(), cl-&gt;getName()))
<a name="l00587"></a>00587         cl-&gt;setName(cl-&gt;getAliasName());
<a name="l00588"></a>00588     }
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591   <span class="keywordtype">void</span>
<a name="l00592"></a>00592   odl_skip_volatiles(Database *db, Schema *m)
<a name="l00593"></a>00593   {
<a name="l00594"></a>00594     <span class="keywordflow">if</span> (!odlAgregatClass::superclass ||
<a name="l00595"></a>00595         odlAgregatClass::superclass-&gt;getAgregSpec() != odl_RootClass)
<a name="l00596"></a>00596       <span class="keywordflow">return</span>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598     db-&gt;transactionBegin();
<a name="l00599"></a>00599     LinkedListCursor c(m-&gt;getClassList());
<a name="l00600"></a>00600     Class *cl, *toSuppress = 0;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     <span class="keywordtype">char</span> name[64];
<a name="l00603"></a>00603     sprintf(name, <span class="stringliteral">&quot;%s%s&quot;</span>, odl_prefix, get_superclass_name());
<a name="l00604"></a>00604     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)cl))
<a name="l00605"></a>00605       {
<a name="l00606"></a>00606         <span class="keywordflow">if</span> (!strcmp(cl-&gt;getName(), name))
<a name="l00607"></a>00607           toSuppress = cl;
<a name="l00608"></a>00608         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cl-&gt;getParent() &amp;&amp; !strcmp(cl-&gt;getParent()-&gt;getName(), name))
<a name="l00609"></a>00609           ClassPeer::setParent(cl, cl-&gt;getParent()-&gt;getParent());
<a name="l00610"></a>00610       }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="keywordflow">if</span> (toSuppress)
<a name="l00613"></a>00613       m-&gt;suppressClass(toSuppress);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615     rename_classes(m);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     <span class="comment">//  db-&gt;transactionAbort();</span>
<a name="l00618"></a>00618     db-&gt;transactionCommit();
<a name="l00619"></a>00619   }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <span class="keywordtype">int</span> odlDeclaration::check(Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix)
<a name="l00622"></a>00622   {
<a name="l00623"></a>00623     <span class="comment">/*</span>
<a name="l00624"></a>00624 <span class="comment">      Class *cl;</span>
<a name="l00625"></a>00625 <span class="comment">      if (cl = getClass(m, name, prefix))</span>
<a name="l00626"></a>00626 <span class="comment">      {</span>
<a name="l00627"></a>00627 <span class="comment">      if (!cls-&gt;compare(cl))</span>
<a name="l00628"></a>00628 <span class="comment">      odl_add_error(&quot;class &apos;%s&apos; already exists in schema and differs from input class\n&quot;, name);</span>
<a name="l00629"></a>00629 <span class="comment">      return 1;</span>
<a name="l00630"></a>00630 <span class="comment">      }</span>
<a name="l00631"></a>00631 <span class="comment">    */</span>
<a name="l00632"></a>00632 
<a name="l00633"></a>00633     <span class="keywordflow">return</span> 0;
<a name="l00634"></a>00634   }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00637"></a>00637   odl_rename_class(Schema *m, <span class="keyword">const</span> Class *cls, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00638"></a>00638   {
<a name="l00639"></a>00639     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlRenameClass(cls, name));
<a name="l00640"></a>00640   }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00643"></a>00643   odl_migrate_attributes(Schema *m, <span class="keyword">const</span> Class *cls);
<a name="l00644"></a>00644 
<a name="l00645"></a>00645   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00646"></a>00646   odl_remove_class(Database *db, Schema *m, <span class="keyword">const</span> Class *cls);
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <span class="keywordtype">int</span>
<a name="l00649"></a>00649   odlAgregatClass::record(Database *db, Schema *m,
<a name="l00650"></a>00650                           <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix)
<a name="l00651"></a>00651   {
<a name="l00652"></a>00652     <span class="keywordflow">if</span> (parentname) {
<a name="l00653"></a>00653       parent = eyedb::getClass(m, parentname, prefix);
<a name="l00654"></a>00654       <span class="keywordflow">if</span> (!parent)
<a name="l00655"></a>00655         odl_add_error(<span class="stringliteral">&quot;cannot find parent &apos;%s&apos; for agregat_class &apos;%s&apos;\n&quot;</span>,
<a name="l00656"></a>00656                       parentname, name);
<a name="l00657"></a>00657     }
<a name="l00658"></a>00658     <span class="keywordflow">else</span>
<a name="l00659"></a>00659       parent = 0;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     <span class="keywordflow">if</span> (agrspec == odl_Struct || agrspec == odl_SuperClass ||
<a name="l00662"></a>00662         agrspec == odl_RootClass) {
<a name="l00663"></a>00663       cls = <span class="keyword">new</span> StructClass(makeName(name, prefix), parent);
<a name="l00664"></a>00664       cls-&gt;setUserData(odlGENCODE, AnyUserData);
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (agrspec == odl_Declare) {
<a name="l00667"></a>00667       cls = m-&gt;getClass(name);
<a name="l00668"></a>00668       <span class="keywordflow">if</span> (!cls)
<a name="l00669"></a>00669         odl_add_error(<span class="stringliteral">&quot;cannot find declared class &apos;%s&apos;\n&quot;</span>, name);
<a name="l00670"></a>00670       
<a name="l00671"></a>00671       <span class="keywordflow">if</span> (!odl_error)
<a name="l00672"></a>00672         cls = <span class="keyword">new</span> Class(cls-&gt;getName(), cls-&gt;getParent());
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (agrspec == odl_NativeClass) {
<a name="l00675"></a>00675       cls = m-&gt;getClass(name);
<a name="l00676"></a>00676       <span class="keywordflow">if</span> (!cls)
<a name="l00677"></a>00677         odl_add_error(<span class="stringliteral">&quot;cannot find native class &apos;%s&apos;\n&quot;</span>, name);
<a name="l00678"></a>00678       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!cls-&gt;isSystem())
<a name="l00679"></a>00679         odl_add_error(<span class="stringliteral">&quot;class &apos;%s&apos; is not native\n&quot;</span>,
<a name="l00680"></a>00680                       name);
<a name="l00681"></a>00681       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aliasname &amp;&amp; strcmp(aliasname, name))
<a name="l00682"></a>00682         odl_add_error(<span class="stringliteral">&quot;cannot set an alias name on the native&quot;</span>
<a name="l00683"></a>00683                       <span class="stringliteral">&quot; class &apos;%s&apos;\n&quot;</span>, name);
<a name="l00684"></a>00684       <span class="keywordflow">else</span> {
<a name="l00685"></a>00685         <span class="comment">/*</span>
<a name="l00686"></a>00686 <span class="comment">          odlDeclRootLink *l = decl_list-&gt;first;</span>
<a name="l00687"></a>00687 <span class="comment">          while (l) {</span>
<a name="l00688"></a>00688 <span class="comment">          if (!l-&gt;x-&gt;asExecSpec()) {</span>
<a name="l00689"></a>00689 <span class="comment">          odl_add_error(&quot;native class &apos;%s&apos; can include &quot;</span>
<a name="l00690"></a>00690 <span class="comment">          &quot; only methods or triggers.\n&quot;, name);</span>
<a name="l00691"></a>00691 <span class="comment">          break;</span>
<a name="l00692"></a>00692 <span class="comment">          }</span>
<a name="l00693"></a>00693 <span class="comment">          l = l-&gt;next;</span>
<a name="l00694"></a>00694 <span class="comment">          }</span>
<a name="l00695"></a>00695 <span class="comment">        */</span>
<a name="l00696"></a>00696       }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="preprocessor">#if 0</span>
<a name="l00699"></a>00699 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (!odl_error) {
<a name="l00700"></a>00700         printf(<span class="stringliteral">&quot;NATIVE CLASS %s %s -&gt; %p [system=%d] &quot;</span>, cls-&gt;getName(),
<a name="l00701"></a>00701                cls-&gt;isSystem() ? <span class="stringliteral">&quot;system&quot;</span> : <span class="stringliteral">&quot;user&quot;</span>, cls, system);
<a name="l00702"></a>00702       }
<a name="l00703"></a>00703 <span class="preprocessor">#endif</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (!odl_error) {
<a name="l00705"></a>00705         cls = <span class="keyword">new</span> Class(cls-&gt;getName(), cls-&gt;getParent());
<a name="l00706"></a>00706         cls-&gt;setUserData(odlGENCOMP, AnyUserData);
<a name="l00707"></a>00707         ClassPeer::setMType(cls, Class::System);
<a name="l00708"></a>00708         <span class="keywordflow">if</span> (db)
<a name="l00709"></a>00709           cls-&gt;setDatabase(db);
<a name="l00710"></a>00710       }
<a name="l00711"></a>00711     }
<a name="l00712"></a>00712     <span class="keywordflow">else</span> {
<a name="l00713"></a>00713       cls = <span class="keyword">new</span> UnionClass(makeName(name, prefix), parent);
<a name="l00714"></a>00714       cls-&gt;setUserData(odlGENCODE, AnyUserData);
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717     <span class="keywordflow">if</span> (!odl_lang &amp;&amp; upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::RenameFrom)
<a name="l00718"></a>00718       {
<a name="l00719"></a>00719         <span class="keyword">const</span> <span class="keywordtype">char</span> *xname = upd_hints-&gt;detail;
<a name="l00720"></a>00720         ocls = eyedb::getClass(m, xname, prefix);
<a name="l00721"></a>00721         <span class="keywordflow">if</span> (!ocls)
<a name="l00722"></a>00722           odl_add_error(<span class="stringliteral">&quot;class %s: does not exist in database\n&quot;</span>, xname);
<a name="l00723"></a>00723         <span class="keywordflow">else</span>
<a name="l00724"></a>00724           {
<a name="l00725"></a>00725             odl_rename_class(m, cls, xname);
<a name="l00726"></a>00726             ocls-&gt;setName(name);
<a name="l00727"></a>00727           }
<a name="l00728"></a>00728       }
<a name="l00729"></a>00729     <span class="keywordflow">else</span>
<a name="l00730"></a>00730       ocls = eyedb::getClass(m, (aliasname ? aliasname : name), prefix);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732     <span class="keywordflow">if</span> (!odl_lang &amp;&amp; upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::Remove &amp;&amp;
<a name="l00733"></a>00733         !ocls)
<a name="l00734"></a>00734       odl_add_error(<span class="stringliteral">&quot;cannot remove class &apos;%s&apos;\n&quot;</span>, name);
<a name="l00735"></a>00735     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (agrspec != odl_NativeClass &amp;&amp; agrspec != odl_Declare)
<a name="l00736"></a>00736       {
<a name="l00737"></a>00737         <span class="keywordflow">if</span> (aliasname)
<a name="l00738"></a>00738           cls-&gt;setAliasName(aliasname);
<a name="l00739"></a>00739         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (db_prefix)
<a name="l00740"></a>00740           cls-&gt;setAliasName(makeName(name, db_prefix));
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         assert(ocls != cls);
<a name="l00743"></a>00743         <span class="keywordflow">if</span> (ocls &amp;&amp; ocls != cls)
<a name="l00744"></a>00744           {
<a name="l00745"></a>00745             m-&gt;suppressClass(ocls);
<a name="l00746"></a>00746             cls-&gt;setUserData(ocls);
<a name="l00747"></a>00747             cls-&gt;setExtentImplementation(ocls-&gt;getExtentImplementation(),
<a name="l00748"></a>00748                                          True);
<a name="l00749"></a>00749             ObjectPeer::setOid(cls, ocls-&gt;getOid());
<a name="l00750"></a>00750           }
<a name="l00751"></a>00751       
<a name="l00752"></a>00752         <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::Remove)
<a name="l00753"></a>00753           {
<a name="l00754"></a>00754             <span class="keywordflow">if</span> (ocls-&gt;isSystem()) {
<a name="l00755"></a>00755               odl_add_error(<span class="stringliteral">&quot;cannot remove the system class &apos;%s&apos;\n&quot;</span>,
<a name="l00756"></a>00756                             ocls-&gt;getName());
<a name="l00757"></a>00757               <span class="keywordflow">return</span> 1;
<a name="l00758"></a>00758             } <span class="keywordflow">else</span> {
<a name="l00759"></a>00759               odl_remove_class(db, m, cls);
<a name="l00760"></a>00760               cls = 0;
<a name="l00761"></a>00761             }
<a name="l00762"></a>00762           }
<a name="l00763"></a>00763         <span class="keywordflow">else</span>
<a name="l00764"></a>00764           m-&gt;addClass(cls);
<a name="l00765"></a>00765       }
<a name="l00766"></a>00766     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (odl_gencode &amp;&amp; ocls)
<a name="l00767"></a>00767       {
<a name="l00768"></a>00768         m-&gt;suppressClass(ocls);
<a name="l00769"></a>00769         <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::Remove)
<a name="l00770"></a>00770           {
<a name="l00771"></a>00771             <span class="keywordflow">if</span> (ocls-&gt;isSystem()) {
<a name="l00772"></a>00772               odl_add_error(<span class="stringliteral">&quot;cannot remove the system class &apos;%s&apos;\n&quot;</span>,
<a name="l00773"></a>00773                             ocls-&gt;getName());
<a name="l00774"></a>00774               <span class="keywordflow">return</span> 1;
<a name="l00775"></a>00775             } <span class="keywordflow">else</span> {
<a name="l00776"></a>00776               odl_remove_class(db, m, cls);
<a name="l00777"></a>00777               cls = 0;
<a name="l00778"></a>00778             }
<a name="l00779"></a>00779           }
<a name="l00780"></a>00780         <span class="keywordflow">else</span>
<a name="l00781"></a>00781           m-&gt;addClass(cls);
<a name="l00782"></a>00782 
<a name="l00783"></a>00783         <span class="keywordflow">if</span> (!odl_error &amp;&amp; agrspec == odl_NativeClass) {
<a name="l00784"></a>00784           <span class="comment">/*</span>
<a name="l00785"></a>00785 <span class="comment">            printf(&quot;should report attributes from ocls %d to cls %d\n&quot;,</span>
<a name="l00786"></a>00786 <span class="comment">            ocls-&gt;getAttributesCount(), cls-&gt;getAttributesCount());</span>
<a name="l00787"></a>00787 <span class="comment">          */</span>
<a name="l00788"></a>00788           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attr_cnt;
<a name="l00789"></a>00789           <span class="keyword">const</span> Attribute **attrs = ocls-&gt;getAttributes(attr_cnt);
<a name="l00790"></a>00790           Status status = cls-&gt;setAttributes((Attribute **)attrs, attr_cnt);
<a name="l00791"></a>00791           <span class="keywordflow">if</span> (status)
<a name="l00792"></a>00792             odl_add_error(status);
<a name="l00793"></a>00793         }
<a name="l00794"></a>00794       }
<a name="l00795"></a>00795   
<a name="l00796"></a>00796     <span class="keywordflow">if</span> (odl_system_class &amp;&amp; !odl_error)
<a name="l00797"></a>00797       ClassPeer::setMType(cls, Class::System);
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     <span class="keywordflow">if</span> (cls)
<a name="l00800"></a>00800       cls-&gt;setUserData(odlSELF, <span class="keyword">this</span>);
<a name="l00801"></a>00801 
<a name="l00802"></a>00802     <span class="keywordflow">if</span> (cls &amp;&amp; coll_impl_spec) {
<a name="l00803"></a>00803       <span class="comment">// TBD: Index -&gt; Coll</span>
<a name="l00804"></a>00804       odlCollImplSpecItem::Type type;
<a name="l00805"></a>00805       <span class="keywordtype">char</span> *hints;
<a name="l00806"></a>00806       <span class="keywordflow">if</span> (!coll_impl_spec-&gt;make_class_prologue(cls-&gt;getName(), type, hints))
<a name="l00807"></a>00807         <span class="keywordflow">return</span> 1;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809       <span class="keywordflow">if</span> (type != odlCollImplSpecItem::HashIndex &amp;&amp;
<a name="l00810"></a>00810           type != odlCollImplSpecItem::BTreeIndex) {
<a name="l00811"></a>00811         odl_add_error(<span class="stringliteral">&quot;class %s: extent implementation &apos;%s&apos; must be an hashindex or a btreeindex&quot;</span>, cls-&gt;getName());
<a name="l00812"></a>00812         <span class="keywordflow">return</span> 1;
<a name="l00813"></a>00813 
<a name="l00814"></a>00814       }
<a name="l00815"></a>00815       IndexImpl *idximpl;
<a name="l00816"></a>00816       Status s = IndexImpl::make
<a name="l00817"></a>00817         ((db ? db : odl_get_dummy_db(m)),
<a name="l00818"></a>00818          (type == odlCollImplSpecItem::HashIndex ? IndexImpl::Hash :
<a name="l00819"></a>00819           IndexImpl::BTree), hints, idximpl);
<a name="l00820"></a>00820       <span class="keywordflow">if</span> (!s) {
<a name="l00821"></a>00821         <span class="keywordflow">if</span> (cls-&gt;getOid().isValid()) {
<a name="l00822"></a>00822           IndexImpl *oidximpl = cls-&gt;getExtentImplementation();
<a name="l00823"></a>00823           <span class="keywordflow">if</span> (!oidximpl-&gt;compare(idximpl)) {
<a name="l00824"></a>00824             odl_add_error(<span class="stringliteral">&quot;class %s: extent implementation &apos;%s&apos; cannot be &quot;</span>
<a name="l00825"></a>00825                           <span class="stringliteral">&quot;dynamically changed to &apos;%s&apos; using eyedbodl\n&quot;</span>,
<a name="l00826"></a>00826                           cls-&gt;getName(),
<a name="l00827"></a>00827                           oidximpl-&gt;getHintsString().c_str(),
<a name="l00828"></a>00828                           idximpl-&gt;getHintsString().c_str());
<a name="l00829"></a>00829             <span class="keywordflow">return</span> 1;
<a name="l00830"></a>00830           }
<a name="l00831"></a>00831         }
<a name="l00832"></a>00832         <span class="keywordflow">else</span>
<a name="l00833"></a>00833           s = cls-&gt;setExtentImplementation(idximpl);
<a name="l00834"></a>00834       }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836       <span class="keywordflow">if</span> (s) {
<a name="l00837"></a>00837         odl_add_error(s);
<a name="l00838"></a>00838         <span class="keywordflow">return</span> 1;
<a name="l00839"></a>00839       }
<a name="l00840"></a>00840     }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     <span class="keywordflow">return</span> 0;
<a name="l00843"></a>00843   }
<a name="l00844"></a>00844       
<a name="l00845"></a>00845   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00846"></a>00846   array_make(odlDeclItem *item, <span class="keywordtype">int</span>* &amp;dims, <span class="keywordtype">int</span> &amp;ndims)
<a name="l00847"></a>00847   {
<a name="l00848"></a>00848     <span class="keywordflow">if</span> (item-&gt;array_list)
<a name="l00849"></a>00849       {
<a name="l00850"></a>00850         <span class="keywordtype">int</span> count = item-&gt;array_list-&gt;count;
<a name="l00851"></a>00851         odlArrayItemLink *l = item-&gt;array_list-&gt;first;
<a name="l00852"></a>00852         dims = <span class="keyword">new</span> <span class="keywordtype">int</span>[count];
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         <span class="keywordflow">for</span> (ndims = 0; ndims &lt; count; ndims++, l = l-&gt;next)
<a name="l00855"></a>00855           {
<a name="l00856"></a>00856             <span class="keywordtype">int</span> v = l-&gt;x;
<a name="l00857"></a>00857             <span class="keywordflow">if</span> (v&gt;0)
<a name="l00858"></a>00858               dims[ndims] = v;
<a name="l00859"></a>00859             <span class="keywordflow">else</span>
<a name="l00860"></a>00860               dims[ndims] = idbVarDim(-v);
<a name="l00861"></a>00861           }
<a name="l00862"></a>00862       }
<a name="l00863"></a>00863     <span class="keywordflow">else</span>
<a name="l00864"></a>00864       {
<a name="l00865"></a>00865         dims = 0;
<a name="l00866"></a>00866         ndims = 0;
<a name="l00867"></a>00867       }
<a name="l00868"></a>00868   }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00871"></a>00871   sign_error(<span class="keyword">const</span> <span class="keywordtype">char</span> *method_name, <span class="keyword">const</span> Class *cls)
<a name="l00872"></a>00872   {
<a name="l00873"></a>00873     odl_add_error(<span class="stringliteral">&quot;invalid hash method signature &apos;%s&apos; in &quot;</span>
<a name="l00874"></a>00874                   <span class="stringliteral">&quot;class &apos;%s&apos; in index declaration: must be &quot;</span>
<a name="l00875"></a>00875                   <span class="stringliteral">&quot;`classmethod int %s(in rawdata, in int)&apos;.\n&quot;</span>,
<a name="l00876"></a>00876                   method_name, cls-&gt;getName(), method_name);
<a name="l00877"></a>00877   }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879 <span class="preprocessor">#define FIND_IDX_OPTIM</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>
<a name="l00881"></a>00881   Status
<a name="l00882"></a>00882   odlIndex::findIndex(Schema *m, Index *&amp;idx_obj)
<a name="l00883"></a>00883   {
<a name="l00884"></a>00884     <span class="keywordflow">if</span> (!m-&gt;getDatabase())
<a name="l00885"></a>00885       <span class="keywordflow">return</span> Success;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 <span class="preprocessor">#ifdef FIND_IDX_OPTIM</span>
<a name="l00888"></a>00888 <span class="preprocessor"></span>    Status s;
<a name="l00889"></a>00889     <span class="keyword">static</span> ObjectArray *index_arr;
<a name="l00890"></a>00890     <span class="keyword">static</span> <span class="keywordtype">int</span> index_arr_cnt;
<a name="l00891"></a>00891     <span class="keywordflow">if</span> (!index_arr)
<a name="l00892"></a>00892       {
<a name="l00893"></a>00893         index_arr = <span class="keyword">new</span> ObjectArray();
<a name="l00894"></a>00894         OQL q(m-&gt;getDatabase(), <span class="stringliteral">&quot;select index&quot;</span>);
<a name="l00895"></a>00895         s = q.execute(*index_arr);
<a name="l00896"></a>00896         <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l00897"></a>00897         index_arr_cnt = index_arr-&gt;getCount();
<a name="l00898"></a>00898       }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900     <span class="comment">// a hash table should be better!!</span>
<a name="l00901"></a>00901     <span class="keyword">const</span> <span class="keywordtype">char</span> *idxname = idx_obj-&gt;getName().c_str();
<a name="l00902"></a>00902     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; index_arr_cnt; i++)
<a name="l00903"></a>00903       <span class="keywordflow">if</span> (!strcmp(idxname, ((Index *)(*index_arr)[i])-&gt;getName().c_str()))
<a name="l00904"></a>00904         {
<a name="l00905"></a>00905           idx_obj-&gt;release();
<a name="l00906"></a>00906           idx_obj = (Index *)(*index_arr)[i];
<a name="l00907"></a>00907           <span class="keywordflow">return</span> Success;
<a name="l00908"></a>00908         }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <span class="keywordflow">return</span> Success;
<a name="l00911"></a>00911 <span class="preprocessor">#else      </span>
<a name="l00912"></a>00912 <span class="preprocessor"></span>    OQL q(m-&gt;getDatabase(), <span class="stringliteral">&quot;select index.name = \&quot;%s\&quot;&quot;</span>, idx_obj-&gt;getName());
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     Object *o;
<a name="l00915"></a>00915     Bool found;
<a name="l00916"></a>00916     Status s;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918     ObjectArray obj_arr;
<a name="l00919"></a>00919     s = q.execute(obj_arr);
<a name="l00920"></a>00920     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922     <span class="keywordflow">if</span> (obj_arr.getCount())
<a name="l00923"></a>00923       {
<a name="l00924"></a>00924         idx_obj-&gt;release();
<a name="l00925"></a>00925         idx_obj = (Index *)obj_arr[0];
<a name="l00926"></a>00926       }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928     <span class="keywordflow">return</span> Success;
<a name="l00929"></a>00929 <span class="preprocessor">#endif</span>
<a name="l00930"></a>00930 <span class="preprocessor"></span>  }
<a name="l00931"></a>00931 
<a name="l00932"></a>00932   <span class="keyword">static</span> Bool
<a name="l00933"></a>00933   odlIsType(odlDeclItem *item, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l00934"></a>00934   {
<a name="l00935"></a>00935     <span class="keywordflow">if</span> (strcmp(item-&gt;typname, type) || item-&gt;isref ||
<a name="l00936"></a>00936         !item-&gt;array_list || item-&gt;array_list-&gt;count != 1)
<a name="l00937"></a>00937       <span class="keywordflow">return</span> False;
<a name="l00938"></a>00938 
<a name="l00939"></a>00939     <span class="keywordflow">return</span> True;
<a name="l00940"></a>00940   }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="keyword">static</span> Bool
<a name="l00943"></a>00943   odlIsString(odlDeclItem *item)
<a name="l00944"></a>00944   {
<a name="l00945"></a>00945     <span class="keywordflow">return</span> odlIsType(item, char_class_name);
<a name="l00946"></a>00946   }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948   <span class="keyword">static</span> Bool
<a name="l00949"></a>00949   odlIsRawData(odlDeclItem *item)
<a name="l00950"></a>00950   {
<a name="l00951"></a>00951     <span class="keywordflow">return</span> odlIsType(item, <span class="stringliteral">&quot;byte&quot;</span>);
<a name="l00952"></a>00952   }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   <span class="keyword">static</span> Signature *
<a name="l00955"></a>00955   makeSign(Schema *m)
<a name="l00956"></a>00956   {
<a name="l00957"></a>00957     Signature *sign = <span class="keyword">new</span> Signature();
<a name="l00958"></a>00958     ArgType *type;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960 <span class="preprocessor">#ifdef NO_DIRECT_SET</span>
<a name="l00961"></a>00961 <span class="preprocessor"></span>    type = sign-&gt;getRettype();
<a name="l00962"></a>00962     *type = *ArgType::make(m, int32_class_name);
<a name="l00963"></a>00963 <span class="preprocessor">#else</span>
<a name="l00964"></a>00964 <span class="preprocessor"></span>    type = ArgType::make(m, int32_class_name);
<a name="l00965"></a>00965 <span class="preprocessor">#endif</span>
<a name="l00966"></a>00966 <span class="preprocessor"></span>
<a name="l00967"></a>00967     type-&gt;setType((ArgType_Type)(type-&gt;getType() | OUT_ARG_TYPE), False);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969 <span class="preprocessor">#ifndef NO_DIRECT_SET</span>
<a name="l00970"></a>00970 <span class="preprocessor"></span>    sign-&gt;setRettype(type);
<a name="l00971"></a>00971 <span class="preprocessor">#endif</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span>    sign-&gt;setNargs(2);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 <span class="preprocessor">#ifdef NO_DIRECT_SET</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>    sign-&gt;setTypesCount(2);
<a name="l00976"></a>00976     type = sign-&gt;getTypes(0);
<a name="l00977"></a>00977     *type = *ArgType::make(m, <span class="stringliteral">&quot;rawdata&quot;</span>);
<a name="l00978"></a>00978 <span class="preprocessor">#else</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span>    type = ArgType::make(m, <span class="stringliteral">&quot;rawdata&quot;</span>);
<a name="l00980"></a>00980 <span class="preprocessor">#endif</span>
<a name="l00981"></a>00981 <span class="preprocessor"></span>
<a name="l00982"></a>00982     type-&gt;setType((ArgType_Type)(type-&gt;getType() | IN_ARG_TYPE), False);
<a name="l00983"></a>00983 
<a name="l00984"></a>00984 <span class="preprocessor">#ifndef NO_DIRECT_SET</span>
<a name="l00985"></a>00985 <span class="preprocessor"></span>    sign-&gt;setTypes(0, type);
<a name="l00986"></a>00986 <span class="preprocessor">#endif</span>
<a name="l00987"></a>00987 <span class="preprocessor"></span>
<a name="l00988"></a>00988 <span class="preprocessor">#ifdef NO_DIRECT_SET</span>
<a name="l00989"></a>00989 <span class="preprocessor"></span>    sign-&gt;setTypesCount(2);
<a name="l00990"></a>00990     type = sign-&gt;getTypes(1);
<a name="l00991"></a>00991     *type = *ArgType::make(m, int32_class_name);
<a name="l00992"></a>00992 <span class="preprocessor">#else</span>
<a name="l00993"></a>00993 <span class="preprocessor"></span>    type = ArgType::make(m, int32_class_name);
<a name="l00994"></a>00994 <span class="preprocessor">#endif</span>
<a name="l00995"></a>00995 <span class="preprocessor"></span>    type-&gt;setType((ArgType_Type)(type-&gt;getType() | IN_ARG_TYPE), False);
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="preprocessor">#ifndef NO_DIRECT_SET</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span>    sign-&gt;setTypes(1, type);
<a name="l00999"></a>00999 <span class="preprocessor">#endif</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span>
<a name="l01001"></a>01001     <span class="keywordflow">return</span> sign;
<a name="l01002"></a>01002   }
<a name="l01003"></a>01003 
<a name="l01004"></a>01004   <span class="keyword">static</span> Signature *
<a name="l01005"></a>01005   getHashSignature(Schema *m)
<a name="l01006"></a>01006   {
<a name="l01007"></a>01007     <span class="keyword">static</span> Signature *sign;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009     <span class="keywordflow">if</span> (!sign)
<a name="l01010"></a>01010       sign = makeSign(m);
<a name="l01011"></a>01011  
<a name="l01012"></a>01012     <span class="keywordflow">return</span> sign;
<a name="l01013"></a>01013   }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015   odlBool
<a name="l01016"></a>01016   odlDeclItem::hasInverseAttr()<span class="keyword"> const</span>
<a name="l01017"></a>01017 <span class="keyword">  </span>{
<a name="l01018"></a>01018     <span class="keywordflow">return</span> inverse ? odlTrue : odlFalse;
<a name="l01019"></a>01019 <span class="preprocessor">#if 0</span>
<a name="l01020"></a>01020 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!attr_list)
<a name="l01021"></a>01021       <span class="keywordflow">return</span> odlFalse;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     odlAttrItemLink *l = attr_list-&gt;first;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     <span class="keywordflow">while</span> (l)
<a name="l01026"></a>01026       {
<a name="l01027"></a>01027         odlAttrItem *attr = l-&gt;x;
<a name="l01028"></a>01028         <span class="keywordflow">if</span> (attr-&gt;asInverse())
<a name="l01029"></a>01029           <span class="keywordflow">return</span> odlTrue;
<a name="l01030"></a>01030         l = l -&gt;next;
<a name="l01031"></a>01031       }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="keywordflow">return</span> odlFalse;
<a name="l01034"></a>01034 <span class="preprocessor">#endif</span>
<a name="l01035"></a>01035 <span class="preprocessor"></span>  }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 <span class="preprocessor">#if 0</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span>  <span class="keywordtype">void</span>
<a name="l01039"></a>01039   odlDeclItem::attr_list_make(Schema *m, Class *cls,
<a name="l01040"></a>01040                               <span class="keywordtype">int</span>&amp; index_mode, Index *&amp;idx_item,
<a name="l01041"></a>01041                               Index *&amp;idx_comp,
<a name="l01042"></a>01042                               <span class="keywordtype">char</span> **invcname, <span class="keywordtype">char</span> **invfname,
<a name="l01043"></a>01043                               ClassComponent *comp[], <span class="keywordtype">int</span> &amp;comp_cnt)
<a name="l01044"></a>01044   {
<a name="l01045"></a>01045     index_mode = 0;
<a name="l01046"></a>01046     idx_item = idx_comp = 0;
<a name="l01047"></a>01047     *invcname = *invfname = 0;
<a name="l01048"></a>01048   
<a name="l01049"></a>01049     <span class="keywordtype">int</span> ocomp_cnt = comp_cnt;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="keywordflow">if</span> (attr_list)
<a name="l01052"></a>01052       {
<a name="l01053"></a>01053         odlAttrItemLink *l = attr_list-&gt;first;
<a name="l01054"></a>01054 
<a name="l01055"></a>01055         <span class="keywordflow">while</span> (l)
<a name="l01056"></a>01056           {
<a name="l01057"></a>01057             odlAttrItem *attr = l-&gt;x;
<a name="l01058"></a>01058             <span class="keywordflow">if</span> (attr-&gt;asInverse())
<a name="l01059"></a>01059               {
<a name="l01060"></a>01060                 odlInverse *inv = attr-&gt;asInverse();
<a name="l01061"></a>01061                 *invcname = inv-&gt;classname;
<a name="l01062"></a>01062                 *invfname = inv-&gt;attrname;
<a name="l01063"></a>01063               }
<a name="l01064"></a>01064             <span class="keywordflow">if</span> (attr-&gt;asCardinality())
<a name="l01065"></a>01065               {
<a name="l01066"></a>01066                 <span class="keywordflow">if</span> (!coll_spec)
<a name="l01067"></a>01067                   {
<a name="l01068"></a>01068                     odl_add_error(<span class="stringliteral">&quot;cannot set cardinality_constraint on a not collection item &apos;%s&apos;\n&quot;</span>, attrname);
<a name="l01069"></a>01069                   }
<a name="l01070"></a>01070                 <span class="keywordflow">else</span>
<a name="l01071"></a>01071                   {
<a name="l01072"></a>01072                     odlCardinality *card = attr-&gt;asCardinality();
<a name="l01073"></a>01073                     comp[comp_cnt++] =
<a name="l01074"></a>01074                       <span class="keyword">new</span> CardinalityConstraint(0, cls, attrname,
<a name="l01075"></a>01075                                                 card-&gt;bottom, (<span class="keywordtype">int</span>)card-&gt;bottom_excl,
<a name="l01076"></a>01076                                                 card-&gt;top, (<span class="keywordtype">int</span>)card-&gt;top_excl);
<a name="l01077"></a>01077                   }
<a name="l01078"></a>01078               }
<a name="l01079"></a>01079             <span class="comment">/*</span>
<a name="l01080"></a>01080 <span class="comment">              else</span>
<a name="l01081"></a>01081 <span class="comment">              abort();</span>
<a name="l01082"></a>01082 <span class="comment">            */</span>
<a name="l01083"></a>01083 
<a name="l01084"></a>01084             l = l-&gt;next;
<a name="l01085"></a>01085           }
<a name="l01086"></a>01086       }
<a name="l01087"></a>01087   }
<a name="l01088"></a>01088 <span class="preprocessor">#endif</span>
<a name="l01089"></a>01089 <span class="preprocessor"></span>
<a name="l01090"></a>01090   <span class="keyword">static</span> <span class="keywordtype">int</span> key_w(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *key)
<a name="l01091"></a>01091   {
<a name="l01092"></a>01092     <span class="keywordflow">if</span> (!s)
<a name="l01093"></a>01093       <span class="keywordflow">return</span> 0;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     <span class="keywordflow">if</span> (!strcmp(s, key))
<a name="l01096"></a>01096       {
<a name="l01097"></a>01097         odl_add_error(<span class="stringliteral">&quot;use of invalid C++ keyword &apos;%s&apos; for attribute name or type name\n&quot;</span>, s);
<a name="l01098"></a>01098         <span class="keywordflow">return</span> 1;
<a name="l01099"></a>01099       }
<a name="l01100"></a>01100     <span class="keywordflow">return</span> 0;
<a name="l01101"></a>01101   }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103 <span class="preprocessor">#define KEY_W(K) if (key_w(typname, K) || key_w(attrname, K)) return 1</span>
<a name="l01104"></a>01104 <span class="preprocessor"></span>
<a name="l01105"></a>01105   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01106"></a>01106   check_name(Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *classname,
<a name="l01107"></a>01107              <span class="keyword">const</span> <span class="keywordtype">char</span> *typname, <span class="keyword">const</span> <span class="keywordtype">char</span> *attrname,
<a name="l01108"></a>01108              <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix)
<a name="l01109"></a>01109   {
<a name="l01110"></a>01110     KEY_W(<span class="stringliteral">&quot;delete&quot;</span>);
<a name="l01111"></a>01111     KEY_W(<span class="stringliteral">&quot;operator&quot;</span>);
<a name="l01112"></a>01112 
<a name="l01113"></a>01113     <span class="keywordflow">if</span> (getClass(m, attrname, prefix))
<a name="l01114"></a>01114       {
<a name="l01115"></a>01115         <span class="comment">// why??</span>
<a name="l01116"></a>01116         <span class="comment">// because may be ambiguous in uses such as OQL, C++ or Java</span>
<a name="l01117"></a>01117         odl_add_error(<span class="stringliteral">&quot;cannot use a type name for an attribute name: &apos;%s %s&apos; in class &apos;%s&apos;\n&quot;</span>, (typname ? typname : <span class="stringliteral">&quot;identifier&quot;</span>), attrname, classname);
<a name="l01118"></a>01118         <span class="keywordflow">return</span> 1;
<a name="l01119"></a>01119       }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121     <span class="keyword">const</span> LinkedList *_class = m-&gt;getClassList();
<a name="l01122"></a>01122     LinkedListCursor *c = _class-&gt;startScan();
<a name="l01123"></a>01123 
<a name="l01124"></a>01124     Class *cl;
<a name="l01125"></a>01125 
<a name="l01126"></a>01126     <span class="keywordtype">char</span> tmp[128];
<a name="l01127"></a>01127     sprintf(tmp, <span class="stringliteral">&quot;%s%s&quot;</span>, prefix, classname);
<a name="l01128"></a>01128     <span class="keywordflow">while</span> (_class-&gt;getNextObject(c, (<span class="keywordtype">void</span> *&amp;)cl))
<a name="l01129"></a>01129       <span class="keywordflow">if</span> (cl-&gt;asEnumClass())
<a name="l01130"></a>01130         {
<a name="l01131"></a>01131           <span class="keywordflow">if</span> (!strcmp(cl-&gt;getName(), tmp))
<a name="l01132"></a>01132             <span class="keywordflow">continue</span>;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134           <span class="keywordtype">int</span> count;
<a name="l01135"></a>01135           <span class="keyword">const</span> EnumItem **items = cl-&gt;asEnumClass()-&gt;getEnumItems(count);
<a name="l01136"></a>01136           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; i++)
<a name="l01137"></a>01137             <span class="keywordflow">if</span> (!strcmp(attrname, items[i]-&gt;getName()))
<a name="l01138"></a>01138               {
<a name="l01139"></a>01139                 <span class="keywordflow">if</span> (!typname)
<a name="l01140"></a>01140                   odl_add_error(<span class="stringliteral">&quot;enum item name &apos;%s&apos; found in &apos;%s&apos; and &apos;%s&apos;\n&quot;</span>,
<a name="l01141"></a>01141                                 attrname, cl-&gt;getName(), tmp);
<a name="l01142"></a>01142                 <span class="keywordflow">else</span>
<a name="l01143"></a>01143                   odl_add_error(<span class="stringliteral">&quot;cannot use a enum item name for &quot;</span>
<a name="l01144"></a>01144                                 <span class="stringliteral">&quot;an attribute name: &apos;%s&apos;\n&quot;</span>, attrname);
<a name="l01145"></a>01145                 _class-&gt;endScan(c);
<a name="l01146"></a>01146                 <span class="keywordflow">return</span> 1;
<a name="l01147"></a>01147               }
<a name="l01148"></a>01148         }
<a name="l01149"></a>01149 
<a name="l01150"></a>01150     _class-&gt;endScan(c);
<a name="l01151"></a>01151   
<a name="l01152"></a>01152     <span class="keywordflow">return</span> 0;
<a name="l01153"></a>01153   }
<a name="l01154"></a>01154 
<a name="l01155"></a>01155   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01156"></a>01156   add_quoted_seq(Class *cls, <span class="keyword">const</span> <span class="keywordtype">char</span> *quoted_seq)
<a name="l01157"></a>01157   {
<a name="l01158"></a>01158     <span class="keywordtype">char</span> *tied_code = cls-&gt;getTiedCode();
<a name="l01159"></a>01159     <span class="keywordtype">int</span> len = strlen(quoted_seq)+1;
<a name="l01160"></a>01160 
<a name="l01161"></a>01161     <span class="keywordflow">if</span> (!tied_code)
<a name="l01162"></a>01162       tied_code = (<span class="keywordtype">char</span> *)calloc(len, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01163"></a>01163     <span class="keywordflow">else</span>
<a name="l01164"></a>01164       tied_code = (<span class="keywordtype">char</span> *)realloc(tied_code, len+strlen(tied_code));
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     strcat(tied_code, quoted_seq);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168     cls-&gt;setTiedCode(tied_code);
<a name="l01169"></a>01169   }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171 
<a name="l01172"></a>01172   <span class="keyword">struct </span>ClassNotFound {
<a name="l01173"></a>01173 
<a name="l01174"></a>01174     <span class="keyword">static</span> LinkedList list;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176     <span class="keyword">static</span> Bool <span class="keyword">get</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l01177"></a>01177       LinkedListCursor c(list);
<a name="l01178"></a>01178       <span class="keywordtype">char</span> *s;
<a name="l01179"></a>01179 
<a name="l01180"></a>01180       <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)s))
<a name="l01181"></a>01181         <span class="keywordflow">if</span> (!strcmp(s, name))
<a name="l01182"></a>01182           <span class="keywordflow">return</span> True;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184       <span class="keywordflow">return</span> False;
<a name="l01185"></a>01185     }
<a name="l01186"></a>01186 
<a name="l01187"></a>01187     <span class="keyword">static</span> <span class="keywordtype">void</span> error(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix = 0) {
<a name="l01188"></a>01188       <span class="keywordtype">char</span> *x = strdup(name);
<a name="l01189"></a>01189       <span class="keywordflow">if</span> (x[strlen(x)-1] == <span class="charliteral">&apos;*&apos;</span>)
<a name="l01190"></a>01190         x[strlen(x)-1] = 0;
<a name="l01191"></a>01191 
<a name="l01192"></a>01192       <span class="keywordflow">if</span> (<span class="keyword">get</span>(x))
<a name="l01193"></a>01193         {
<a name="l01194"></a>01194           free(x);
<a name="l01195"></a>01195           <span class="keywordflow">return</span>;
<a name="l01196"></a>01196         }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198       <span class="keywordflow">if</span> (prefix) {
<a name="l01199"></a>01199         std::string str = std::string(prefix) + <span class="stringliteral">&quot; : cannot find class &apos;%s&apos;\n&quot;</span>;
<a name="l01200"></a>01200         odl_add_error(str.c_str(), x);
<a name="l01201"></a>01201       }
<a name="l01202"></a>01202       <span class="keywordflow">else</span>
<a name="l01203"></a>01203         odl_add_error(<span class="stringliteral">&quot;cannot find class &apos;%s&apos;\n&quot;</span>, x);
<a name="l01204"></a>01204       put(x);
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     <span class="keyword">static</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l01208"></a>01208       list.insertObjectLast((<span class="keywordtype">void</span> *)name);
<a name="l01209"></a>01209     }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211   };
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   LinkedList ClassNotFound::list;
<a name="l01214"></a>01214 
<a name="l01215"></a>01215   <span class="comment">// debug function</span>
<a name="l01216"></a>01216   std::string
<a name="l01217"></a>01217   odlCollSpecToString(odlCollSpec *coll_spec)
<a name="l01218"></a>01218   {
<a name="l01219"></a>01219 <span class="preprocessor">#define STR(X) ((X) ? (X) : &quot;&lt;null&gt;&quot;)</span>
<a name="l01220"></a>01220 <span class="preprocessor"></span>    std::string s = <span class="stringliteral">&quot;collname=&quot;</span>;
<a name="l01221"></a>01221     s += STR(coll_spec-&gt;collname);
<a name="l01222"></a>01222     s += <span class="stringliteral">&quot; typename=&quot;</span>;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     <span class="keywordflow">if</span> (coll_spec-&gt;typname)
<a name="l01225"></a>01225       s += coll_spec-&gt;typname;
<a name="l01226"></a>01226     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (coll_spec-&gt;coll_spec)
<a name="l01227"></a>01227       s += std::string(<span class="stringliteral">&quot;{&quot;</span>) + odlCollSpecToString(coll_spec-&gt;coll_spec) + <span class="stringliteral">&quot;}&quot;</span>;
<a name="l01228"></a>01228     <span class="keywordflow">else</span>
<a name="l01229"></a>01229       s += <span class="stringliteral">&quot;&lt;null&gt;&quot;</span>;
<a name="l01230"></a>01230 
<a name="l01231"></a>01231     s += <span class="stringliteral">&quot; isref=&quot;</span>;
<a name="l01232"></a>01232     s += str_convert((<span class="keywordtype">long</span>)coll_spec-&gt;isref);
<a name="l01233"></a>01233     s += <span class="stringliteral">&quot; dim=&quot;</span>;
<a name="l01234"></a>01234     s += str_convert((<span class="keywordtype">long</span>)coll_spec-&gt;dim);
<a name="l01235"></a>01235     <span class="keywordflow">return</span> s;
<a name="l01236"></a>01236   }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   AttributeComponent *
<a name="l01239"></a>01239   odlAttrComponent::make(Database *db, Schema *m, Class *cls,
<a name="l01240"></a>01240                          <span class="keyword">const</span> Attribute *&amp;attr)
<a name="l01241"></a>01241   {
<a name="l01242"></a>01242     <span class="keywordflow">if</span> (isCloned) {
<a name="l01243"></a>01243       <span class="comment">//printf(&quot;component %p is cloned\n&quot;, this);</span>
<a name="l01244"></a>01244       <span class="keywordflow">return</span> 0;
<a name="l01245"></a>01245     }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247     std::string sattrpath;
<a name="l01248"></a>01248     <span class="keyword">const</span> <span class="keywordtype">char</span> *clsname = cls-&gt;getAliasName();
<a name="l01249"></a>01249     <span class="keywordtype">int</span> len = strlen(clsname);
<a name="l01250"></a>01250     std::string s = std::string(clsname) + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l01251"></a>01251     <span class="keyword">const</span> <span class="keywordtype">char</span> *p = strchr(attrpath, <span class="charliteral">&apos;:&apos;</span>);
<a name="l01252"></a>01252     <span class="keywordflow">if</span> (p) {
<a name="l01253"></a>01253       <span class="keywordflow">if</span> (strncmp(attrpath, clsname, p - attrpath)) {
<a name="l01254"></a>01254         odl_add_error(<span class="stringliteral">&quot;invalid syntax &apos;%s&apos; for attribute path: class name &quot;</span>
<a name="l01255"></a>01255                       <span class="stringliteral">&quot;expected before scope operator\n&quot;</span>,
<a name="l01256"></a>01256                       attrpath);
<a name="l01257"></a>01257         <span class="keywordflow">return</span> 0;
<a name="l01258"></a>01258       }
<a name="l01259"></a>01259       sattrpath = s + std::string(p + 2);
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(attrpath, s.c_str(), len + 1))
<a name="l01262"></a>01262       sattrpath = attrpath;
<a name="l01263"></a>01263     <span class="keywordflow">else</span>
<a name="l01264"></a>01264       sattrpath = s + attrpath;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <span class="keyword">const</span> Class *xcls;
<a name="l01267"></a>01267     Status st = <a class="code" href="classeyedb_1_1Attribute.html#af3317534f1a896683a8400a80360dd21" title="Not yet documented.">Attribute::checkAttrPath</a>(m, xcls, attr, sattrpath.c_str());
<a name="l01268"></a>01268     <span class="keywordflow">if</span> (st) {
<a name="l01269"></a>01269       odl_add_error(st);
<a name="l01270"></a>01270       <span class="keywordflow">return</span> 0;
<a name="l01271"></a>01271     }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     free(attrpath);
<a name="l01274"></a>01274     attrpath = strdup(sattrpath.c_str());
<a name="l01275"></a>01275     <span class="keywordflow">return</span> make_realize(db, m, const_cast&lt;Class *&gt;(cls), attr);
<a name="l01276"></a>01276   }
<a name="l01277"></a>01277 
<a name="l01278"></a>01278   <span class="keyword">static</span> odlBool
<a name="l01279"></a>01279   is_update_attribute(odlUpdateItem *ci, <span class="keyword">const</span> Attribute *attr)
<a name="l01280"></a>01280   {
<a name="l01281"></a>01281     <span class="keywordflow">if</span> (!ci-&gt;asUpdateAttribute())
<a name="l01282"></a>01282       <span class="keywordflow">return</span> odlFalse;
<a name="l01283"></a>01283 
<a name="l01284"></a>01284     <span class="keyword">const</span> Attribute *cattr = ci-&gt;asUpdateAttribute()-&gt;item;
<a name="l01285"></a>01285     <span class="keywordflow">if</span> (cattr-&gt;getClassOwner() == attr-&gt;getClassOwner()) { <span class="comment">// reconnected the 27/05/02</span>
<a name="l01286"></a>01286       <span class="keywordflow">return</span> odlTrue;
<a name="l01287"></a>01287     }
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     <span class="comment">/*</span>
<a name="l01290"></a>01290 <span class="comment">      if (cattr == attr)</span>
<a name="l01291"></a>01291 <span class="comment">      return odlTrue;</span>
<a name="l01292"></a>01292 <span class="comment">    */</span>
<a name="l01293"></a>01293 
<a name="l01294"></a>01294 
<a name="l01295"></a>01295     <span class="comment">/*</span>
<a name="l01296"></a>01296 <span class="comment">      if (attr-&gt;getClassOwner() == cattr-&gt;getClassOwner()) {</span>
<a name="l01297"></a>01297 <span class="comment">      printf(&quot;update attribute %s returns TRUE becaus of %s\n&quot;, attr-&gt;getName(),</span>
<a name="l01298"></a>01298 <span class="comment">      attr-&gt;getClassOwner()-&gt;getName());</span>
<a name="l01299"></a>01299 <span class="comment">      return odlTrue;</span>
<a name="l01300"></a>01300 <span class="comment">      }</span>
<a name="l01301"></a>01301 <span class="comment">    */</span>
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     <span class="keywordflow">return</span> odlFalse;
<a name="l01304"></a>01304   }
<a name="l01305"></a>01305 
<a name="l01306"></a>01306   <span class="keyword">static</span> odlBool
<a name="l01307"></a>01307   is_remove_attribute(odlUpdateItem *ci, <span class="keyword">const</span> Attribute *attr)
<a name="l01308"></a>01308   {
<a name="l01309"></a>01309     <span class="keywordflow">return</span> ci-&gt;asRemoveAttribute() &amp;&amp;
<a name="l01310"></a>01310       ci-&gt;asRemoveAttribute()-&gt;item == attr ? odlTrue : odlFalse;
<a name="l01311"></a>01311   }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   <span class="comment">//static Bool is_pred_bypass = IDBBOOL(getenv(&quot;IS_PRED_BYPASS&quot;));</span>
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   <span class="keyword">static</span> <span class="keyword">const</span> Attribute *
<a name="l01316"></a>01316   odl_is_pred_attribute(Schema *m, <span class="keyword">const</span> Attribute *attr,
<a name="l01317"></a>01317                         odlBool (*pred)(odlUpdateItem *,
<a name="l01318"></a>01318                                         <span class="keyword">const</span> Attribute *),
<a name="l01319"></a>01319                         <span class="keyword">const</span> <span class="keywordtype">char</span> *predname)
<a name="l01320"></a>01320   {
<a name="l01321"></a>01321     LinkedListCursor c(odlUPDLIST(m));
<a name="l01322"></a>01322     odlUpdateItem *ci;
<a name="l01323"></a>01323 
<a name="l01324"></a>01324     <span class="comment">//printf(&quot;XCOMP: is_%s_attribute -&gt; %s\n&quot;, predname, attr-&gt;getName());</span>
<a name="l01325"></a>01325     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci)) {
<a name="l01326"></a>01326       <span class="keywordflow">if</span> (pred(ci, attr))
<a name="l01327"></a>01327         <span class="keywordflow">return</span> attr;
<a name="l01328"></a>01328 
<a name="l01329"></a>01329       <span class="comment">//if (is_pred_bypass) return 0;</span>
<a name="l01330"></a>01330 
<a name="l01331"></a>01331       <span class="keywordflow">if</span> (!attr-&gt;isIndirect() &amp;&amp; attr-&gt;getClass()-&gt;asAgregatClass()) {
<a name="l01332"></a>01332         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attr_cnt;
<a name="l01333"></a>01333         <span class="keyword">const</span> Attribute **attrs = attr-&gt;getClass()-&gt;getAttributes(attr_cnt);
<a name="l01334"></a>01334         <span class="comment">/*</span>
<a name="l01335"></a>01335 <span class="comment">          printf(&quot;XCOMP: is_%s_attribute recursion in %s\n&quot;, predname,</span>
<a name="l01336"></a>01336 <span class="comment">          attr-&gt;getClass()-&gt;getName());</span>
<a name="l01337"></a>01337 <span class="comment">        */</span>
<a name="l01338"></a>01338         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; attr_cnt; i++) {
<a name="l01339"></a>01339           <span class="keywordflow">if</span> (!attrs[i]-&gt;isNative() &amp;&amp;
<a name="l01340"></a>01340               odl_is_pred_attribute(m, attrs[i], pred, predname))
<a name="l01341"></a>01341             <span class="keywordflow">return</span> attrs[i];
<a name="l01342"></a>01342         }
<a name="l01343"></a>01343       }
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345   
<a name="l01346"></a>01346     <span class="keywordflow">return</span> 0;
<a name="l01347"></a>01347   }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349   <span class="keyword">static</span> <span class="keyword">const</span> Attribute *
<a name="l01350"></a>01350   odl_is_update_attribute(Schema *m, <span class="keyword">const</span> Attribute *attr)
<a name="l01351"></a>01351   {
<a name="l01352"></a>01352     <span class="keywordflow">return</span> odl_is_pred_attribute(m, attr, is_update_attribute, <span class="stringliteral">&quot;update&quot;</span>);
<a name="l01353"></a>01353   }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355   <span class="keyword">static</span> <span class="keyword">const</span> Attribute *
<a name="l01356"></a>01356   odl_is_remove_attribute(Schema *m, <span class="keyword">const</span> Attribute *attr)
<a name="l01357"></a>01357   {
<a name="l01358"></a>01358     <span class="keywordflow">return</span> odl_is_pred_attribute(m, attr, is_remove_attribute, <span class="stringliteral">&quot;remove&quot;</span>);
<a name="l01359"></a>01359   }
<a name="l01360"></a>01360 
<a name="l01361"></a>01361   <span class="keywordtype">void</span> odlAgregatClass::realize(Database *db, odlAttrComponent *odl_comp,
<a name="l01362"></a>01362                                 Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix)
<a name="l01363"></a>01363   {
<a name="l01364"></a>01364     <span class="keywordflow">if</span> (!cls) {
<a name="l01365"></a>01365       odl_add_error(std::string(<span class="stringliteral">&quot;class &quot;</span>) + ocls-&gt;getName() + <span class="stringliteral">&quot; is removed : &quot;</span>
<a name="l01366"></a>01366                     <span class="stringliteral">&quot;cannot add components&quot;</span>);
<a name="l01367"></a>01367       return ;
<a name="l01368"></a>01368     }
<a name="l01369"></a>01369 
<a name="l01370"></a>01370     <span class="keyword">const</span> Attribute *attr;
<a name="l01371"></a>01371     AttributeComponent *attr_comp = odl_comp-&gt;make
<a name="l01372"></a>01372       (db, m, const_cast&lt;Class *&gt;(cls), attr);
<a name="l01373"></a>01373     <span class="comment">/*</span>
<a name="l01374"></a>01374 <span class="comment">      printf(&quot;realize::AttrComponent %p &apos;%s&apos; %s attr_comp=%p\n&quot;,</span>
<a name="l01375"></a>01375 <span class="comment">      odl_comp, odl_comp-&gt;attrpath, cls-&gt;getName(), attr_comp);</span>
<a name="l01376"></a>01376 <span class="comment">    */</span>
<a name="l01377"></a>01377 
<a name="l01378"></a>01378     <span class="keywordflow">if</span> (attr_comp) {
<a name="l01379"></a>01379       <span class="keywordflow">if</span> (db &amp;&amp; db-&gt;isOpened() &amp;&amp; ocls) {
<a name="l01380"></a>01380         <span class="keyword">const</span> LinkedList *dlist;
<a name="l01381"></a>01381         <span class="comment">// to force attrcomplist loading</span>
<a name="l01382"></a>01382         Status s = <span class="keyword">const_cast&lt;</span>Class *<span class="keyword">&gt;</span>(ocls)-&gt;getAttrCompList(dlist);
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         <span class="keywordflow">if</span> (s) {
<a name="l01385"></a>01385           odl_add_error(s);
<a name="l01386"></a>01386           <span class="keywordflow">return</span>;
<a name="l01387"></a>01387         }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389         AttributeComponent *oattr_comp = 0;
<a name="l01390"></a>01390         s = ocls-&gt;getAttrComp(attr_comp-&gt;getName().c_str(), oattr_comp);
<a name="l01391"></a>01391 
<a name="l01392"></a>01392         <span class="keywordflow">if</span> (s) {
<a name="l01393"></a>01393           odl_add_error(s);
<a name="l01394"></a>01394           <span class="keywordflow">return</span>;
<a name="l01395"></a>01395         }
<a name="l01396"></a>01396 
<a name="l01397"></a>01397         <span class="keywordflow">if</span> (oattr_comp) {
<a name="l01398"></a>01398           <span class="keywordflow">if</span> (!attr_comp-&gt;getClass()-&gt;compare(oattr_comp-&gt;getClass())) {
<a name="l01399"></a>01399             <span class="keywordflow">if</span> (attr_comp-&gt;asIndex()) {
<a name="l01400"></a>01400               <span class="keywordflow">if</span> (odl_update_index)
<a name="l01401"></a>01401                 odl_add_error(<span class="stringliteral">&quot;index on %s has not the same implementation type &quot;</span>
<a name="l01402"></a>01402                               <span class="stringliteral">&quot;in database : use idxupdate to change manually &quot;</span>
<a name="l01403"></a>01403                               <span class="stringliteral">&quot;its implementation type\n&quot;</span>,
<a name="l01404"></a>01404                               attr_comp-&gt;getAttrpath().c_str());
<a name="l01405"></a>01405             }
<a name="l01406"></a>01406             <span class="keywordflow">else</span>
<a name="l01407"></a>01407               odl_add_error(<span class="stringliteral">&quot;internal error in &quot;</span>
<a name="l01408"></a>01408                             <span class="stringliteral">&quot;attribute component management\n&quot;</span>);
<a name="l01409"></a>01409             <span class="keywordflow">return</span>;
<a name="l01410"></a>01410           }
<a name="l01411"></a>01411 
<a name="l01412"></a>01412           ObjectPeer::setOid(attr_comp, oattr_comp-&gt;getOid());
<a name="l01413"></a>01413         }
<a name="l01414"></a>01414       }
<a name="l01415"></a>01415 
<a name="l01416"></a>01416       cls-&gt;add(attr_comp-&gt;getInd(), attr_comp);
<a name="l01417"></a>01417     }
<a name="l01418"></a>01418   }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="keywordtype">int</span> odlCollImplSpec::make_class_prologue(<span class="keyword">const</span> <span class="keywordtype">char</span> *clsname,
<a name="l01421"></a>01421                                            odlCollImplSpecItem::Type &amp;type,
<a name="l01422"></a>01422                                            <span class="keywordtype">char</span> *&amp;hints)<span class="keyword"> const</span>
<a name="l01423"></a>01423 <span class="keyword">  </span>{
<a name="l01424"></a>01424     <span class="keywordflow">return</span> make_prologue(True, clsname, type, hints, 0);
<a name="l01425"></a>01425   }
<a name="l01426"></a>01426 
<a name="l01427"></a>01427   <span class="keywordtype">int</span> odlCollImplSpec::make_attr_prologue(<span class="keyword">const</span> <span class="keywordtype">char</span> *attrpath,
<a name="l01428"></a>01428                                           odlCollImplSpecItem::Type &amp;type,
<a name="l01429"></a>01429                                           <span class="keywordtype">char</span> *&amp;hints, <span class="keyword">const</span> Attribute *attr)<span class="keyword"> const </span>{
<a name="l01430"></a>01430     <span class="keywordflow">return</span> make_prologue(False, attrpath, type, hints, attr);
<a name="l01431"></a>01431   }
<a name="l01432"></a>01432 
<a name="l01433"></a>01433   <span class="keywordtype">int</span> odlCollImplSpec::make_prologue(Bool isclass, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l01434"></a>01434                                      odlCollImplSpecItem::Type &amp;type,
<a name="l01435"></a>01435                                      <span class="keywordtype">char</span> *&amp;hints, <span class="keyword">const</span> Attribute *attr)<span class="keyword"> const </span>{
<a name="l01436"></a>01436     odlCollImplSpecItem::Type undefType = odlCollImplSpecItem::UndefType;
<a name="l01437"></a>01437 
<a name="l01438"></a>01438     type = undefType;
<a name="l01439"></a>01439     hints = 0;
<a name="l01440"></a>01440 
<a name="l01441"></a>01441     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; item_cnt; i++) {
<a name="l01442"></a>01442       odlCollImplSpecItem *item = &amp;items[i];
<a name="l01443"></a>01443       <span class="keywordflow">if</span> (item-&gt;type != undefType) {
<a name="l01444"></a>01444         <span class="keywordflow">if</span> (type != undefType) {
<a name="l01445"></a>01445           <span class="keywordflow">if</span> (isclass)
<a name="l01446"></a>01446             odl_add_error(<span class="stringliteral">&quot;class implementation&apos;%s&apos;: collection type is &quot;</span>
<a name="l01447"></a>01447                           <span class="stringliteral">&quot;defined twice&quot;</span>, name);
<a name="l01448"></a>01448           <span class="keywordflow">else</span>
<a name="l01449"></a>01449             odl_add_error(<span class="stringliteral">&quot;attribute &apos;%s&apos;: collection type is defined twice&quot;</span>,
<a name="l01450"></a>01450                           name);
<a name="l01451"></a>01451           <span class="keywordflow">return</span> 0;
<a name="l01452"></a>01452         }
<a name="l01453"></a>01453         type = item-&gt;type;
<a name="l01454"></a>01454       }
<a name="l01455"></a>01455       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (item-&gt;hints) {
<a name="l01456"></a>01456         <span class="keywordflow">if</span> (hints) {
<a name="l01457"></a>01457           <span class="keywordflow">if</span> (isclass)
<a name="l01458"></a>01458             odl_add_error(<span class="stringliteral">&quot;class implementation &apos;%s&apos;: collection hints are &quot;</span>
<a name="l01459"></a>01459                           <span class="stringliteral">&quot;defined twice&quot;</span>, name);
<a name="l01460"></a>01460           <span class="keywordflow">else</span>
<a name="l01461"></a>01461             odl_add_error(<span class="stringliteral">&quot;attribute &apos;%s&apos;: collection hints are defined twice&quot;</span>,
<a name="l01462"></a>01462                           name);
<a name="l01463"></a>01463           <span class="keywordflow">return</span> 0;
<a name="l01464"></a>01464         }
<a name="l01465"></a>01465         hints = item-&gt;hints;
<a name="l01466"></a>01466       }
<a name="l01467"></a>01467     }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     <span class="keywordflow">if</span> (type == undefType) {
<a name="l01470"></a>01470       <span class="keywordflow">if</span> (isclass) {
<a name="l01471"></a>01471         type = odlCollImplSpecItem::HashIndex;
<a name="l01472"></a>01472       }
<a name="l01473"></a>01473       <span class="keywordflow">else</span> {
<a name="l01474"></a>01474         type = odlCollImplSpecItem::NoIndex;
<a name="l01475"></a>01475       }
<a name="l01476"></a>01476       <span class="comment">/*</span>
<a name="l01477"></a>01477 <span class="comment">      else if (attr &amp;&amp;</span>
<a name="l01478"></a>01478 <span class="comment">               (attr-&gt;isString() || attr-&gt;isIndirect() ||</span>
<a name="l01479"></a>01479 <span class="comment">                attr-&gt;getClass()-&gt;asCollectionClass())) // what about enums</span>
<a name="l01480"></a>01480 <span class="comment">        type = odlCollImplSpecItem::HashIndex;</span>
<a name="l01481"></a>01481 <span class="comment">      else</span>
<a name="l01482"></a>01482 <span class="comment">        type = odlCollImplSpecItem::BTreeIndex;</span>
<a name="l01483"></a>01483 <span class="comment">      */</span>
<a name="l01484"></a>01484     }
<a name="l01485"></a>01485 
<a name="l01486"></a>01486     <span class="keywordflow">return</span> 1;
<a name="l01487"></a>01487   }
<a name="l01488"></a>01488 
<a name="l01489"></a>01489   <span class="keywordtype">int</span>
<a name="l01490"></a>01490   odlIndexImplSpec::make_prologue(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l01491"></a>01491                                   odlIndexImplSpecItem::Type &amp;type,
<a name="l01492"></a>01492                                   <span class="keywordtype">char</span> *&amp;hints, 
<a name="l01493"></a>01493                                   <span class="keyword">const</span> Attribute *attr)<span class="keyword"> const</span>
<a name="l01494"></a>01494 <span class="keyword">  </span>{
<a name="l01495"></a>01495     odlIndexImplSpecItem::Type undefType = odlIndexImplSpecItem::UndefType;
<a name="l01496"></a>01496 
<a name="l01497"></a>01497     type = undefType;
<a name="l01498"></a>01498     hints = 0;
<a name="l01499"></a>01499 
<a name="l01500"></a>01500     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; item_cnt; i++) {
<a name="l01501"></a>01501       odlIndexImplSpecItem *item = &amp;items[i];
<a name="l01502"></a>01502       <span class="keywordflow">if</span> (item-&gt;type != undefType) {
<a name="l01503"></a>01503         <span class="keywordflow">if</span> (type != undefType) {
<a name="l01504"></a>01504           odl_add_error(<span class="stringliteral">&quot;attribute &apos;%s&apos;: index type is defined twice&quot;</span>,
<a name="l01505"></a>01505                         name);
<a name="l01506"></a>01506           <span class="keywordflow">return</span> 0;
<a name="l01507"></a>01507         }
<a name="l01508"></a>01508         type = item-&gt;type;
<a name="l01509"></a>01509       }
<a name="l01510"></a>01510       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (item-&gt;hints) {
<a name="l01511"></a>01511         <span class="keywordflow">if</span> (hints) {
<a name="l01512"></a>01512           odl_add_error(<span class="stringliteral">&quot;attribute &apos;%s&apos;: index hints are defined twice&quot;</span>, name);
<a name="l01513"></a>01513           <span class="keywordflow">return</span> 0;
<a name="l01514"></a>01514         }
<a name="l01515"></a>01515         hints = item-&gt;hints;
<a name="l01516"></a>01516       }
<a name="l01517"></a>01517     }
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     <span class="keywordflow">if</span> (type == undefType) {
<a name="l01520"></a>01520       <span class="keywordflow">if</span> (attr &amp;&amp; (attr-&gt;isString() || attr-&gt;isIndirect() ||
<a name="l01521"></a>01521                    attr-&gt;getClass()-&gt;asCollectionClass())) <span class="comment">// what about enums</span>
<a name="l01522"></a>01522         type = odlIndexImplSpecItem::Hash;
<a name="l01523"></a>01523       <span class="keywordflow">else</span>
<a name="l01524"></a>01524         type = odlIndexImplSpecItem::BTree;
<a name="l01525"></a>01525     }
<a name="l01526"></a>01526 
<a name="l01527"></a>01527     <span class="keywordflow">return</span> 1;
<a name="l01528"></a>01528   }
<a name="l01529"></a>01529 
<a name="l01530"></a>01530   odlBool
<a name="l01531"></a>01531   odlAttrComponent::similar(odlAttrComponent *comp,
<a name="l01532"></a>01532                             <span class="keyword">const</span> Class *cls1, <span class="keyword">const</span> Class *cls2)
<a name="l01533"></a>01533   {
<a name="l01534"></a>01534     <span class="comment">/*</span>
<a name="l01535"></a>01535 <span class="comment">      printf(&quot;MUST CHECK BETTER %s %s/%s %s\n&quot;,</span>
<a name="l01536"></a>01536 <span class="comment">      cls1-&gt;getName(), attrpath, cls2-&gt;getName(), comp-&gt;attrpath);</span>
<a name="l01537"></a>01537 <span class="comment">    */</span>
<a name="l01538"></a>01538 
<a name="l01539"></a>01539     <span class="keywordflow">if</span> (!strcmp(comp-&gt;attrpath, attrpath))
<a name="l01540"></a>01540       <span class="keywordflow">return</span> odlTrue;
<a name="l01541"></a>01541 
<a name="l01542"></a>01542     std::string s1 = std::string(cls1-&gt;getName()) + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l01543"></a>01543     std::string s2 = std::string(cls2-&gt;getName()) + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l01544"></a>01544     <span class="keywordtype">int</span> len1 = strlen(s1.c_str());
<a name="l01545"></a>01545     <span class="keywordtype">int</span> len2 = strlen(s2.c_str());
<a name="l01546"></a>01546     <span class="keywordflow">if</span> (!strncmp(attrpath, s1.c_str(), len1)) {
<a name="l01547"></a>01547       <span class="keywordflow">if</span> (!strncmp(comp-&gt;attrpath, s2.c_str(), len2)) {
<a name="l01548"></a>01548         <span class="keywordflow">return</span> !strcmp(&amp;attrpath[len1], &amp;comp-&gt;attrpath[len2]) ?
<a name="l01549"></a>01549           odlTrue : odlFalse;
<a name="l01550"></a>01550       }
<a name="l01551"></a>01551       <span class="keywordflow">else</span>
<a name="l01552"></a>01552         <span class="keywordflow">return</span> !strcmp(&amp;attrpath[len1], comp-&gt;attrpath) ?
<a name="l01553"></a>01553           odlTrue : odlFalse;
<a name="l01554"></a>01554     }
<a name="l01555"></a>01555     <span class="keywordflow">else</span> {
<a name="l01556"></a>01556       <span class="keywordflow">if</span> (!strncmp(comp-&gt;attrpath, s2.c_str(), len2)) {
<a name="l01557"></a>01557         <span class="keywordflow">return</span> !strcmp(attrpath, &amp;comp-&gt;attrpath[len2]) ?
<a name="l01558"></a>01558           odlTrue : odlFalse;
<a name="l01559"></a>01559       }
<a name="l01560"></a>01560     }
<a name="l01561"></a>01561 
<a name="l01562"></a>01562     <span class="keywordflow">return</span> odlFalse;
<a name="l01563"></a>01563   }
<a name="l01564"></a>01564 
<a name="l01565"></a>01565   odlBool
<a name="l01566"></a>01566   odlIndex::similar(odlAttrComponent *comp,
<a name="l01567"></a>01567                     <span class="keyword">const</span> Class *cls1, <span class="keyword">const</span> Class *cls2)
<a name="l01568"></a>01568   {
<a name="l01569"></a>01569     <span class="keywordflow">if</span> (!comp-&gt;asIndex())
<a name="l01570"></a>01570       <span class="keywordflow">return</span> odlFalse;
<a name="l01571"></a>01571     <span class="keywordflow">return</span> odlAttrComponent::similar(comp, cls1, cls2);
<a name="l01572"></a>01572   }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574   odlBool
<a name="l01575"></a>01575   odlCardinality::similar(odlAttrComponent *comp,
<a name="l01576"></a>01576                           <span class="keyword">const</span> Class *cls1, <span class="keyword">const</span> Class *cls2)
<a name="l01577"></a>01577   {
<a name="l01578"></a>01578     <span class="keywordflow">if</span> (!comp-&gt;asCardinality())
<a name="l01579"></a>01579       <span class="keywordflow">return</span> odlFalse;
<a name="l01580"></a>01580     <span class="keywordflow">return</span> odlAttrComponent::similar(comp, cls1, cls2);
<a name="l01581"></a>01581   }
<a name="l01582"></a>01582 
<a name="l01583"></a>01583   odlBool
<a name="l01584"></a>01584   odlImplementation::similar(odlAttrComponent *comp,
<a name="l01585"></a>01585                              <span class="keyword">const</span> Class *cls1, <span class="keyword">const</span> Class *cls2)
<a name="l01586"></a>01586   {
<a name="l01587"></a>01587     <span class="keywordflow">if</span> (!comp-&gt;asImplementation())
<a name="l01588"></a>01588       <span class="keywordflow">return</span> odlFalse;
<a name="l01589"></a>01589     <span class="keywordflow">return</span> odlAttrComponent::similar(comp, cls1, cls2);
<a name="l01590"></a>01590   }
<a name="l01591"></a>01591 
<a name="l01592"></a>01592   odlBool
<a name="l01593"></a>01593   odlNotnull::similar(odlAttrComponent *comp,
<a name="l01594"></a>01594                       <span class="keyword">const</span> Class *cls1, <span class="keyword">const</span> Class *cls2)
<a name="l01595"></a>01595   {
<a name="l01596"></a>01596     <span class="keywordflow">if</span> (!comp-&gt;asNotnull())
<a name="l01597"></a>01597       <span class="keywordflow">return</span> odlFalse;
<a name="l01598"></a>01598     <span class="keywordflow">return</span> odlAttrComponent::similar(comp, cls1, cls2);
<a name="l01599"></a>01599   }
<a name="l01600"></a>01600 
<a name="l01601"></a>01601   odlBool
<a name="l01602"></a>01602   odlUnique::similar(odlAttrComponent *comp,
<a name="l01603"></a>01603                      <span class="keyword">const</span> Class *cls1, <span class="keyword">const</span> Class *cls2)
<a name="l01604"></a>01604   {
<a name="l01605"></a>01605     <span class="keywordflow">if</span> (!comp-&gt;asUnique())
<a name="l01606"></a>01606       <span class="keywordflow">return</span> odlFalse;
<a name="l01607"></a>01607     <span class="keywordflow">return</span> odlAttrComponent::similar(comp, cls1, cls2);
<a name="l01608"></a>01608   }
<a name="l01609"></a>01609 
<a name="l01610"></a>01610   AttributeComponent *
<a name="l01611"></a>01611   odlIndex::make_realize(Database *db, Schema *m, Class *cls,
<a name="l01612"></a>01612                          <span class="keyword">const</span> Attribute *attr)
<a name="l01613"></a>01613   {
<a name="l01614"></a>01614     odlIndexImplSpecItem::Type type;
<a name="l01615"></a>01615     <span class="keywordtype">char</span> *hints;
<a name="l01616"></a>01616 
<a name="l01617"></a>01617     <span class="keywordflow">if</span> (index_impl_spec) {
<a name="l01618"></a>01618       <span class="keywordflow">if</span> (!index_impl_spec-&gt;make_prologue(attrpath, type, hints, attr))
<a name="l01619"></a>01619         <span class="keywordflow">return</span> 0;
<a name="l01620"></a>01620     }
<a name="l01621"></a>01621     <span class="keywordflow">else</span> {
<a name="l01622"></a>01622       hints = 0;
<a name="l01623"></a>01623       <span class="keywordflow">if</span> (attr &amp;&amp;
<a name="l01624"></a>01624           (attr-&gt;isString() || attr-&gt;isIndirect() ||
<a name="l01625"></a>01625            attr-&gt;getClass()-&gt;asCollectionClass())) <span class="comment">// what about enums</span>
<a name="l01626"></a>01626         type = odlIndexImplSpecItem::Hash;
<a name="l01627"></a>01627       <span class="keywordflow">else</span>
<a name="l01628"></a>01628         type = odlIndexImplSpecItem::BTree;
<a name="l01629"></a>01629     }
<a name="l01630"></a>01630 
<a name="l01631"></a>01631     Bool hasDB = IDBBOOL(db);
<a name="l01632"></a>01632 
<a name="l01633"></a>01633     <span class="keywordflow">if</span> (!db)
<a name="l01634"></a>01634       db = odl_get_dummy_db(m);
<a name="l01635"></a>01635 
<a name="l01636"></a>01636     Index *idx;
<a name="l01637"></a>01637     Status s;
<a name="l01638"></a>01638     <span class="keywordflow">if</span> (type == odlIndexImplSpecItem::Hash)
<a name="l01639"></a>01639       s = HashIndex::make(db,
<a name="l01640"></a>01640                           const_cast&lt;Class *&gt;(cls), attrpath,
<a name="l01641"></a>01641                           IDBBOOL(propagate), attr-&gt;isString(), hints,
<a name="l01642"></a>01642                           (HashIndex *&amp;)idx);
<a name="l01643"></a>01643     <span class="keywordflow">else</span>
<a name="l01644"></a>01644       s = BTreeIndex::make(db,
<a name="l01645"></a>01645                            const_cast&lt;Class *&gt;(cls), attrpath,
<a name="l01646"></a>01646                            IDBBOOL(propagate), attr-&gt;isString(), hints,
<a name="l01647"></a>01647                            (BTreeIndex *&amp;)idx);
<a name="l01648"></a>01648   
<a name="l01649"></a>01649     <span class="keywordflow">if</span> (s) { 
<a name="l01650"></a>01650       odl_add_error(s);
<a name="l01651"></a>01651       <span class="keywordflow">return</span> 0;
<a name="l01652"></a>01652     }
<a name="l01653"></a>01653 
<a name="l01654"></a>01654     <span class="keywordflow">return</span> idx;
<a name="l01655"></a>01655   }
<a name="l01656"></a>01656 
<a name="l01657"></a>01657   AttributeComponent *
<a name="l01658"></a>01658   odlImplementation::make_realize(Database *db, Schema *m, Class *cls,
<a name="l01659"></a>01659                                   <span class="keyword">const</span> Attribute *attr)
<a name="l01660"></a>01660   {
<a name="l01661"></a>01661     <span class="comment">// TBD: Index -&gt; Coll</span>
<a name="l01662"></a>01662     odlCollImplSpecItem::Type type;
<a name="l01663"></a>01663     <span class="keywordtype">char</span> *hints;
<a name="l01664"></a>01664 
<a name="l01665"></a>01665     <span class="keywordflow">if</span> (coll_impl_spec) {
<a name="l01666"></a>01666       <span class="keywordflow">if</span> (!coll_impl_spec-&gt;make_attr_prologue(attrpath, type, hints, attr))
<a name="l01667"></a>01667         <span class="keywordflow">return</span> 0;
<a name="l01668"></a>01668     }
<a name="l01669"></a>01669     <span class="keywordflow">else</span> {
<a name="l01670"></a>01670       hints = 0;
<a name="l01671"></a>01671       <span class="comment">//type = odlCollImplSpecItem::HashIndex;</span>
<a name="l01672"></a>01672       type = odlCollImplSpecItem::NoIndex;
<a name="l01673"></a>01673     }
<a name="l01674"></a>01674 
<a name="l01675"></a>01675     Bool hasDB = IDBBOOL(db);
<a name="l01676"></a>01676     <span class="keywordflow">if</span> (!db)
<a name="l01677"></a>01677       db = odl_get_dummy_db(m);
<a name="l01678"></a>01678 
<a name="l01679"></a>01679     CollAttrImpl *impl;
<a name="l01680"></a>01680     CollImpl::Type impltype;
<a name="l01681"></a>01681 
<a name="l01682"></a>01682     <span class="keywordflow">if</span> (type == odlCollImplSpecItem::HashIndex) {
<a name="l01683"></a>01683       impltype = CollImpl::HashIndex;
<a name="l01684"></a>01684     }
<a name="l01685"></a>01685     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == odlCollImplSpecItem::BTreeIndex) {
<a name="l01686"></a>01686       impltype = CollImpl::BTreeIndex;
<a name="l01687"></a>01687     }
<a name="l01688"></a>01688     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == odlCollImplSpecItem::NoIndex) {
<a name="l01689"></a>01689       impltype = CollImpl::NoIndex;
<a name="l01690"></a>01690     }
<a name="l01691"></a>01691     <span class="keywordflow">else</span> {
<a name="l01692"></a>01692       odl_add_error(<span class="stringliteral">&quot;unknown implementation type for attribute %s&quot;</span>, attrpath);
<a name="l01693"></a>01693       <span class="keywordflow">return</span> 0;
<a name="l01694"></a>01694     }
<a name="l01695"></a>01695 
<a name="l01696"></a>01696     Status s = CollAttrImpl::make
<a name="l01697"></a>01697       (db, const_cast&lt;Class *&gt;(cls), attrpath, IDBBOOL(propagate),
<a name="l01698"></a>01698        impltype, hints, (CollAttrImpl *&amp;)impl);
<a name="l01699"></a>01699   
<a name="l01700"></a>01700     <span class="keywordflow">if</span> (s) { 
<a name="l01701"></a>01701       odl_add_error(s);
<a name="l01702"></a>01702       <span class="keywordflow">return</span> 0;
<a name="l01703"></a>01703     }
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     <span class="keywordflow">return</span> impl;
<a name="l01706"></a>01706   }
<a name="l01707"></a>01707 
<a name="l01708"></a>01708   AttributeComponent *
<a name="l01709"></a>01709   odlNotnull::make_realize(Database *db, Schema *m, Class *cls,
<a name="l01710"></a>01710                            <span class="keyword">const</span> Attribute *)
<a name="l01711"></a>01711   {
<a name="l01712"></a>01712     <span class="keywordflow">return</span> <span class="keyword">new</span> NotNullConstraint(db, cls, attrpath, IDBBOOL(propagate));
<a name="l01713"></a>01713   }
<a name="l01714"></a>01714 
<a name="l01715"></a>01715   AttributeComponent *
<a name="l01716"></a>01716   odlUnique::make_realize(Database *db, Schema *m, Class *cls,
<a name="l01717"></a>01717                           <span class="keyword">const</span> Attribute *)
<a name="l01718"></a>01718   {
<a name="l01719"></a>01719     <span class="keywordflow">return</span> <span class="keyword">new</span> UniqueConstraint(db, cls, attrpath, IDBBOOL(propagate));
<a name="l01720"></a>01720   }
<a name="l01721"></a>01721 
<a name="l01722"></a>01722   AttributeComponent *
<a name="l01723"></a>01723   odlCardinality::make_realize(Database *db, Schema *m, Class *cls,
<a name="l01724"></a>01724                                <span class="keyword">const</span> Attribute *)
<a name="l01725"></a>01725   {
<a name="l01726"></a>01726     <span class="keywordflow">return</span> 0;
<a name="l01727"></a>01727   }
<a name="l01728"></a>01728 
<a name="l01729"></a>01729   <span class="keywordtype">void</span> odlAgregatClass::realize(odlDeclItem *item,
<a name="l01730"></a>01730                                 Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l01731"></a>01731                                 <span class="keywordtype">int</span> n, ClassComponent **comp,
<a name="l01732"></a>01732                                 <span class="keywordtype">int</span> &amp;comp_cnt, Attribute **agr)
<a name="l01733"></a>01733   {
<a name="l01734"></a>01734     Class *cl = NULL;
<a name="l01735"></a>01735     <span class="keywordtype">int</span> *dims, ndims, index_mode;
<a name="l01736"></a>01736     Status status;
<a name="l01737"></a>01737 
<a name="l01738"></a>01738     <span class="keywordflow">if</span> (item-&gt;typname)
<a name="l01739"></a>01739       {
<a name="l01740"></a>01740         <span class="comment">/*</span>
<a name="l01741"></a>01741 <span class="comment">          if (!strcmp(item-&gt;typname, &quot;int&quot;))</span>
<a name="l01742"></a>01742 <span class="comment">          cl = m-&gt;Int32_Class;</span>
<a name="l01743"></a>01743 <span class="comment">          else */</span>
<a name="l01744"></a>01744         cl = eyedb::getClass(m, item-&gt;typname, prefix);
<a name="l01745"></a>01745       }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     <span class="keywordflow">if</span> (item-&gt;typname &amp;&amp; !cl)
<a name="l01748"></a>01748       {
<a name="l01749"></a>01749         ClassNotFound::error(item-&gt;typname, 
<a name="l01750"></a>01750                              (std::string(<span class="stringliteral">&quot;class &quot;</span>) + name +
<a name="l01751"></a>01751                               <span class="stringliteral">&quot;, attribute #&quot;</span> + str_convert((<span class="keywordtype">long</span>)n+1)).c_str());
<a name="l01752"></a>01752         <span class="keywordflow">return</span>;
<a name="l01753"></a>01753       }
<a name="l01754"></a>01754 
<a name="l01755"></a>01755     <span class="keywordflow">if</span> (check_name(m, name, item-&gt;typname, item-&gt;attrname, prefix))
<a name="l01756"></a>01756       {
<a name="l01757"></a>01757         odl_error++;
<a name="l01758"></a>01758         <span class="keywordflow">return</span>;
<a name="l01759"></a>01759       }
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     array_make(item, dims, ndims);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     <span class="keywordtype">char</span> *invcname, *invfname;
<a name="l01764"></a>01764     <span class="keywordflow">if</span> (item-&gt;inverse) {
<a name="l01765"></a>01765       invcname = item-&gt;inverse-&gt;classname;
<a name="l01766"></a>01766       invfname = item-&gt;inverse-&gt;attrname;
<a name="l01767"></a>01767     }
<a name="l01768"></a>01768     <span class="keywordflow">else</span> {
<a name="l01769"></a>01769       invcname = invfname = 0;
<a name="l01770"></a>01770     }
<a name="l01771"></a>01771     
<a name="l01772"></a>01772 <span class="preprocessor">#if 0</span>
<a name="l01773"></a>01773 <span class="preprocessor"></span>    Index *idx_item, *idx_comp;
<a name="l01774"></a>01774     item-&gt;attr_list_make(m, cls, index_mode, idx_item, idx_comp,
<a name="l01775"></a>01775                          &amp;invcname, &amp;invfname, comp, comp_cnt);
<a name="l01776"></a>01776 <span class="preprocessor">#endif</span>
<a name="l01777"></a>01777 <span class="preprocessor"></span>
<a name="l01778"></a>01778     <span class="keywordflow">if</span> (invcname)
<a name="l01779"></a>01779       invcname = strdup(makeName(invcname, prefix));
<a name="l01780"></a>01780 
<a name="l01781"></a>01781     <span class="keywordflow">if</span> (item-&gt;coll_spec)
<a name="l01782"></a>01782       {
<a name="l01783"></a>01783         odlCollSpec *coll_spec = item-&gt;coll_spec;
<a name="l01784"></a>01784         odlCollSpec *coll_spec_arr[64];
<a name="l01785"></a>01785         <span class="keywordtype">int</span> coll_spec_cnt = 0;
<a name="l01786"></a>01786 
<a name="l01787"></a>01787         <span class="keywordflow">while</span> (coll_spec)
<a name="l01788"></a>01788           {
<a name="l01789"></a>01789             <span class="comment">//printf(&quot;coll_spec #%d: %s\n&quot;, coll_spec_cnt, collSpecToString(coll_spec));</span>
<a name="l01790"></a>01790             coll_spec_arr[coll_spec_cnt++] = coll_spec;
<a name="l01791"></a>01791             coll_spec = coll_spec-&gt;coll_spec;
<a name="l01792"></a>01792           }
<a name="l01793"></a>01793 
<a name="l01794"></a>01794         <span class="keyword">const</span> <span class="keywordtype">char</span> *coll_typname = coll_spec_arr[coll_spec_cnt-1]-&gt;typname;
<a name="l01795"></a>01795         Class *mcoll = NULL;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = coll_spec_cnt-1; i &gt;= 0; i--)
<a name="l01798"></a>01798           {
<a name="l01799"></a>01799             coll_spec = coll_spec_arr[i];
<a name="l01800"></a>01800             cl = eyedb::getClass(m, coll_typname, prefix);
<a name="l01801"></a>01801 
<a name="l01802"></a>01802             <span class="keywordflow">if</span> (!cl) {
<a name="l01803"></a>01803               ClassNotFound::error(coll_typname,
<a name="l01804"></a>01804                                    (std::string(<span class="stringliteral">&quot;class &quot;</span>) + name).c_str());
<a name="l01805"></a>01805               <span class="keywordflow">return</span>;
<a name="l01806"></a>01806             }
<a name="l01807"></a>01807 
<a name="l01808"></a>01808             Exception::Mode mode = <a class="code" href="classeyedb_1_1Exception.html#a6593ce9ad1bc7686290829fe1fa15cd4" title="Not yet documented.">Exception::setMode</a>(Exception::StatusMode);
<a name="l01809"></a>01809             <span class="keywordflow">if</span> (!strcmp(coll_spec-&gt;collname, <span class="stringliteral">&quot;set&quot;</span>)) {
<a name="l01810"></a>01810               <span class="keywordflow">if</span> (coll_spec-&gt;dim)
<a name="l01811"></a>01811                 mcoll = <span class="keyword">new</span> CollSetClass(cl, coll_spec-&gt;dim);
<a name="l01812"></a>01812               <span class="keywordflow">else</span>
<a name="l01813"></a>01813                 mcoll = <span class="keyword">new</span> CollSetClass(cl, (Bool)coll_spec-&gt;isref);
<a name="l01814"></a>01814             }
<a name="l01815"></a>01815             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(coll_spec-&gt;collname, <span class="stringliteral">&quot;bag&quot;</span>)) {
<a name="l01816"></a>01816               <span class="keywordflow">if</span> (coll_spec-&gt;dim)
<a name="l01817"></a>01817                 mcoll = <span class="keyword">new</span> CollBagClass(cl, coll_spec-&gt;dim);
<a name="l01818"></a>01818               <span class="keywordflow">else</span>
<a name="l01819"></a>01819                 mcoll = <span class="keyword">new</span> CollBagClass(cl, (Bool)coll_spec-&gt;isref);
<a name="l01820"></a>01820             }
<a name="l01821"></a>01821             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(coll_spec-&gt;collname, <span class="stringliteral">&quot;array&quot;</span>)) {
<a name="l01822"></a>01822               <span class="keywordflow">if</span> (coll_spec-&gt;dim)
<a name="l01823"></a>01823                 mcoll = <span class="keyword">new</span> CollArrayClass(cl, coll_spec-&gt;dim);
<a name="l01824"></a>01824               <span class="keywordflow">else</span>
<a name="l01825"></a>01825                 mcoll = <span class="keyword">new</span> CollArrayClass(cl, (Bool)coll_spec-&gt;isref);
<a name="l01826"></a>01826             }
<a name="l01827"></a>01827             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(coll_spec-&gt;collname, <span class="stringliteral">&quot;list&quot;</span>)) {
<a name="l01828"></a>01828               <span class="keywordflow">if</span> (coll_spec-&gt;dim)
<a name="l01829"></a>01829                 mcoll = <span class="keyword">new</span> CollListClass(cl, coll_spec-&gt;dim);
<a name="l01830"></a>01830               <span class="keywordflow">else</span>
<a name="l01831"></a>01831                 mcoll = <span class="keyword">new</span> CollListClass(cl, (Bool)coll_spec-&gt;isref);
<a name="l01832"></a>01832             }
<a name="l01833"></a>01833             <span class="keywordflow">else</span> {
<a name="l01834"></a>01834               odl_add_error(<span class="stringliteral">&quot;invalid collection type &apos;%s&apos;\n&quot;</span>,
<a name="l01835"></a>01835                             coll_spec-&gt;collname);
<a name="l01836"></a>01836               <span class="keywordflow">return</span>;
<a name="l01837"></a>01837             }
<a name="l01838"></a>01838 
<a name="l01839"></a>01839             mcoll-&gt;setUserData(odlGENCODE, AnyUserData);
<a name="l01840"></a>01840             <a class="code" href="classeyedb_1_1Exception.html#a6593ce9ad1bc7686290829fe1fa15cd4" title="Not yet documented.">Exception::setMode</a>(mode);
<a name="l01841"></a>01841           
<a name="l01842"></a>01842             <span class="comment">/*</span>
<a name="l01843"></a>01843 <span class="comment">              if (!coll_spec-&gt;isref) {</span>
<a name="l01844"></a>01844 <span class="comment">              odl_add_error(&quot;&apos;%s&lt;%s&gt; %s%s&apos;: only collection of objects are &quot;</span>
<a name="l01845"></a>01845 <span class="comment">              &quot;supported\n&quot;,</span>
<a name="l01846"></a>01846 <span class="comment">              coll_spec-&gt;collname, cl-&gt;getName(),</span>
<a name="l01847"></a>01847 <span class="comment">              (item-&gt;isref ? &quot;*&quot; : &quot;&quot;), item-&gt;attrname);</span>
<a name="l01848"></a>01848 <span class="comment">              return;</span>
<a name="l01849"></a>01849 <span class="comment">              }</span>
<a name="l01850"></a>01850 <span class="comment">            */</span>
<a name="l01851"></a>01851 
<a name="l01852"></a>01852             status = mcoll-&gt;asCollectionClass()-&gt;getStatus();
<a name="l01853"></a>01853             <span class="keywordflow">if</span> (status) {
<a name="l01854"></a>01854               odl_add_error(<span class="stringliteral">&quot;attribute error &apos;%s::%s&apos;: &quot;</span>, name, item-&gt;attrname);
<a name="l01855"></a>01855               odl_add_error(status);
<a name="l01856"></a>01856               odl_error--;
<a name="l01857"></a>01857               <span class="keywordflow">return</span>;
<a name="l01858"></a>01858             }
<a name="l01859"></a>01859 
<a name="l01860"></a>01860             Class *mcoll_old = m-&gt;getClass(mcoll-&gt;getName());
<a name="l01861"></a>01861 
<a name="l01862"></a>01862             <span class="keywordflow">if</span> (mcoll_old) {
<a name="l01863"></a>01863               mcoll-&gt;release();
<a name="l01864"></a>01864               mcoll = mcoll_old;
<a name="l01865"></a>01865             }
<a name="l01866"></a>01866             <span class="keywordflow">else</span>
<a name="l01867"></a>01867               m-&gt;addClass(mcoll);
<a name="l01868"></a>01868 
<a name="l01869"></a>01869             coll_typname = mcoll-&gt;getName();
<a name="l01870"></a>01870           }
<a name="l01871"></a>01871 
<a name="l01872"></a>01872         <span class="keywordflow">if</span> (invfname)
<a name="l01873"></a>01873           {
<a name="l01874"></a>01874             <span class="keywordflow">if</span> (invcname)
<a name="l01875"></a>01875               {
<a name="l01876"></a>01876                 <span class="keywordflow">if</span> (strcmp(invcname, cl-&gt;getName()) &amp;&amp;
<a name="l01877"></a>01877                     strcmp(invcname, cl-&gt;getAliasName()))
<a name="l01878"></a>01878                   {
<a name="l01879"></a>01879                     odl_add_error(<span class="stringliteral">&quot;inverse class incoherency: got &apos;%s&apos;, expected &apos;%s&apos;\n&quot;</span>, invcname, mcoll-&gt;getName());
<a name="l01880"></a>01880                     <span class="keywordflow">return</span>;
<a name="l01881"></a>01881                   }
<a name="l01882"></a>01882               }
<a name="l01883"></a>01883             <span class="keywordflow">else</span>
<a name="l01884"></a>01884               invcname = strdup(cl-&gt;getAliasName());
<a name="l01885"></a>01885           }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887         agr[n] =
<a name="l01888"></a>01888           <span class="keyword">new</span> Attribute(mcoll, item-&gt;attrname, (Bool)item-&gt;isref, ndims, dims);
<a name="l01889"></a>01889 
<a name="l01890"></a>01890         <span class="comment">//agr[n]-&gt;setMagOrder(getMagOrder(cls, item-&gt;attr_list, agr[n]-&gt;getName()));</span>
<a name="l01891"></a>01891         agr[n]-&gt;setUserData(item-&gt;upd_hints);
<a name="l01892"></a>01892 
<a name="l01893"></a>01893         status = agr[n]-&gt;check();
<a name="l01894"></a>01894         <span class="keywordflow">if</span> (status)
<a name="l01895"></a>01895           odl_add_error(status);
<a name="l01896"></a>01896       }
<a name="l01897"></a>01897     <span class="keywordflow">else</span>
<a name="l01898"></a>01898       {
<a name="l01899"></a>01899         <span class="keywordflow">if</span> (invfname)
<a name="l01900"></a>01900           {
<a name="l01901"></a>01901             <span class="keywordflow">if</span> (invcname)
<a name="l01902"></a>01902               {
<a name="l01903"></a>01903                 <span class="keywordflow">if</span> (strcmp(invcname, cl-&gt;getName()) &amp;&amp;
<a name="l01904"></a>01904                     strcmp(invcname, cl-&gt;getAliasName()))
<a name="l01905"></a>01905                   {
<a name="l01906"></a>01906                     odl_add_error(<span class="stringliteral">&quot;inverse class incoherency: got &apos;%s&apos;, expected &apos;%s&apos;\n&quot;</span>, invcname, cl-&gt;getName());
<a name="l01907"></a>01907                     <span class="keywordflow">return</span>;
<a name="l01908"></a>01908                   }
<a name="l01909"></a>01909               }
<a name="l01910"></a>01910             <span class="keywordflow">else</span>
<a name="l01911"></a>01911               invcname = strdup(cl-&gt;getAliasName());
<a name="l01912"></a>01912           }
<a name="l01913"></a>01913 
<a name="l01914"></a>01914         agr[n] = <span class="keyword">new</span> Attribute(cl, item-&gt;attrname, (Bool)item-&gt;isref,
<a name="l01915"></a>01915                                ndims, dims);
<a name="l01916"></a>01916         <span class="comment">//agr[n]-&gt;setMagOrder(getMagOrder(cls, item-&gt;attr_list, agr[n]-&gt;getName()));</span>
<a name="l01917"></a>01917         agr[n]-&gt;setUserData(item-&gt;upd_hints);
<a name="l01918"></a>01918         status = agr[n]-&gt;check();
<a name="l01919"></a>01919         <span class="keywordflow">if</span> (status)
<a name="l01920"></a>01920           odl_add_error(status);
<a name="l01921"></a>01921       }
<a name="l01922"></a>01922 
<a name="l01923"></a>01923     <span class="keywordflow">if</span> (invcname)
<a name="l01924"></a>01924       {
<a name="l01925"></a>01925         status = agr[n]-&gt;setInverse(invcname, invfname);
<a name="l01926"></a>01926       
<a name="l01927"></a>01927         <span class="keywordflow">if</span> (status)
<a name="l01928"></a>01928           odl_add_error(status);
<a name="l01929"></a>01929       }
<a name="l01930"></a>01930   }
<a name="l01931"></a>01931 
<a name="l01932"></a>01932   <span class="keyword">static</span> TriggerType
<a name="l01933"></a>01933   makeTrigType(<span class="keyword">const</span> <span class="keywordtype">char</span> *loc)
<a name="l01934"></a>01934   {
<a name="l01935"></a>01935     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;create_before&quot;</span>))
<a name="l01936"></a>01936       <span class="keywordflow">return</span> TriggerCREATE_BEFORE;
<a name="l01937"></a>01937     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;create_after&quot;</span>))
<a name="l01938"></a>01938       <span class="keywordflow">return</span> TriggerCREATE_AFTER;
<a name="l01939"></a>01939     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;update_before&quot;</span>))
<a name="l01940"></a>01940       <span class="keywordflow">return</span> TriggerUPDATE_BEFORE;
<a name="l01941"></a>01941     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;update_after&quot;</span>))
<a name="l01942"></a>01942       <span class="keywordflow">return</span> TriggerUPDATE_AFTER;
<a name="l01943"></a>01943     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;load_before&quot;</span>))
<a name="l01944"></a>01944       <span class="keywordflow">return</span> TriggerLOAD_BEFORE;
<a name="l01945"></a>01945     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;load_after&quot;</span>))
<a name="l01946"></a>01946       <span class="keywordflow">return</span> TriggerLOAD_AFTER;
<a name="l01947"></a>01947     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;remove_before&quot;</span>))
<a name="l01948"></a>01948       <span class="keywordflow">return</span> TriggerREMOVE_BEFORE;
<a name="l01949"></a>01949     <span class="keywordflow">if</span> (!strcmp(loc, <span class="stringliteral">&quot;remove_after&quot;</span>))
<a name="l01950"></a>01950       <span class="keywordflow">return</span> TriggerREMOVE_AFTER;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952     odl_add_error(<span class="stringliteral">&quot;invalid trigger localisation &apos;%s&apos;\n&quot;</span>, loc);
<a name="l01953"></a>01953     <span class="keywordflow">return</span> (TriggerType)0;
<a name="l01954"></a>01954   }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956   <span class="keyword">static</span> Signature *
<a name="l01957"></a>01957   makeSignature(Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *clsname, <span class="keyword">const</span> <span class="keywordtype">char</span> *mthname,
<a name="l01958"></a>01958                 <span class="keyword">const</span> <span class="keywordtype">char</span> *rettype, odlArgSpecList *arglist,
<a name="l01959"></a>01959                 <span class="keywordtype">int</span> &amp;missNames)
<a name="l01960"></a>01960   {
<a name="l01961"></a>01961     ArgType *type = ArgType::make(m, rettype);
<a name="l01962"></a>01962 
<a name="l01963"></a>01963     <span class="keywordflow">if</span> (!type)
<a name="l01964"></a>01964       {
<a name="l01965"></a>01965         type = ArgType::make(m, (odl_db_prefix + rettype).c_str());
<a name="l01966"></a>01966         <span class="keywordflow">if</span> (!type) {
<a name="l01967"></a>01967           ClassNotFound::error(rettype,
<a name="l01968"></a>01968                                (std::string(<span class="stringliteral">&quot;method &quot;</span>) + clsname + <span class="stringliteral">&quot;::&quot;</span> +
<a name="l01969"></a>01969                                 mthname).c_str());
<a name="l01970"></a>01970           <span class="keywordflow">return</span> 0;
<a name="l01971"></a>01971         }
<a name="l01972"></a>01972       }
<a name="l01973"></a>01973 
<a name="l01974"></a>01974     missNames = 0;
<a name="l01975"></a>01975     type-&gt;setType((ArgType_Type)(type-&gt;getType() | OUT_ARG_TYPE), False);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977     Signature *sign = <span class="keyword">new</span> Signature();
<a name="l01978"></a>01978 <span class="preprocessor">#ifdef NO_DIRECT_SET</span>
<a name="l01979"></a>01979 <span class="preprocessor"></span>    *sign-&gt;getRettype() = *type;
<a name="l01980"></a>01980 <span class="preprocessor">#endif</span>
<a name="l01981"></a>01981 <span class="preprocessor"></span>
<a name="l01982"></a>01982 <span class="preprocessor">#ifndef NO_DIRECT_SET</span>
<a name="l01983"></a>01983 <span class="preprocessor"></span>    sign-&gt;setRettype(type);
<a name="l01984"></a>01984 <span class="preprocessor">#endif</span>
<a name="l01985"></a>01985 <span class="preprocessor"></span>    sign-&gt;setNargs(arglist-&gt;count);
<a name="l01986"></a>01986     odlArgSpecLink *l = arglist-&gt;first;
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 <span class="preprocessor">#ifdef NO_DIRECT_SET</span>
<a name="l01989"></a>01989 <span class="preprocessor"></span>    sign-&gt;setTypesCount(arglist-&gt;count);
<a name="l01990"></a>01990 <span class="preprocessor">#endif</span>
<a name="l01991"></a>01991 <span class="preprocessor"></span>    <span class="keywordtype">char</span> **names = <span class="keyword">new</span> <span class="keywordtype">char</span> *[arglist-&gt;count];
<a name="l01992"></a>01992 
<a name="l01993"></a>01993     <span class="keywordtype">int</span> n = 0;
<a name="l01994"></a>01994     <span class="keywordflow">while</span> (l)
<a name="l01995"></a>01995       {
<a name="l01996"></a>01996         type = ArgType::make(m, l-&gt;x-&gt;typname);
<a name="l01997"></a>01997         <span class="keywordflow">if</span> (!type)
<a name="l01998"></a>01998           {
<a name="l01999"></a>01999             type = ArgType::make(m, (odl_db_prefix + l-&gt;x-&gt;typname).c_str());
<a name="l02000"></a>02000             <span class="keywordflow">if</span> (!type) {
<a name="l02001"></a>02001               ClassNotFound::error(l-&gt;x-&gt;typname,
<a name="l02002"></a>02002                                    (std::string(<span class="stringliteral">&quot;method &quot;</span>) + clsname + <span class="stringliteral">&quot;::&quot;</span> +
<a name="l02003"></a>02003                                     mthname + <span class="stringliteral">&quot;, argument #&quot;</span> +
<a name="l02004"></a>02004                                     str_convert((<span class="keywordtype">long</span>)n+1)).c_str());
<a name="l02005"></a>02005               <span class="keywordflow">if</span> (sign)
<a name="l02006"></a>02006                 sign-&gt;release();
<a name="l02007"></a>02007               sign = 0;
<a name="l02008"></a>02008               <span class="comment">//return 0;</span>
<a name="l02009"></a>02009             }
<a name="l02010"></a>02010           }
<a name="l02011"></a>02011 
<a name="l02012"></a>02012         <span class="keywordflow">if</span> (sign) {
<a name="l02013"></a>02013           type-&gt;setType((ArgType_Type)(type-&gt;getType() | l-&gt;x-&gt;inout), False);
<a name="l02014"></a>02014 <span class="preprocessor">#ifdef NO_DIRECT_SET</span>
<a name="l02015"></a>02015 <span class="preprocessor"></span>          *sign-&gt;getTypes(n) = *type;
<a name="l02016"></a>02016 <span class="preprocessor">#else</span>
<a name="l02017"></a>02017 <span class="preprocessor"></span>          sign-&gt;setTypes(n, type);
<a name="l02018"></a>02018 <span class="preprocessor">#endif</span>
<a name="l02019"></a>02019 <span class="preprocessor"></span>          names[n] = (l-&gt;x-&gt;varname ? strdup(l-&gt;x-&gt;varname) : 0);
<a name="l02020"></a>02020           <span class="keywordflow">if</span> (!names[n])
<a name="l02021"></a>02021             missNames++;
<a name="l02022"></a>02022         }
<a name="l02023"></a>02023 
<a name="l02024"></a>02024         l = l-&gt;next;
<a name="l02025"></a>02025         n++;
<a name="l02026"></a>02026       }
<a name="l02027"></a>02027 
<a name="l02028"></a>02028     <span class="keywordflow">if</span> (!sign) <span class="keywordflow">return</span> 0;
<a name="l02029"></a>02029     odlSignUserData *sud = <span class="keyword">new</span> odlSignUserData(names);
<a name="l02030"></a>02030     sign-&gt;setUserData(sud);
<a name="l02031"></a>02031     <span class="keywordflow">return</span> sign;
<a name="l02032"></a>02032   }
<a name="l02033"></a>02033 
<a name="l02034"></a>02034   <span class="keywordtype">int</span>
<a name="l02035"></a>02035   odlMethodSpec::getParamNames(<span class="keywordtype">char</span> **&amp;typnames, <span class="keywordtype">char</span> **&amp;varnames)
<a name="l02036"></a>02036   {
<a name="l02037"></a>02037     <span class="keywordtype">int</span> param_cnt = arglist-&gt;count;
<a name="l02038"></a>02038     typnames = <span class="keyword">new</span> <span class="keywordtype">char</span>*[param_cnt];
<a name="l02039"></a>02039     varnames = <span class="keyword">new</span> <span class="keywordtype">char</span>*[param_cnt];
<a name="l02040"></a>02040 
<a name="l02041"></a>02041     odlArgSpecLink *l = arglist-&gt;first;
<a name="l02042"></a>02042 
<a name="l02043"></a>02043     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; l; n++)
<a name="l02044"></a>02044       {
<a name="l02045"></a>02045         <span class="keyword">const</span> <span class="keywordtype">char</span> *s;
<a name="l02046"></a>02046         <span class="keywordflow">if</span> (l-&gt;x-&gt;inout == INOUT_ARG_TYPE)
<a name="l02047"></a>02047           s = <span class="stringliteral">&quot;inout&quot;</span>;
<a name="l02048"></a>02048         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (l-&gt;x-&gt;inout == IN_ARG_TYPE)
<a name="l02049"></a>02049           s = <span class="stringliteral">&quot;in&quot;</span>;
<a name="l02050"></a>02050         <span class="keywordflow">else</span>
<a name="l02051"></a>02051           s = <span class="stringliteral">&quot;out&quot;</span>;
<a name="l02052"></a>02052         typnames[n] = strdup((std::string(s) + <span class="stringliteral">&quot;$&quot;</span> + l-&gt;x-&gt;typname).c_str());
<a name="l02053"></a>02053         varnames[n] = l-&gt;x-&gt;varname;
<a name="l02054"></a>02054         l = l-&gt;next;
<a name="l02055"></a>02055       }
<a name="l02056"></a>02056 
<a name="l02057"></a>02057     <span class="keywordflow">return</span> param_cnt;
<a name="l02058"></a>02058   }
<a name="l02059"></a>02059 
<a name="l02060"></a>02060   std::string
<a name="l02061"></a>02061   odlTriggerSpec::makeOQLBody(<span class="keyword">const</span> Class *cls)<span class="keyword"> const</span>
<a name="l02062"></a>02062 <span class="keyword">  </span>{
<a name="l02063"></a>02063     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;oql$&quot;</span>) + cls-&gt;getAliasName() + <span class="stringliteral">&quot;$&quot;</span> + name + <span class="stringliteral">&quot;(this) &quot;</span>;
<a name="l02064"></a>02064   }
<a name="l02065"></a>02065 
<a name="l02066"></a>02066   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02067"></a>02067   compileMethod(Schema *m, <span class="keyword">const</span> Class *cls, odlMethodSpec *mth)
<a name="l02068"></a>02068   {
<a name="l02069"></a>02069     <span class="keywordflow">if</span> (!m-&gt;getDatabase() || !m-&gt;getDatabase()-&gt;isOpened())
<a name="l02070"></a>02070       <span class="keywordflow">return</span>;
<a name="l02071"></a>02071 
<a name="l02072"></a>02072     <span class="keywordtype">char</span> **typnames;
<a name="l02073"></a>02073     <span class="keywordtype">char</span> **varnames;
<a name="l02074"></a>02074     <span class="keywordtype">int</span> param_cnt = mth-&gt;getParamNames(typnames, varnames);
<a name="l02075"></a>02075     std::string oqlConstruct;
<a name="l02076"></a>02076 
<a name="l02077"></a>02077     std::string body = BEMethod_OQL::makeExtrefBody(cls, mth-&gt;oqlSpec,
<a name="l02078"></a>02078                                                     mth-&gt;fname,
<a name="l02079"></a>02079                                                     typnames, varnames,
<a name="l02080"></a>02080                                                     param_cnt,
<a name="l02081"></a>02081                                                     oqlConstruct);
<a name="l02082"></a>02082 
<a name="l02083"></a>02083     oqmlStatus *s = oqml_realize(m-&gt;getDatabase(),
<a name="l02084"></a>02084                                  (<span class="keywordtype">char</span> *)oqlConstruct.c_str(), 0,
<a name="l02085"></a>02085                                  oqml_True);
<a name="l02086"></a>02086     <span class="keywordflow">if</span> (s)
<a name="l02087"></a>02087       odl_add_error(<span class="stringliteral">&quot;compiling &apos;%s::%s&apos;: %s\n&quot;</span>,
<a name="l02088"></a>02088                     cls-&gt;getAliasName(), mth-&gt;fname, s-&gt;msg);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090     free(mth-&gt;oqlSpec);
<a name="l02091"></a>02091     mth-&gt;oqlSpec = strdup(body.c_str());
<a name="l02092"></a>02092   }
<a name="l02093"></a>02093 
<a name="l02094"></a>02094   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02095"></a>02095   compileTrigger(Schema *m, <span class="keyword">const</span> Class *cls, odlTriggerSpec *trig)
<a name="l02096"></a>02096   {
<a name="l02097"></a>02097     std::string oqlConstruct;
<a name="l02098"></a>02098 
<a name="l02099"></a>02099     std::string body = Trigger::makeExtrefBody(cls, trig-&gt;oqlSpec,
<a name="l02100"></a>02100                                                trig-&gt;name,
<a name="l02101"></a>02101                                                oqlConstruct);
<a name="l02102"></a>02102 
<a name="l02103"></a>02103     oqmlStatus *s = oqml_realize(m-&gt;getDatabase(),
<a name="l02104"></a>02104                                  (<span class="keywordtype">char</span> *)oqlConstruct.c_str(), 0,
<a name="l02105"></a>02105                                  oqml_True);
<a name="l02106"></a>02106     <span class="keywordflow">if</span> (s)
<a name="l02107"></a>02107       odl_add_error(<span class="stringliteral">&quot;compiling trigger &apos;%s::%s&apos;: %s\n&quot;</span>,
<a name="l02108"></a>02108                     cls-&gt;getAliasName(), trig-&gt;name, s-&gt;msg);
<a name="l02109"></a>02109 
<a name="l02110"></a>02110     <span class="comment">/*</span>
<a name="l02111"></a>02111 <span class="comment">      char *str = strdup(std::string(&quot;function &quot;) + trig-&gt;makeOQLBody(cls) +</span>
<a name="l02112"></a>02112 <span class="comment">      trig-&gt;oqlSpec);</span>
<a name="l02113"></a>02113 <span class="comment"></span>
<a name="l02114"></a>02114 <span class="comment">      oqmlStatus *s = oqml_realize(m-&gt;getDatabase(), (char *)str, 0, oqml_True);</span>
<a name="l02115"></a>02115 <span class="comment">      if (s)</span>
<a name="l02116"></a>02116 <span class="comment">      odl_add_error(&quot;compiling trigger &apos;%s::%s&apos;: %s\n&quot;,</span>
<a name="l02117"></a>02117 <span class="comment">      cls-&gt;getAliasName(), trig-&gt;name, s-&gt;msg);</span>
<a name="l02118"></a>02118 <span class="comment">    */</span>
<a name="l02119"></a>02119 
<a name="l02120"></a>02120     free(trig-&gt;oqlSpec);
<a name="l02121"></a>02121     trig-&gt;oqlSpec = strdup(body.c_str());
<a name="l02122"></a>02122   }
<a name="l02123"></a>02123 
<a name="l02124"></a>02124   <span class="keywordtype">void</span> odlAgregatClass::realize(Database *db, Schema *m,
<a name="l02125"></a>02125                                 odlExecSpec *ex, <span class="keyword">const</span> <span class="keywordtype">char</span> *def_extref)
<a name="l02126"></a>02126   {
<a name="l02127"></a>02127     ClassComponent *comp = 0;
<a name="l02128"></a>02128     odlMethodSpec *mth;
<a name="l02129"></a>02129     odlTriggerSpec *trig;
<a name="l02130"></a>02130 
<a name="l02131"></a>02131     <span class="keywordflow">if</span> (mth = ex-&gt;asMethodSpec()) {
<a name="l02132"></a>02132       <span class="keywordtype">int</span> missNames;
<a name="l02133"></a>02133       Signature *sign = makeSignature(m, name, mth-&gt;fname,
<a name="l02134"></a>02134                                       mth-&gt;rettype, mth-&gt;arglist,
<a name="l02135"></a>02135                                       missNames);
<a name="l02136"></a>02136 
<a name="l02137"></a>02137       <span class="keywordflow">if</span> (!sign)
<a name="l02138"></a>02138         <span class="keywordflow">return</span>;
<a name="l02139"></a>02139 
<a name="l02140"></a>02140       <span class="keywordflow">if</span> (mth-&gt;oqlSpec) {
<a name="l02141"></a>02141         <span class="keywordflow">if</span> (missNames) {
<a name="l02142"></a>02142           odl_add_error(<span class="stringliteral">&quot;method &apos;%s::%s&apos; : signatures for OQL&quot;</span>
<a name="l02143"></a>02143                         <span class="stringliteral">&quot; methods must contains parameter names\n&quot;</span>,
<a name="l02144"></a>02144                         cls-&gt;getName(), mth-&gt;fname);
<a name="l02145"></a>02145           <span class="keywordflow">return</span>;
<a name="l02146"></a>02146         }
<a name="l02147"></a>02147 
<a name="l02148"></a>02148         compileMethod(m, cls, mth);
<a name="l02149"></a>02149 
<a name="l02150"></a>02150         comp = <span class="keyword">new</span> BEMethod_OQL(0, cls, mth-&gt;fname, sign,
<a name="l02151"></a>02151                                 (Bool)mth-&gt;isClassMethod,
<a name="l02152"></a>02152                                 odl_system_class,
<a name="l02153"></a>02153                                 mth-&gt;oqlSpec);
<a name="l02154"></a>02154       }
<a name="l02155"></a>02155       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mth-&gt;mth_hints.isClient)
<a name="l02156"></a>02156         comp = <span class="keyword">new</span> FEMethod_C(0, cls, mth-&gt;fname, sign,
<a name="l02157"></a>02157                               (Bool)mth-&gt;isClassMethod,
<a name="l02158"></a>02158                               odl_system_class,
<a name="l02159"></a>02159                               mth-&gt;extref ? mth-&gt;extref : def_extref);
<a name="l02160"></a>02160       <span class="keywordflow">else</span>
<a name="l02161"></a>02161         comp = <span class="keyword">new</span> BEMethod_C(0, cls, mth-&gt;fname, sign,
<a name="l02162"></a>02162                               (Bool)mth-&gt;isClassMethod,
<a name="l02163"></a>02163                               odl_system_class,
<a name="l02164"></a>02164                               mth-&gt;extref ? mth-&gt;extref : def_extref);
<a name="l02165"></a>02165       ((odlSignUserData *)sign-&gt;getUserData())-&gt;mth_hints = &amp;mth-&gt;mth_hints;
<a name="l02166"></a>02166       ((odlSignUserData *)sign-&gt;getUserData())-&gt;upd_hints = mth-&gt;upd_hints;
<a name="l02167"></a>02167       comp-&gt;setUserData(sign-&gt;getUserData());
<a name="l02168"></a>02168       comp-&gt;asMethod()-&gt;getEx()-&gt;getSign()-&gt;setUserData(sign-&gt;getUserData());
<a name="l02169"></a>02169     }
<a name="l02170"></a>02170     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (trig = ex-&gt;asTriggerSpec()) {
<a name="l02171"></a>02171       TriggerType ttype = makeTrigType(trig-&gt;localisation);
<a name="l02172"></a>02172       <span class="keywordflow">if</span> (ttype) {
<a name="l02173"></a>02173         <span class="keywordflow">if</span> (trig-&gt;oqlSpec)
<a name="l02174"></a>02174           compileTrigger(m, cls, trig);
<a name="l02175"></a>02175         <span class="keyword">const</span> <span class="keywordtype">char</span> *extref;
<a name="l02176"></a>02176         <span class="keywordflow">if</span> (trig-&gt;oqlSpec)
<a name="l02177"></a>02177           extref = trig-&gt;oqlSpec;
<a name="l02178"></a>02178         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (trig-&gt;extref)
<a name="l02179"></a>02179           extref = trig-&gt;extref;
<a name="l02180"></a>02180         <span class="keywordflow">else</span>
<a name="l02181"></a>02181           extref = def_extref;
<a name="l02182"></a>02182 
<a name="l02183"></a>02183         comp = <span class="keyword">new</span> Trigger(0, cls, ttype,
<a name="l02184"></a>02184                            (trig-&gt;oqlSpec ? OQL_LANG : C_LANG),
<a name="l02185"></a>02185                            odl_system_class,
<a name="l02186"></a>02186                            trig-&gt;name, trig-&gt;light ? True : False,
<a name="l02187"></a>02187                            extref);
<a name="l02188"></a>02188 
<a name="l02189"></a>02189         odlSignUserData *sud = <span class="keyword">new</span> odlSignUserData(0);
<a name="l02190"></a>02190         sud-&gt;upd_hints = trig-&gt;upd_hints;
<a name="l02191"></a>02191         comp-&gt;setUserData(sud);
<a name="l02192"></a>02192       }
<a name="l02193"></a>02193     }
<a name="l02194"></a>02194     <span class="keywordflow">else</span>
<a name="l02195"></a>02195       abort();
<a name="l02196"></a>02196 
<a name="l02197"></a>02197     <span class="keywordflow">if</span> (!odl_error){
<a name="l02198"></a>02198       <span class="keywordflow">if</span> (ex-&gt;asMethodSpec()) {
<a name="l02199"></a>02199         <span class="keywordflow">if</span> (!cls-&gt;getUserData(odlMTHLIST))
<a name="l02200"></a>02200           cls-&gt;setUserData(odlMTHLIST, <span class="keyword">new</span> LinkedList());
<a name="l02201"></a>02201         odlMTHLIST(cls)-&gt;insertObject(comp);
<a name="l02202"></a>02202       }
<a name="l02203"></a>02203       cls-&gt;add(comp-&gt;getInd(), comp);
<a name="l02204"></a>02204     }
<a name="l02205"></a>02205   }
<a name="l02206"></a>02206 
<a name="l02207"></a>02207   <span class="keywordtype">void</span>
<a name="l02208"></a>02208   odl_add_component(Schema *m, ClassComponent *comp)
<a name="l02209"></a>02209   {
<a name="l02210"></a>02210     <span class="keywordflow">if</span> (odl_error)
<a name="l02211"></a>02211       <span class="keywordflow">return</span>;
<a name="l02212"></a>02212 
<a name="l02213"></a>02213     <span class="comment">//printf(&quot;odlAddComponent(&apos;%s&apos;)\n&quot;, comp-&gt;getName());</span>
<a name="l02214"></a>02214     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlAddComponent(comp));
<a name="l02215"></a>02215     comp-&gt;getClassOwner()-&gt;touch();
<a name="l02216"></a>02216   }
<a name="l02217"></a>02217 
<a name="l02218"></a>02218   <span class="keywordtype">void</span>
<a name="l02219"></a>02219   odl_add_component(Schema *m, AttributeComponent *comp)
<a name="l02220"></a>02220   {
<a name="l02221"></a>02221     <span class="keywordflow">if</span> (odl_error)
<a name="l02222"></a>02222       <span class="keywordflow">return</span>;
<a name="l02223"></a>02223 
<a name="l02224"></a>02224     <span class="comment">//printf(&quot;odlAddComponent(&apos;%s&apos;) -&gt; %p\n&quot;, comp-&gt;getName(), comp);</span>
<a name="l02225"></a>02225     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlAddComponent(comp));
<a name="l02226"></a>02226     <span class="comment">//odlUPDLIST(m)-&gt;insertObjectFirst(new odlAddComponent(comp));</span>
<a name="l02227"></a>02227   }
<a name="l02228"></a>02228 
<a name="l02229"></a>02229   <span class="keywordtype">void</span>
<a name="l02230"></a>02230   odl_remove_component(Schema *m, ClassComponent *comp)
<a name="l02231"></a>02231   {
<a name="l02232"></a>02232     <span class="keywordflow">if</span> (odl_error)
<a name="l02233"></a>02233       <span class="keywordflow">return</span>;
<a name="l02234"></a>02234 
<a name="l02235"></a>02235     <span class="comment">//printf(&quot;odlRemoveComponent(&apos;%s&apos;)\n&quot;, comp-&gt;getName());</span>
<a name="l02236"></a>02236     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlRemoveComponent(comp));
<a name="l02237"></a>02237     comp-&gt;getClassOwner()-&gt;touch();
<a name="l02238"></a>02238   }
<a name="l02239"></a>02239 
<a name="l02240"></a>02240   <span class="keywordtype">void</span>
<a name="l02241"></a>02241   odl_remove_component(Schema *m, AttributeComponent *comp)
<a name="l02242"></a>02242   {
<a name="l02243"></a>02243     <span class="keywordflow">if</span> (odl_error)
<a name="l02244"></a>02244       <span class="keywordflow">return</span>;
<a name="l02245"></a>02245 
<a name="l02246"></a>02246     <span class="comment">//printf(&quot;odlRemoveComponent(&apos;%s&apos;) -&gt; %p\n&quot;, comp-&gt;getName(), comp);</span>
<a name="l02247"></a>02247     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlRemoveComponent(comp));
<a name="l02248"></a>02248   }
<a name="l02249"></a>02249 
<a name="l02250"></a>02250   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02251"></a>02251   odl_add_relationship(Schema *m, Class *cls, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l02252"></a>02252                        <span class="keyword">const</span> Attribute *item,
<a name="l02253"></a>02253                        <span class="keyword">const</span> Attribute *invitem)
<a name="l02254"></a>02254   {
<a name="l02255"></a>02255     cls-&gt;touch();
<a name="l02256"></a>02256     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlAddRelationship(item, invitem));
<a name="l02257"></a>02257   }
<a name="l02258"></a>02258 
<a name="l02259"></a>02259   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02260"></a>02260   odl_remove_relationship(Schema *m, Class *cls, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l02261"></a>02261                           <span class="keyword">const</span> Attribute *item,
<a name="l02262"></a>02262                           <span class="keyword">const</span> Attribute *invitem)
<a name="l02263"></a>02263   {
<a name="l02264"></a>02264     cls-&gt;touch();
<a name="l02265"></a>02265     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlRemoveRelationship(item, invitem));
<a name="l02266"></a>02266   }
<a name="l02267"></a>02267 
<a name="l02268"></a>02268   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02269"></a>02269   odl_add_class(Schema *m, <span class="keyword">const</span> Class *cls)
<a name="l02270"></a>02270   {
<a name="l02271"></a>02271     <span class="keywordflow">if</span> (odl_error)
<a name="l02272"></a>02272       <span class="keywordflow">return</span>;
<a name="l02273"></a>02273 
<a name="l02274"></a>02274     <span class="keywordflow">if</span> (!odl_rootclass || strcmp(cls-&gt;getName(), odl_rootclass))
<a name="l02275"></a>02275       odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlAddClass(cls));
<a name="l02276"></a>02276   }
<a name="l02277"></a>02277 
<a name="l02278"></a>02278   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02279"></a>02279   odl_remove_class(Database *db, Schema *m, <span class="keyword">const</span> Class *cls)
<a name="l02280"></a>02280   {
<a name="l02281"></a>02281     <span class="keywordflow">if</span> (odl_error)
<a name="l02282"></a>02282       <span class="keywordflow">return</span>;
<a name="l02283"></a>02283 
<a name="l02284"></a>02284     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlRemoveClass(db, cls,
<a name="l02285"></a>02285                                                        odlUPDLIST(m)));
<a name="l02286"></a>02286   }
<a name="l02287"></a>02287 
<a name="l02288"></a>02288   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02289"></a>02289   odl_migrate_attributes(Schema *m, <span class="keyword">const</span> Class *cls)
<a name="l02290"></a>02290   {
<a name="l02291"></a>02291     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attr_cnt;
<a name="l02292"></a>02292     <span class="keyword">const</span> Attribute **attrs  = cls-&gt;getAttributes(attr_cnt);
<a name="l02293"></a>02293 
<a name="l02294"></a>02294     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; attr_cnt; i++)
<a name="l02295"></a>02295       {
<a name="l02296"></a>02296         <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l02297"></a>02297         odlUpdateHint *upd_hints = (odlUpdateHint *)attr-&gt;getUserData();
<a name="l02298"></a>02298         <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::MigrateFrom)
<a name="l02299"></a>02299           {
<a name="l02300"></a>02300             <span class="keyword">const</span> Class *ocls = eyedb::getClass(m, upd_hints-&gt;detail, odl_db_prefix.c_str());
<a name="l02301"></a>02301             <span class="keywordflow">if</span> (!ocls)
<a name="l02302"></a>02302               {
<a name="l02303"></a>02303                 ClassNotFound::error(upd_hints-&gt;detail);
<a name="l02304"></a>02304                 <span class="keywordflow">continue</span>;
<a name="l02305"></a>02305               }
<a name="l02306"></a>02306 
<a name="l02307"></a>02307             ocls = (<span class="keyword">const</span> Class *)ocls-&gt;getUserData();
<a name="l02308"></a>02308             assert(ocls);
<a name="l02309"></a>02309 
<a name="l02310"></a>02310             <span class="keyword">const</span> Attribute *oattr = ocls-&gt;getAttribute(upd_hints-&gt;detail2);
<a name="l02311"></a>02311             <span class="keywordflow">if</span> (!oattr)
<a name="l02312"></a>02312               {
<a name="l02313"></a>02313                 odl_add_error(<span class="stringliteral">&quot;attribute %s not found in class %s\n&quot;</span>,
<a name="l02314"></a>02314                               upd_hints-&gt;detail2, upd_hints-&gt;detail);
<a name="l02315"></a>02315                 <span class="keywordflow">continue</span>;
<a name="l02316"></a>02316               }
<a name="l02317"></a>02317 
<a name="l02318"></a>02318             <span class="keyword">const_cast&lt;</span>Attribute *<span class="keyword">&gt;</span>(oattr)-&gt;setUserData
<a name="l02319"></a>02319               (<span class="keyword">new</span> odlUpdateHint
<a name="l02320"></a>02320                (odlUpdateHint::MigrateTo,
<a name="l02321"></a>02321                 cls-&gt;getName(), attr-&gt;getName(), upd_hints-&gt;detail3));
<a name="l02322"></a>02322           }
<a name="l02323"></a>02323       }
<a name="l02324"></a>02324   }
<a name="l02325"></a>02325 
<a name="l02326"></a>02326   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02327"></a>02327   odl_reparent_class(Schema *m, <span class="keyword">const</span> Class *cls)
<a name="l02328"></a>02328   {
<a name="l02329"></a>02329     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlReparentClass(cls));
<a name="l02330"></a>02330   }
<a name="l02331"></a>02331 
<a name="l02332"></a>02332   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02333"></a>02333   odl_add_attribute(Schema *m, <span class="keyword">const</span> Class *cls,
<a name="l02334"></a>02334                     <span class="keyword">const</span> Attribute *attr)
<a name="l02335"></a>02335   {
<a name="l02336"></a>02336     <span class="comment">//printf(&quot;XCOMP: add_attribute(%s, %p)\n&quot;, attr-&gt;getName(), cls);</span>
<a name="l02337"></a>02337     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlAddAttribute(cls, attr));
<a name="l02338"></a>02338   }
<a name="l02339"></a>02339 
<a name="l02340"></a>02340   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02341"></a>02341   odl_remove_attribute(Schema *m, <span class="keyword">const</span> Class *cls,
<a name="l02342"></a>02342                        <span class="keyword">const</span> Attribute *attr)
<a name="l02343"></a>02343   {
<a name="l02344"></a>02344     <span class="comment">//printf(&quot;XCOMP: remove_attribute(%s)\n&quot;, attr-&gt;getName());</span>
<a name="l02345"></a>02345     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlRemoveAttribute(cls, attr));
<a name="l02346"></a>02346   }
<a name="l02347"></a>02347 
<a name="l02348"></a>02348   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02349"></a>02349   odl_rename_attribute(Schema *m, <span class="keyword">const</span> Class *cls,
<a name="l02350"></a>02350                        <span class="keyword">const</span> Attribute *attr,
<a name="l02351"></a>02351                        odlUpdateHint *upd_hints)
<a name="l02352"></a>02352   {
<a name="l02353"></a>02353     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlRenameAttribute(cls, attr, upd_hints));
<a name="l02354"></a>02354   }
<a name="l02355"></a>02355 
<a name="l02356"></a>02356   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02357"></a>02357   odl_migrate_attribute(Schema *m, <span class="keyword">const</span> Class *cls,
<a name="l02358"></a>02358                         <span class="keyword">const</span> Attribute *attr, odlUpdateHint *upd_hints)
<a name="l02359"></a>02359   {
<a name="l02360"></a>02360     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlMigrateAttribute(cls, attr, upd_hints));
<a name="l02361"></a>02361   }
<a name="l02362"></a>02362   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02363"></a>02363   odl_convert_attribute(Schema *m, <span class="keyword">const</span> Class *cls,
<a name="l02364"></a>02364                         <span class="keyword">const</span> Attribute *oattr, <span class="keyword">const</span> Attribute *attr,
<a name="l02365"></a>02365                         odlUpdateHint *upd_hints = 0)
<a name="l02366"></a>02366   {
<a name="l02367"></a>02367     odlUPDLIST(m)-&gt;insertObjectLast(<span class="keyword">new</span> odlConvertAttribute(cls, oattr, attr, upd_hints));
<a name="l02368"></a>02368   }
<a name="l02369"></a>02369 
<a name="l02370"></a>02370   <span class="keyword">static</span> Bool
<a name="l02371"></a>02371   odl_reorder_attr(Schema *m, <span class="keyword">const</span> Class *cls,
<a name="l02372"></a>02372                    <span class="keyword">const</span> Attribute *attr, <span class="keywordtype">int</span> newnum)
<a name="l02373"></a>02373   {
<a name="l02374"></a>02374     <span class="keywordflow">if</span> (attr-&gt;getNum() != newnum)
<a name="l02375"></a>02375       {
<a name="l02376"></a>02376         odlUPDLIST(m)-&gt;insertObjectLast
<a name="l02377"></a>02377           (<span class="keyword">new</span> odlReorderAttribute(cls, attr, newnum, attr-&gt;getNum()));
<a name="l02378"></a>02378         <span class="keyword">const_cast&lt;</span>Attribute *<span class="keyword">&gt;</span>(attr)-&gt;setNum(newnum);
<a name="l02379"></a>02379         <span class="keywordflow">return</span> True;
<a name="l02380"></a>02380       }
<a name="l02381"></a>02381 
<a name="l02382"></a>02382     <span class="keywordflow">return</span> False;
<a name="l02383"></a>02383   }
<a name="l02384"></a>02384 
<a name="l02385"></a>02385   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02386"></a>02386   cmp_attr(<span class="keyword">const</span> <span class="keywordtype">void</span> *x1, <span class="keyword">const</span> <span class="keywordtype">void</span> *x2)
<a name="l02387"></a>02387   {
<a name="l02388"></a>02388     <span class="keywordflow">return</span> (*(Attribute **)x1)-&gt;getNum() - (*(Attribute **)x2)-&gt;getNum();
<a name="l02389"></a>02389   }
<a name="l02390"></a>02390 
<a name="l02391"></a>02391   <span class="keyword">static</span> Attribute *
<a name="l02392"></a>02392   odl_get_renamed_attr(Attribute *attrs[], <span class="keywordtype">int</span> attr_cnt,
<a name="l02393"></a>02393                        <span class="keyword">const</span> Attribute *oattr)
<a name="l02394"></a>02394   {
<a name="l02395"></a>02395     <span class="comment">// check if not renamed!</span>
<a name="l02396"></a>02396     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; attr_cnt; j++)
<a name="l02397"></a>02397       {
<a name="l02398"></a>02398         <span class="keyword">const</span> Attribute *attr = attrs[j];
<a name="l02399"></a>02399         odlUpdateHint *upd_hints = (odlUpdateHint *)attr-&gt;<a class="code" href="classeyedb_1_1Attribute.html#ae0e9eb0964dd711e005ea739d17954da" title="Not yet documented.">getUserData</a>();
<a name="l02400"></a>02400         <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::RenameFrom &amp;&amp;
<a name="l02401"></a>02401             !strcmp(upd_hints-&gt;detail, oattr-&gt;getName()))
<a name="l02402"></a>02402           <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>Attribute *<span class="keyword">&gt;</span>(attr);
<a name="l02403"></a>02403       }
<a name="l02404"></a>02404 
<a name="l02405"></a>02405     <span class="keywordflow">return</span> 0;
<a name="l02406"></a>02406   }
<a name="l02407"></a>02407 
<a name="l02408"></a>02408 <span class="preprocessor">#define COMPLETE(CLS)                                   \</span>
<a name="l02409"></a>02409 <span class="preprocessor">  if ((CLS)-&gt;isPartiallyLoaded())                       \</span>
<a name="l02410"></a>02410 <span class="preprocessor">    {                                                   \</span>
<a name="l02411"></a>02411 <span class="preprocessor">      Status s = m-&gt;manageClassDeferred((Class *)CLS);  \</span>
<a name="l02412"></a>02412 <span class="preprocessor">      if (s)                                            \</span>
<a name="l02413"></a>02413 <span class="preprocessor">        {                                               \</span>
<a name="l02414"></a>02414 <span class="preprocessor">          odl_add_error(s);                             \</span>
<a name="l02415"></a>02415 <span class="preprocessor">          return;                                       \</span>
<a name="l02416"></a>02416 <span class="preprocessor">        }                                               \</span>
<a name="l02417"></a>02417 <span class="preprocessor">    }</span>
<a name="l02418"></a>02418 <span class="preprocessor"></span>
<a name="l02419"></a>02419 <span class="preprocessor">#ifdef NEW_REORDER</span>
<a name="l02420"></a>02420 <span class="preprocessor"></span>  <span class="keyword">static</span> Bool
<a name="l02421"></a>02421   odl_class_need_reorder(<span class="keyword">const</span> Class *ocls,
<a name="l02422"></a>02422                          Attribute **attrs, <span class="keywordtype">int</span> attr_cnt)
<a name="l02423"></a>02423   {
<a name="l02424"></a>02424     <span class="keywordtype">int</span> onum = 0;
<a name="l02425"></a>02425     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; attr_cnt; i++)
<a name="l02426"></a>02426       {
<a name="l02427"></a>02427         <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l02428"></a>02428         <span class="keyword">const</span> Attribute *oattr;
<a name="l02429"></a>02429 
<a name="l02430"></a>02430         <span class="keywordflow">if</span> (oattr = ocls-&gt;getAttribute(attr-&gt;getName())) {
<a name="l02431"></a>02431           <span class="keywordflow">if</span> (oattr-&gt;getNum() &lt; onum) {
<a name="l02432"></a>02432             <span class="comment">//printf(&quot;%s NEEDING REORDER!\n&quot;, ocls-&gt;getName());</span>
<a name="l02433"></a>02433             <span class="keywordflow">return</span> True;
<a name="l02434"></a>02434           }
<a name="l02435"></a>02435           onum = oattr-&gt;getNum();
<a name="l02436"></a>02436         }
<a name="l02437"></a>02437       }
<a name="l02438"></a>02438 
<a name="l02439"></a>02439     <span class="comment">//printf(&quot;%s DOES NOT NEED REORDER!\n&quot;, ocls-&gt;getName());</span>
<a name="l02440"></a>02440     <span class="keywordflow">return</span> False;
<a name="l02441"></a>02441   }
<a name="l02442"></a>02442 
<a name="l02443"></a>02443   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02444"></a>02444   odl_class_premanage(Schema *m, <span class="keyword">const</span> Class *ocls, <span class="keyword">const</span> Class *cls)
<a name="l02445"></a>02445   {
<a name="l02446"></a>02446     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> invalid_num = -1;
<a name="l02447"></a>02447     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attr_cnt;
<a name="l02448"></a>02448     Attribute **attrs = (Attribute **)cls-&gt;getAttributes(attr_cnt);
<a name="l02449"></a>02449     <span class="keywordtype">int</span> i;
<a name="l02450"></a>02450 
<a name="l02451"></a>02451     COMPLETE(cls);
<a name="l02452"></a>02452     COMPLETE(ocls);
<a name="l02453"></a>02453 
<a name="l02454"></a>02454     <span class="keywordflow">if</span> (!odl_class_need_reorder(ocls, attrs, attr_cnt))
<a name="l02455"></a>02455       <span class="keywordflow">return</span>;
<a name="l02456"></a>02456 
<a name="l02457"></a>02457     <span class="comment">//</span>
<a name="l02458"></a>02458     <span class="comment">// ignore attribute reordering</span>
<a name="l02459"></a>02459     <span class="comment">//</span>
<a name="l02460"></a>02460 
<a name="l02461"></a>02461     Bool is_renum = False;
<a name="l02462"></a>02462     <span class="keywordtype">int</span> attr_num = 0;
<a name="l02463"></a>02463     <span class="keywordflow">for</span> (i = 0; i &lt; attr_cnt; i++)
<a name="l02464"></a>02464       {
<a name="l02465"></a>02465         <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l02466"></a>02466         <span class="keyword">const</span> Attribute *oattr;
<a name="l02467"></a>02467 
<a name="l02468"></a>02468         <span class="keywordflow">if</span> (oattr = ocls-&gt;getAttribute(attr-&gt;getName())) {
<a name="l02469"></a>02469           <span class="keywordflow">if</span> (odl_reorder_attr(m, cls, attr, oattr-&gt;getNum()))
<a name="l02470"></a>02470             is_renum = True;
<a name="l02471"></a>02471           attr_num++;
<a name="l02472"></a>02472         }
<a name="l02473"></a>02473         <span class="keywordflow">else</span>
<a name="l02474"></a>02474           {
<a name="l02475"></a>02475             odlUpdateHint *upd_hints = (odlUpdateHint *)attr-&gt;getUserData();
<a name="l02476"></a>02476             <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::RenameFrom)
<a name="l02477"></a>02477               {
<a name="l02478"></a>02478                 oattr = ocls-&gt;getAttribute(upd_hints-&gt;detail);
<a name="l02479"></a>02479                 <span class="keywordflow">if</span> (oattr) {
<a name="l02480"></a>02480                   <span class="keywordflow">if</span> (odl_reorder_attr(m, cls, attr, oattr-&gt;getNum()))
<a name="l02481"></a>02481                     is_renum = True;
<a name="l02482"></a>02482                   attr_num++;
<a name="l02483"></a>02483                 }
<a name="l02484"></a>02484                 <span class="keywordflow">else</span>
<a name="l02485"></a>02485                   <span class="keyword">const_cast&lt;</span>Attribute *<span class="keyword">&gt;</span>(attr)-&gt;setNum(invalid_num);
<a name="l02486"></a>02486               }
<a name="l02487"></a>02487             <span class="keywordflow">else</span>
<a name="l02488"></a>02488               <span class="keyword">const_cast&lt;</span>Attribute *<span class="keyword">&gt;</span>(attr)-&gt;setNum(invalid_num);
<a name="l02489"></a>02489           }
<a name="l02490"></a>02490       }
<a name="l02491"></a>02491 
<a name="l02492"></a>02492     <span class="keywordflow">for</span> (i = 0; i &lt; attr_cnt; i++) {
<a name="l02493"></a>02493       <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l02494"></a>02494       <span class="keywordflow">if</span> (attr-&gt;getNum() == invalid_num) {
<a name="l02495"></a>02495         <span class="keyword">const_cast&lt;</span>Attribute *<span class="keyword">&gt;</span>(attr)-&gt;setNum(attr_num++);
<a name="l02496"></a>02496         is_renum = True;
<a name="l02497"></a>02497       }
<a name="l02498"></a>02498     }
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     qsort(attrs, attr_cnt, <span class="keyword">sizeof</span>(Attribute *), cmp_attr);
<a name="l02501"></a>02501     <span class="keywordflow">if</span> (is_renum) <span class="keyword">const_cast&lt;</span>Class *<span class="keyword">&gt;</span>(cls)-&gt;compile();
<a name="l02502"></a>02502   }
<a name="l02503"></a>02503 <span class="preprocessor">#endif</span>
<a name="l02504"></a>02504 <span class="preprocessor"></span>
<a name="l02505"></a>02505   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02506"></a>02506   odl_class_compare(Schema *m, <span class="keyword">const</span> Class *ocls, <span class="keyword">const</span> Class *cls,
<a name="l02507"></a>02507                     odlUpdateHint *cls_hints)
<a name="l02508"></a>02508   {
<a name="l02509"></a>02509     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oattr_cnt, attr_cnt;
<a name="l02510"></a>02510     Attribute **oattrs = (Attribute **)ocls-&gt;getAttributes(oattr_cnt);
<a name="l02511"></a>02511     Attribute **attrs = (Attribute **)cls-&gt;getAttributes(attr_cnt);
<a name="l02512"></a>02512     <span class="keywordtype">int</span> i;
<a name="l02513"></a>02513 
<a name="l02514"></a>02514     COMPLETE(cls);
<a name="l02515"></a>02515     COMPLETE(ocls);
<a name="l02516"></a>02516 
<a name="l02517"></a>02517     <span class="comment">// check removed and converted attributes</span>
<a name="l02518"></a>02518     <span class="keywordflow">for</span> (i = 0; i &lt; oattr_cnt; i++) {
<a name="l02519"></a>02519       <span class="keyword">const</span> Attribute *oattr = oattrs[i];
<a name="l02520"></a>02520       <span class="keyword">const</span> Attribute *attr;
<a name="l02521"></a>02521       Bool migrate = False;
<a name="l02522"></a>02522 
<a name="l02523"></a>02523       odlUpdateHint *upd_hints = (odlUpdateHint *)oattr-&gt;getUserData();
<a name="l02524"></a>02524       <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::MigrateTo) {
<a name="l02525"></a>02525         migrate = True;
<a name="l02526"></a>02526         odl_migrate_attribute(m, cls, oattr, upd_hints);
<a name="l02527"></a>02527       }
<a name="l02528"></a>02528 
<a name="l02529"></a>02529       <span class="keywordflow">if</span> (!(attr = cls-&gt;getAttribute(oattr-&gt;getName()))) {
<a name="l02530"></a>02530         attr = odl_get_renamed_attr(attrs, attr_cnt, oattr);
<a name="l02531"></a>02531         <span class="keywordflow">if</span> (!attr) {
<a name="l02532"></a>02532           <span class="keywordflow">if</span> (!migrate) {
<a name="l02533"></a>02533             <span class="keywordflow">if</span> (cls_hints &amp;&amp; cls_hints-&gt;type == odlUpdateHint::Extend) {
<a name="l02534"></a>02534               <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::Remove)
<a name="l02535"></a>02535                 odl_remove_attribute(m, cls, oattr);
<a name="l02536"></a>02536             }
<a name="l02537"></a>02537             <span class="keywordflow">else</span>
<a name="l02538"></a>02538               odl_remove_attribute(m, cls, oattr);
<a name="l02539"></a>02539           }
<a name="l02540"></a>02540         }
<a name="l02541"></a>02541         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::Convert)
<a name="l02542"></a>02542           odl_convert_attribute(m, cls, oattr, attr, upd_hints);
<a name="l02543"></a>02543         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!oattr-&gt;compare(m-&gt;getDatabase(), attr,
<a name="l02544"></a>02544                                  False,  <span class="comment">// compClassOwner</span>
<a name="l02545"></a>02545                                  False,  <span class="comment">// compNum</span>
<a name="l02546"></a>02546                                  False,  <span class="comment">// compName</span>
<a name="l02547"></a>02547                                  True))  <span class="comment">// inDepth</span>
<a name="l02548"></a>02548           odl_convert_attribute(m, cls, oattr, attr);
<a name="l02549"></a>02549       }
<a name="l02550"></a>02550       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::Convert)
<a name="l02551"></a>02551         odl_convert_attribute(m, cls, oattr, attr, upd_hints);
<a name="l02552"></a>02552       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!oattr-&gt;compare(m-&gt;getDatabase(), attr,
<a name="l02553"></a>02553                                False,  <span class="comment">// compClassOwner</span>
<a name="l02554"></a>02554                                False,  <span class="comment">// compNum</span>
<a name="l02555"></a>02555                                False,  <span class="comment">// compName</span>
<a name="l02556"></a>02556                                True))  <span class="comment">// inDepth</span>
<a name="l02557"></a>02557         odl_convert_attribute(m, cls, oattr, attr);
<a name="l02558"></a>02558     }
<a name="l02559"></a>02559 
<a name="l02560"></a>02560     <span class="comment">// check added attributes</span>
<a name="l02561"></a>02561     <span class="keywordflow">for</span> (i = 0; i &lt; attr_cnt; i++) {
<a name="l02562"></a>02562       <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l02563"></a>02563       <span class="keyword">const</span> Attribute *oattr;
<a name="l02564"></a>02564       
<a name="l02565"></a>02565       <span class="keyword">const</span> <span class="keywordtype">char</span> *name = attr-&gt;getName();
<a name="l02566"></a>02566       odlUpdateHint *upd_hints = (odlUpdateHint *)attr-&gt;getUserData();
<a name="l02567"></a>02567       <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::RenameFrom) {
<a name="l02568"></a>02568         name = upd_hints-&gt;detail;
<a name="l02569"></a>02569         <span class="keywordflow">if</span> (oattr = ocls-&gt;getAttribute(name))
<a name="l02570"></a>02570           odl_rename_attribute(m, cls, attr, upd_hints);
<a name="l02571"></a>02571         <span class="keywordflow">else</span>
<a name="l02572"></a>02572           odl_add_error(<span class="stringliteral">&quot;class %s: no attribute named %s\n&quot;</span>,
<a name="l02573"></a>02573                         cls-&gt;getName(), name);
<a name="l02574"></a>02574       }
<a name="l02575"></a>02575 
<a name="l02576"></a>02576       <span class="keywordflow">if</span> (!(oattr = ocls-&gt;getAttribute(name))) {
<a name="l02577"></a>02577         <span class="keywordflow">if</span> (!upd_hints || upd_hints-&gt;type != odlUpdateHint::MigrateFrom)
<a name="l02578"></a>02578           odl_add_attribute(m, cls, attr);
<a name="l02579"></a>02579       }
<a name="l02580"></a>02580     }
<a name="l02581"></a>02581 
<a name="l02582"></a>02582     <span class="keywordflow">if</span> (odl_error) <span class="keywordflow">return</span>;
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 <span class="preprocessor">#ifndef NEW_REORDER</span>
<a name="l02585"></a>02585 <span class="preprocessor"></span>    <span class="comment">// check attribute order</span>
<a name="l02586"></a>02586     <span class="keywordtype">int</span> cnt = 0;
<a name="l02587"></a>02587     <span class="keywordflow">for</span> (i = 0; i &lt; attr_cnt; i++) {
<a name="l02588"></a>02588       <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l02589"></a>02589       <span class="keyword">const</span> Attribute *oattr;
<a name="l02590"></a>02590 
<a name="l02591"></a>02591       <span class="keywordflow">if</span> (oattr = ocls-&gt;getAttribute(attr-&gt;getName()))
<a name="l02592"></a>02592         odl_reorder_attr(m, cls, attr, oattr-&gt;getNum() + cnt);
<a name="l02593"></a>02593       <span class="keywordflow">else</span> {
<a name="l02594"></a>02594         odlUpdateHint *upd_hints = (odlUpdateHint *)attr-&gt;getUserData();
<a name="l02595"></a>02595         <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::RenameFrom) {
<a name="l02596"></a>02596           oattr = ocls-&gt;getAttribute(upd_hints-&gt;detail);
<a name="l02597"></a>02597           <span class="keywordflow">if</span> (oattr)
<a name="l02598"></a>02598             odl_reorder_attr(m, cls, attr, oattr-&gt;getNum() + cnt);
<a name="l02599"></a>02599           <span class="keywordflow">else</span>
<a name="l02600"></a>02600             cnt++;
<a name="l02601"></a>02601         }
<a name="l02602"></a>02602         <span class="keywordflow">else</span>
<a name="l02603"></a>02603           cnt++;
<a name="l02604"></a>02604       }
<a name="l02605"></a>02605     }
<a name="l02606"></a>02606 
<a name="l02607"></a>02607     <span class="comment">// ignore attribute reordering!</span>
<a name="l02608"></a>02608     qsort(attrs, attr_cnt, <span class="keyword">sizeof</span>(Attribute *), cmp_attr);
<a name="l02609"></a>02609 <span class="preprocessor">#endif</span>
<a name="l02610"></a>02610 <span class="preprocessor"></span>  }
<a name="l02611"></a>02611 
<a name="l02612"></a>02612   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02613"></a>02613   odl_class_parent_compare(Schema *m, <span class="keyword">const</span> Class *ocls, <span class="keyword">const</span> Class *cls)
<a name="l02614"></a>02614   {
<a name="l02615"></a>02615     <span class="keyword">const</span> Class *parent = cls-&gt;getParent();
<a name="l02616"></a>02616     <span class="keywordflow">if</span> (odl_rootclass &amp;&amp; !strcmp(parent-&gt;getName(), odl_rootclass))
<a name="l02617"></a>02617       parent = parent-&gt;getParent();
<a name="l02618"></a>02618     <span class="keyword">const</span> Class *oparent = ocls-&gt;getParent();
<a name="l02619"></a>02619     <span class="keywordflow">if</span> (odl_rootclass &amp;&amp; !strcmp(oparent-&gt;getName(), odl_rootclass))
<a name="l02620"></a>02620       oparent = oparent-&gt;getParent();
<a name="l02621"></a>02621 
<a name="l02622"></a>02622     <span class="comment">/*</span>
<a name="l02623"></a>02623 <span class="comment">      if (!parent-&gt;compare(oparent))</span>
<a name="l02624"></a>02624 <span class="comment">      odl_reparent_class(m, cls);</span>
<a name="l02625"></a>02625 <span class="comment">    */</span>
<a name="l02626"></a>02626 
<a name="l02627"></a>02627     <span class="keywordflow">if</span> (strcmp(parent-&gt;getName(), oparent-&gt;getName()))
<a name="l02628"></a>02628       odl_reparent_class(m, cls);
<a name="l02629"></a>02629   }
<a name="l02630"></a>02630 
<a name="l02631"></a>02631   Bool
<a name="l02632"></a>02632   odl_find_component(ClassComponent *&amp;comp, <span class="keyword">const</span> LinkedList *complist,
<a name="l02633"></a>02633                      Bool strictCheck, ClassComponent *&amp;fclcomp)
<a name="l02634"></a>02634   {
<a name="l02635"></a>02635     <span class="comment">//printf(&quot;LOOKING for component &apos;%s&apos;\n&quot;, comp-&gt;getName());</span>
<a name="l02636"></a>02636     <span class="keywordflow">if</span> (strchr(comp-&gt;getName().c_str(), <span class="charliteral">&apos;.&apos;</span>)) {
<a name="l02637"></a>02637       fclcomp = comp;
<a name="l02638"></a>02638       <span class="keywordflow">return</span> True;
<a name="l02639"></a>02639     }
<a name="l02640"></a>02640 
<a name="l02641"></a>02641     fclcomp = 0;
<a name="l02642"></a>02642     LinkedListCursor c(complist);
<a name="l02643"></a>02643     ClassComponent *tmpcomp;
<a name="l02644"></a>02644     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)tmpcomp))
<a name="l02645"></a>02645       {
<a name="l02646"></a>02646         <span class="keywordflow">if</span> (!strcmp(comp-&gt;getName().c_str(), tmpcomp-&gt;getName().c_str()))
<a name="l02647"></a>02647           {
<a name="l02648"></a>02648             <span class="keywordflow">if</span> (!comp-&gt;asAgregatClassExecutable()) {
<a name="l02649"></a>02649               fclcomp = tmpcomp;
<a name="l02650"></a>02650               <span class="keywordflow">return</span> True;
<a name="l02651"></a>02651             }
<a name="l02652"></a>02652 
<a name="l02653"></a>02653             Executable *ex = comp-&gt;asAgregatClassExecutable()-&gt;getEx();
<a name="l02654"></a>02654             Executable *tmpex = tmpcomp-&gt;asAgregatClassExecutable()-&gt;getEx();
<a name="l02655"></a>02655 
<a name="l02656"></a>02656             <span class="keywordflow">if</span> (strictCheck &amp;&amp;
<a name="l02657"></a>02657                 strcmp(ex-&gt;getExtrefBody().c_str(), tmpex-&gt;getExtrefBody().c_str()))
<a name="l02658"></a>02658               {
<a name="l02659"></a>02659                 tmpex-&gt;setExtrefBody(ex-&gt;getExtrefBody());
<a name="l02660"></a>02660                 <span class="keywordflow">if</span> ((ex-&gt;getLang() &amp; SYSTEM_EXEC) &amp;&amp; !odl_system_class)
<a name="l02661"></a>02661                   {
<a name="l02662"></a>02662                     odl_add_error(<span class="stringliteral">&quot;cannot modify system method &quot;</span>
<a name="l02663"></a>02663                                   <span class="stringliteral">&quot;&apos;%s&apos;\n&quot;</span>, comp-&gt;getName().c_str());
<a name="l02664"></a>02664                     fclcomp = tmpcomp;
<a name="l02665"></a>02665                     <span class="keywordflow">return</span> True;
<a name="l02666"></a>02666                   }
<a name="l02667"></a>02667             
<a name="l02668"></a>02668                 <span class="keywordflow">if</span> (ex-&gt;getLoc() != tmpex-&gt;getLoc()) {
<a name="l02669"></a>02669                   <span class="keywordflow">return</span> False;
<a name="l02670"></a>02670                 }
<a name="l02671"></a>02671                   
<a name="l02672"></a>02672                 comp = tmpcomp;
<a name="l02673"></a>02673                 <span class="keywordflow">return</span> False;
<a name="l02674"></a>02674               }
<a name="l02675"></a>02675             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ex-&gt;getLoc() != tmpex-&gt;getLoc()) {
<a name="l02676"></a>02676               <span class="keywordflow">return</span> False;
<a name="l02677"></a>02677             }
<a name="l02678"></a>02678 
<a name="l02679"></a>02679             fclcomp = tmpcomp;
<a name="l02680"></a>02680             <span class="keywordflow">return</span> True;
<a name="l02681"></a>02681           }
<a name="l02682"></a>02682       }
<a name="l02683"></a>02683 
<a name="l02684"></a>02684     <span class="keywordflow">if</span> (comp-&gt;asAgregatClassExecutable() &amp;&amp;
<a name="l02685"></a>02685         ((comp-&gt;asAgregatClassExecutable()-&gt;getEx()-&gt;getLang() &amp;
<a name="l02686"></a>02686           SYSTEM_EXEC) &amp;&amp; !odl_system_class)) {
<a name="l02687"></a>02687       fclcomp = comp;
<a name="l02688"></a>02688       <span class="keywordflow">return</span> True;
<a name="l02689"></a>02689     }
<a name="l02690"></a>02690 
<a name="l02691"></a>02691     <span class="keywordflow">return</span> False;
<a name="l02692"></a>02692   }
<a name="l02693"></a>02693 
<a name="l02694"></a>02694   Bool
<a name="l02695"></a>02695   odl_compare_index_hints(<span class="keyword">const</span> Index *idx1, <span class="keyword">const</span> Index *idx2)
<a name="l02696"></a>02696   {
<a name="l02697"></a>02697     <span class="keywordflow">if</span> (idx1-&gt;getImplHintsCount() != idx2-&gt;getImplHintsCount())
<a name="l02698"></a>02698       <span class="keywordflow">return</span> False;
<a name="l02699"></a>02699 
<a name="l02700"></a>02700     <span class="keywordtype">int</span> cnt = idx1-&gt;getImplHintsCount();
<a name="l02701"></a>02701     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cnt; i++) {
<a name="l02702"></a>02702       <span class="keywordflow">if</span> (idx1-&gt;getImplHints(i) &amp;&amp; idx2-&gt;getImplHints(i) &amp;&amp;
<a name="l02703"></a>02703           idx1-&gt;getImplHints(i) != idx2-&gt;getImplHints(i))
<a name="l02704"></a>02704         <span class="keywordflow">return</span> False;
<a name="l02705"></a>02705     }
<a name="l02706"></a>02706 
<a name="l02707"></a>02707     <span class="keywordflow">return</span> True;
<a name="l02708"></a>02708   }
<a name="l02709"></a>02709 
<a name="l02710"></a>02710   Bool
<a name="l02711"></a>02711   odl_compare_index(<span class="keyword">const</span> HashIndex *idx1, <span class="keyword">const</span> HashIndex *idx2)
<a name="l02712"></a>02712   {
<a name="l02713"></a>02713     <span class="keywordflow">if</span> (idx1-&gt;getKeyCount() &amp;&amp; idx2-&gt;getKeyCount() &amp;&amp;
<a name="l02714"></a>02714         idx1-&gt;getKeyCount() != idx2-&gt;getKeyCount())
<a name="l02715"></a>02715       <span class="keywordflow">return</span> False;
<a name="l02716"></a>02716 
<a name="l02717"></a>02717     <span class="keywordflow">if</span> (!const_cast&lt;HashIndex *&gt;(idx1)-&gt;compareHashMethod(const_cast&lt;HashIndex *&gt;(idx2)))
<a name="l02718"></a>02718       <span class="keywordflow">return</span> False;
<a name="l02719"></a>02719 
<a name="l02720"></a>02720     <span class="keywordflow">return</span> odl_compare_index_hints(idx1, idx2);
<a name="l02721"></a>02721   }
<a name="l02722"></a>02722 
<a name="l02723"></a>02723   Bool
<a name="l02724"></a>02724   odl_compare_index(<span class="keyword">const</span> BTreeIndex *idx1, <span class="keyword">const</span> BTreeIndex *idx2)
<a name="l02725"></a>02725   {
<a name="l02726"></a>02726     <span class="keywordflow">if</span> (idx1-&gt;getDegree() &amp;&amp; idx2-&gt;getDegree() &amp;&amp;
<a name="l02727"></a>02727         idx1-&gt;getDegree() != idx2-&gt;getDegree())
<a name="l02728"></a>02728       <span class="keywordflow">return</span> False;
<a name="l02729"></a>02729 
<a name="l02730"></a>02730     <span class="keywordflow">return</span> odl_compare_index_hints(idx1, idx2);
<a name="l02731"></a>02731   }
<a name="l02732"></a>02732 
<a name="l02733"></a>02733   AttributeComponent *
<a name="l02734"></a>02734   odl_report_index_hints(<span class="keyword">const</span> Index *idx1, Index *idx2)
<a name="l02735"></a>02735   {
<a name="l02736"></a>02736     <span class="keywordtype">int</span> cnt1 = idx1-&gt;getImplHintsCount();
<a name="l02737"></a>02737     <span class="keywordtype">int</span> cnt2 = idx2-&gt;getImplHintsCount();
<a name="l02738"></a>02738     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cnt1; i++)
<a name="l02739"></a>02739       idx2-&gt;setImplHints(i, idx1-&gt;getImplHints(i));
<a name="l02740"></a>02740 
<a name="l02741"></a>02741     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = cnt1; i &lt; cnt2; i++)
<a name="l02742"></a>02742       idx2-&gt;setImplHints(i, 0);
<a name="l02743"></a>02743 
<a name="l02744"></a>02744     <span class="keywordflow">return</span> idx2;
<a name="l02745"></a>02745   }
<a name="l02746"></a>02746 
<a name="l02747"></a>02747   AttributeComponent *
<a name="l02748"></a>02748   odl_report_index(Index *idx1, Index *idx2)
<a name="l02749"></a>02749   {
<a name="l02750"></a>02750     ObjectPeer::setOid(idx1, idx2-&gt;getOid());
<a name="l02751"></a>02751     idx1-&gt;setIdxOid(idx2-&gt;getIdxOid());
<a name="l02752"></a>02752     <span class="keywordflow">return</span> idx1;
<a name="l02753"></a>02753   }
<a name="l02754"></a>02754 
<a name="l02755"></a>02755   Bool
<a name="l02756"></a>02756   odl_find_component(AttributeComponent *&amp;comp, <span class="keyword">const</span> LinkedList *complist,
<a name="l02757"></a>02757                      Bool strictCheck, AttributeComponent *&amp;fattr_comp)
<a name="l02758"></a>02758   {
<a name="l02759"></a>02759     fattr_comp = 0;
<a name="l02760"></a>02760     LinkedListCursor c(complist);
<a name="l02761"></a>02761     AttributeComponent *tmpcomp;
<a name="l02762"></a>02762     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)tmpcomp)) {
<a name="l02763"></a>02763       <span class="keywordflow">if</span> (!strcmp(comp-&gt;getName().c_str(), tmpcomp-&gt;getName().c_str())) {
<a name="l02764"></a>02764         fattr_comp = tmpcomp;
<a name="l02765"></a>02765         <span class="keywordflow">if</span> (strictCheck) {
<a name="l02766"></a>02766           <span class="keywordflow">if</span> (comp-&gt;asIndex()) {
<a name="l02767"></a>02767             BTreeIndex *bidx = comp-&gt;asBTreeIndex();
<a name="l02768"></a>02768             BTreeIndex *tmpbidx = tmpcomp-&gt;asBTreeIndex();
<a name="l02769"></a>02769             HashIndex *hidx = comp-&gt;asHashIndex();
<a name="l02770"></a>02770             HashIndex *tmphidx = tmpcomp-&gt;asHashIndex();
<a name="l02771"></a>02771 
<a name="l02772"></a>02772             <span class="keywordflow">if</span> (hidx &amp;&amp; tmphidx) {
<a name="l02773"></a>02773               <span class="keywordflow">if</span> (odl_update_index &amp;&amp; !odl_compare_index(hidx, tmphidx)) {
<a name="l02774"></a>02774                 comp = odl_report_index(hidx, tmphidx);
<a name="l02775"></a>02775                 <span class="keywordflow">return</span> False;
<a name="l02776"></a>02776               }
<a name="l02777"></a>02777             }
<a name="l02778"></a>02778             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bidx &amp;&amp; tmpbidx) {
<a name="l02779"></a>02779               <span class="keywordflow">if</span> (odl_update_index &amp;&amp; !odl_compare_index(bidx, tmpbidx)) {
<a name="l02780"></a>02780                 comp = odl_report_index(bidx, tmpbidx);
<a name="l02781"></a>02781                 <span class="keywordflow">return</span> False;
<a name="l02782"></a>02782               }
<a name="l02783"></a>02783             }
<a name="l02784"></a>02784             <span class="keywordflow">else</span>
<a name="l02785"></a>02785               <span class="keywordflow">return</span> False;
<a name="l02786"></a>02786           }
<a name="l02787"></a>02787 
<a name="l02788"></a>02788           <span class="keywordflow">if</span> (odl_update_index &amp;&amp; comp-&gt;getPropagate() != tmpcomp-&gt;getPropagate()) {
<a name="l02789"></a>02789             tmpcomp-&gt;setPropagate(comp-&gt;getPropagate());
<a name="l02790"></a>02790             comp = tmpcomp;
<a name="l02791"></a>02791             <span class="keywordflow">return</span> False;
<a name="l02792"></a>02792           }
<a name="l02793"></a>02793         }
<a name="l02794"></a>02794 
<a name="l02795"></a>02795         <span class="keywordflow">return</span> True;
<a name="l02796"></a>02796       }
<a name="l02797"></a>02797     }
<a name="l02798"></a>02798 
<a name="l02799"></a>02799     <span class="keywordflow">return</span> False;
<a name="l02800"></a>02800   }
<a name="l02801"></a>02801 
<a name="l02802"></a>02802   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02803"></a>02803   completeInverse(Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *cname,
<a name="l02804"></a>02804                   <span class="keyword">const</span> <span class="keywordtype">char</span> *fname, <span class="keyword">const</span> Attribute *&amp;invitem)
<a name="l02805"></a>02805   {
<a name="l02806"></a>02806     <span class="keywordflow">if</span> (invitem)
<a name="l02807"></a>02807       <span class="keywordflow">return</span> 0;
<a name="l02808"></a>02808 
<a name="l02809"></a>02809     <span class="keywordflow">if</span> (cname &amp;&amp; fname)
<a name="l02810"></a>02810       {
<a name="l02811"></a>02811         <span class="keyword">const</span> Class *cls = m-&gt;getClass(cname);
<a name="l02812"></a>02812         <span class="keywordflow">if</span> (!cls)
<a name="l02813"></a>02813           {
<a name="l02814"></a>02814             odl_error++;
<a name="l02815"></a>02815             <span class="keywordflow">return</span> 1;
<a name="l02816"></a>02816           }
<a name="l02817"></a>02817 
<a name="l02818"></a>02818         invitem = cls-&gt;getAttribute(fname);
<a name="l02819"></a>02819       }
<a name="l02820"></a>02820 
<a name="l02821"></a>02821     <span class="keywordflow">return</span> 0;
<a name="l02822"></a>02822   }
<a name="l02823"></a>02823 
<a name="l02824"></a>02824   <span class="comment">//</span>
<a name="l02825"></a>02825   <span class="comment">// 17/09/01:</span>
<a name="l02826"></a>02826   <span class="comment">// THIS FUNCTION IS WRONG IF THE SCHEMA HAS EVOLVED (MORE OR LESS ATTRIBUTES</span>
<a name="l02827"></a>02827   <span class="comment">// OR RENAMED ATTRIBUTES)!!</span>
<a name="l02828"></a>02828   <span class="comment">// </span>
<a name="l02829"></a>02829 
<a name="l02830"></a>02830 <span class="preprocessor">#ifdef NEW_DIFF_RELSHIP</span>
<a name="l02831"></a>02831 <span class="preprocessor"></span>  <span class="keywordtype">int</span>
<a name="l02832"></a>02832   odl_remove_relationships(Database *, Schema *m, Class *ocls)
<a name="l02833"></a>02833   {
<a name="l02834"></a>02834     <span class="comment">// function not really pertinent</span>
<a name="l02835"></a>02835     <span class="keywordflow">if</span> (<span class="keyword">true</span>)
<a name="l02836"></a>02836       <span class="keywordflow">return</span> 0;
<a name="l02837"></a>02837 
<a name="l02838"></a>02838     <span class="keywordflow">if</span> (!ocls)
<a name="l02839"></a>02839       <span class="keywordflow">return</span> 0;
<a name="l02840"></a>02840 
<a name="l02841"></a>02841     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oattr_cnt;
<a name="l02842"></a>02842     <span class="keyword">const</span> Attribute **oattrs  = ocls-&gt;getAttributes(oattr_cnt);
<a name="l02843"></a>02843 
<a name="l02844"></a>02844     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; oattr_cnt; i++) {
<a name="l02845"></a>02845       <span class="keyword">const</span> Attribute *oattr = oattrs[i];
<a name="l02846"></a>02846 
<a name="l02847"></a>02847       <span class="keyword">const</span> <span class="keywordtype">char</span> *ocname, *ofname;
<a name="l02848"></a>02848       <span class="keyword">const</span> Attribute *oinvitem;
<a name="l02849"></a>02849 
<a name="l02850"></a>02850       oattr-&gt;getInverse(&amp;ocname, &amp;ofname, &amp;oinvitem);
<a name="l02851"></a>02851       completeInverse(m, ocname, ofname, oinvitem);
<a name="l02852"></a>02852       
<a name="l02853"></a>02853       <span class="keywordflow">if</span> (oinvitem)
<a name="l02854"></a>02854         odl_remove_relationship(m, ocls, ocls-&gt;getName(), oattr, oinvitem);
<a name="l02855"></a>02855     }
<a name="l02856"></a>02856 
<a name="l02857"></a>02857     <span class="keywordflow">return</span> 0;
<a name="l02858"></a>02858   }
<a name="l02859"></a>02859 
<a name="l02860"></a>02860 
<a name="l02861"></a>02861   <span class="keywordtype">int</span>
<a name="l02862"></a>02862   odlAgregatClass::manageDiffRelationShips(Database *, Schema *m, Bool diff)
<a name="l02863"></a>02863   {
<a name="l02864"></a>02864     <span class="keywordflow">if</span> (!ocls)
<a name="l02865"></a>02865       <span class="keywordflow">return</span> 0;
<a name="l02866"></a>02866 
<a name="l02867"></a>02867     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oattr_cnt, attr_cnt;
<a name="l02868"></a>02868     <span class="keyword">const</span> Attribute **attrs  = cls-&gt;getAttributes(attr_cnt);
<a name="l02869"></a>02869     <span class="keyword">const</span> Attribute **oattrs  = ocls-&gt;getAttributes(oattr_cnt);
<a name="l02870"></a>02870 
<a name="l02871"></a>02871     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; oattr_cnt; i++)
<a name="l02872"></a>02872       {
<a name="l02873"></a>02873         <span class="keyword">const</span> Attribute *oattr = oattrs[i];
<a name="l02874"></a>02874         <span class="keyword">const</span> Attribute *attr;
<a name="l02875"></a>02875 
<a name="l02876"></a>02876         <span class="keywordflow">if</span> (!(attr = cls-&gt;getAttribute(oattr-&gt;getName()))) {
<a name="l02877"></a>02877           <span class="keyword">const</span> <span class="keywordtype">char</span> *ocname, *ofname;
<a name="l02878"></a>02878           <span class="keyword">const</span> Attribute *oinvitem;
<a name="l02879"></a>02879 
<a name="l02880"></a>02880           oattr-&gt;getInverse(&amp;ocname, &amp;ofname, &amp;oinvitem);
<a name="l02881"></a>02881           completeInverse(m, ocname, ofname, oinvitem);
<a name="l02882"></a>02882 
<a name="l02883"></a>02883           <span class="keywordflow">if</span> (oinvitem)
<a name="l02884"></a>02884             odl_remove_relationship(m, cls, name, oattr, oinvitem);
<a name="l02885"></a>02885         }
<a name="l02886"></a>02886       }
<a name="l02887"></a>02887 
<a name="l02888"></a>02888     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; attr_cnt; i++)
<a name="l02889"></a>02889       {
<a name="l02890"></a>02890         <span class="keyword">const</span> Attribute *attr = attrs[i];
<a name="l02891"></a>02891         <span class="keyword">const</span> Attribute *oattr;
<a name="l02892"></a>02892         <span class="keyword">const</span> Attribute *invitem;
<a name="l02893"></a>02893         <span class="keyword">const</span> <span class="keywordtype">char</span> *cname, *fname;
<a name="l02894"></a>02894 
<a name="l02895"></a>02895         attr-&gt;getInverse(&amp;cname, &amp;fname, &amp;invitem);
<a name="l02896"></a>02896         completeInverse(m, cname, fname, invitem);
<a name="l02897"></a>02897 
<a name="l02898"></a>02898         <span class="keywordflow">if</span> (oattr = ocls-&gt;getAttribute(attr-&gt;getName())) {
<a name="l02899"></a>02899           <span class="keyword">const</span> <span class="keywordtype">char</span> *ocname, *ofname;
<a name="l02900"></a>02900           <span class="keyword">const</span> Attribute *oinvitem;
<a name="l02901"></a>02901 
<a name="l02902"></a>02902           oattr-&gt;getInverse(&amp;ocname, &amp;ofname, &amp;oinvitem);
<a name="l02903"></a>02903           completeInverse(m, ocname, ofname, oinvitem);
<a name="l02904"></a>02904 
<a name="l02905"></a>02905           <span class="keywordflow">if</span> (oinvitem &amp;&amp; !invitem)
<a name="l02906"></a>02906             odl_remove_relationship(m, cls, name, attr, oinvitem);
<a name="l02907"></a>02907           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (invitem &amp;&amp; !oinvitem)
<a name="l02908"></a>02908             odl_add_relationship(m, cls, name, attr, invitem);
<a name="l02909"></a>02909           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (invitem &amp;&amp; oinvitem &amp;&amp;
<a name="l02910"></a>02910                    strcmp(invitem-&gt;getName(), oinvitem-&gt;getName())) {
<a name="l02911"></a>02911             odl_remove_relationship(m, cls, name, attr, oinvitem);
<a name="l02912"></a>02912             odl_add_relationship(m, cls, name, attr, invitem);
<a name="l02913"></a>02913           }
<a name="l02914"></a>02914         }
<a name="l02915"></a>02915         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (invitem)
<a name="l02916"></a>02916           odl_add_relationship(m, cls, name, attr, invitem);
<a name="l02917"></a>02917       }
<a name="l02918"></a>02918 
<a name="l02919"></a>02919     <span class="keywordflow">return</span> 0;
<a name="l02920"></a>02920   }
<a name="l02921"></a>02921 <span class="preprocessor">#else</span>
<a name="l02922"></a>02922 <span class="preprocessor"></span>  <span class="keywordtype">int</span>
<a name="l02923"></a>02923   odlAgregatClass::manageDiffRelationShips(Schema *m, Bool diff)
<a name="l02924"></a>02924   {
<a name="l02925"></a>02925     <span class="keywordtype">int</span> attr_cnt, oattr_cnt;
<a name="l02926"></a>02926     <span class="keyword">const</span> Attribute **attrs  = cls-&gt;getAttributes(attr_cnt);
<a name="l02927"></a>02927     <span class="keyword">const</span> Attribute **oattrs = ocls-&gt;getAttributes(oattr_cnt);
<a name="l02928"></a>02928 
<a name="l02929"></a>02929     <span class="comment">//assert(attr_cnt == oattr_cnt);</span>
<a name="l02930"></a>02930     <span class="keywordtype">int</span> cnt = (attr_cnt &lt; oattr_cnt ? attr_cnt : oattr_cnt);
<a name="l02931"></a>02931 
<a name="l02932"></a>02932     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cnt; i++)
<a name="l02933"></a>02933       {
<a name="l02934"></a>02934         <span class="keyword">const</span> <span class="keywordtype">char</span> *cname, *fname, *ocname, *ofname;
<a name="l02935"></a>02935         <span class="keyword">const</span> Attribute *invitem, *oinvitem;
<a name="l02936"></a>02936 
<a name="l02937"></a>02937         attrs[i]-&gt;getInverse(&amp;cname, &amp;fname, &amp;invitem);
<a name="l02938"></a>02938         oattrs[i]-&gt;getInverse(&amp;ocname, &amp;ofname, &amp;oinvitem);
<a name="l02939"></a>02939 
<a name="l02940"></a>02940         completeInverse(m, ocname, ofname, oinvitem);
<a name="l02941"></a>02941         completeInverse(m, cname, fname, invitem);
<a name="l02942"></a>02942 
<a name="l02943"></a>02943         <span class="keywordflow">if</span> (oinvitem &amp;&amp; !invitem)
<a name="l02944"></a>02944           {
<a name="l02945"></a>02945             cls-&gt;touch();
<a name="l02946"></a>02946             odl_remove_relationship(m, name, attrs[i], oinvitem);
<a name="l02947"></a>02947           }
<a name="l02948"></a>02948         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (invitem &amp;&amp; !oinvitem)
<a name="l02949"></a>02949           {
<a name="l02950"></a>02950             cls-&gt;touch();
<a name="l02951"></a>02951             odl_add_relationship(m, name, oattrs[i], invitem);
<a name="l02952"></a>02952           }
<a name="l02953"></a>02953       }
<a name="l02954"></a>02954 
<a name="l02955"></a>02955     <span class="keywordflow">return</span> 0;
<a name="l02956"></a>02956   }
<a name="l02957"></a>02957 <span class="preprocessor">#endif</span>
<a name="l02958"></a>02958 <span class="preprocessor"></span>
<a name="l02959"></a>02959   Bool
<a name="l02960"></a>02960   odl_exec_removed(ClassComponent *comp)
<a name="l02961"></a>02961   {
<a name="l02962"></a>02962     <span class="keywordflow">if</span> (!comp)
<a name="l02963"></a>02963       <span class="keywordflow">return</span> False;
<a name="l02964"></a>02964   
<a name="l02965"></a>02965     <span class="keywordflow">if</span> (!comp-&gt;asTrigger() &amp;&amp; !comp-&gt;asMethod())
<a name="l02966"></a>02966       <span class="keywordflow">return</span> False;
<a name="l02967"></a>02967 
<a name="l02968"></a>02968     odlSignUserData *sud = (odlSignUserData *)comp-&gt;getUserData();
<a name="l02969"></a>02969     <span class="keywordflow">return</span> (sud &amp;&amp; sud-&gt;upd_hints &amp;&amp;
<a name="l02970"></a>02970             sud-&gt;upd_hints-&gt;type == odlUpdateHint::Remove ?
<a name="l02971"></a>02971             True : False);
<a name="l02972"></a>02972   }
<a name="l02973"></a>02973 
<a name="l02974"></a>02974 <span class="preprocessor">#ifdef NEW_REORDER</span>
<a name="l02975"></a>02975 <span class="preprocessor"></span>  <span class="keywordtype">int</span>
<a name="l02976"></a>02976   odlAgregatClass::preManage(Schema *m)
<a name="l02977"></a>02977   {
<a name="l02978"></a>02978     <span class="keywordflow">if</span> (odl_gencode || !m-&gt;getDatabase() || !cls)
<a name="l02979"></a>02979       <span class="keywordflow">return</span> 0;
<a name="l02980"></a>02980 
<a name="l02981"></a>02981     <span class="keywordflow">if</span> (!ocls)
<a name="l02982"></a>02982       {
<a name="l02983"></a>02983         odl_add_class(m, cls);
<a name="l02984"></a>02984         <span class="keywordflow">return</span> 0;
<a name="l02985"></a>02985       }
<a name="l02986"></a>02986 
<a name="l02987"></a>02987     <span class="comment">// added 31/05/01</span>
<a name="l02988"></a>02988     <span class="keywordflow">if</span> (agrspec == odl_Declare)
<a name="l02989"></a>02989       <span class="keywordflow">return</span> 0;
<a name="l02990"></a>02990 
<a name="l02991"></a>02991     <span class="keywordflow">if</span> (agrspec != odl_NativeClass) {
<a name="l02992"></a>02992       odl_class_premanage(m, ocls, cls);
<a name="l02993"></a>02993       <span class="keywordflow">if</span> (odl_error)
<a name="l02994"></a>02994         <span class="keywordflow">return</span> 0;
<a name="l02995"></a>02995     }
<a name="l02996"></a>02996 
<a name="l02997"></a>02997     <span class="keywordflow">return</span> 0;
<a name="l02998"></a>02998   }
<a name="l02999"></a>02999 <span class="preprocessor">#endif</span>
<a name="l03000"></a>03000 <span class="preprocessor"></span>
<a name="l03001"></a>03001   <span class="keyword">const</span> Attribute *
<a name="l03002"></a>03002   odl_getattr(<span class="keyword">const</span> Class *cls, <span class="keyword">const</span> AttributeComponent *attr_comp)
<a name="l03003"></a>03003   {
<a name="l03004"></a>03004     <span class="keywordtype">char</span> *s = strdup(attr_comp-&gt;getAttrpath().c_str());
<a name="l03005"></a>03005     <span class="keywordtype">char</span> *q = strchr(s, <span class="charliteral">&apos;.&apos;</span>);
<a name="l03006"></a>03006 
<a name="l03007"></a>03007     <span class="keywordflow">if</span> (!q) {
<a name="l03008"></a>03008       odl_add_error(<span class="stringliteral">&quot;unexpected attrpath &apos;%s&apos;\n&quot;</span>, s);
<a name="l03009"></a>03009       free(s);
<a name="l03010"></a>03010       <span class="keywordflow">return</span> 0;
<a name="l03011"></a>03011     }
<a name="l03012"></a>03012 
<a name="l03013"></a>03013     *q = 0;
<a name="l03014"></a>03014     <span class="keywordtype">char</span> *p = strchr(q+1, <span class="charliteral">&apos;.&apos;</span>);
<a name="l03015"></a>03015     <span class="keywordflow">if</span> (p) *p = 0;
<a name="l03016"></a>03016     <span class="keyword">const</span> Attribute *attr = cls-&gt;getAttribute(q+1);
<a name="l03017"></a>03017 
<a name="l03018"></a>03018     <span class="keywordflow">if</span> (!attr) {
<a name="l03019"></a>03019       odl_add_error(<span class="stringliteral">&quot;attribute %s not found in class %s\n&quot;</span>, q+1, cls-&gt;getName());
<a name="l03020"></a>03020       free(s);
<a name="l03021"></a>03021       <span class="keywordflow">return</span> 0;
<a name="l03022"></a>03022     }
<a name="l03023"></a>03023 
<a name="l03024"></a>03024     free(s);
<a name="l03025"></a>03025     <span class="keywordflow">return</span> attr;
<a name="l03026"></a>03026   }
<a name="l03027"></a>03027 
<a name="l03028"></a>03028   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03029"></a>03029   odl_remove_components(Schema *m, Class *ocls, Class *cls)
<a name="l03030"></a>03030   {
<a name="l03031"></a>03031     m-&gt;getDatabase()-&gt;transactionBegin();
<a name="l03032"></a>03032 
<a name="l03033"></a>03033     <span class="keyword">const</span> <span class="keywordtype">char</span> *name = ocls-&gt;getName();
<a name="l03034"></a>03034     <span class="keyword">const</span> LinkedList *ocomplist = ocls-&gt;getCompList();
<a name="l03035"></a>03035     LinkedListCursor oc(ocomplist);
<a name="l03036"></a>03036     ClassComponent *clcomp;
<a name="l03037"></a>03037     <span class="keywordflow">while</span> (oc.getNext((<span class="keywordtype">void</span> *&amp;)clcomp)) {
<a name="l03038"></a>03038       <span class="keywordflow">if</span> (!strcmp(clcomp-&gt;getClassOwner()-&gt;getName(), name))
<a name="l03039"></a>03039         odl_remove_component(m, clcomp);
<a name="l03040"></a>03040     }
<a name="l03041"></a>03041 
<a name="l03042"></a>03042     <span class="keyword">const</span> LinkedList *attr_ocomplist;
<a name="l03043"></a>03043     Status s = ocls-&gt;getAttrCompList(attr_ocomplist);
<a name="l03044"></a>03044     <span class="keywordflow">if</span> (s) {odl_add_error(s); <span class="keywordflow">return</span> 1;}
<a name="l03045"></a>03045 
<a name="l03046"></a>03046     AttributeComponent *attr_comp;
<a name="l03047"></a>03047     LinkedListCursor attr_oc(attr_ocomplist);
<a name="l03048"></a>03048 
<a name="l03049"></a>03049     <span class="keywordflow">while</span> (attr_oc.getNext((<span class="keywordtype">void</span> *&amp;)attr_comp)) {
<a name="l03050"></a>03050       <span class="comment">//if (!strcmp(attrcomp-&gt;getClassOwner()-&gt;getName(), name))</span>
<a name="l03051"></a>03051       AttributeComponent *cattr_comp = 0;
<a name="l03052"></a>03052       <span class="keywordflow">if</span> (ocls &amp;&amp; ocls-&gt;getDatabase() &amp;&amp;
<a name="l03053"></a>03053           attr_comp-&gt;find(ocls-&gt;getDatabase(), ocls-&gt;getParent(),
<a name="l03054"></a>03054                           cattr_comp) == Success) {
<a name="l03055"></a>03055         <span class="keywordflow">if</span> (!cattr_comp || !cattr_comp-&gt;getPropagate())
<a name="l03056"></a>03056           odl_remove_component(m, attr_comp);
<a name="l03057"></a>03057       }
<a name="l03058"></a>03058       <span class="keywordflow">else</span>
<a name="l03059"></a>03059         odl_remove_component(m, attr_comp);
<a name="l03060"></a>03060     }
<a name="l03061"></a>03061 
<a name="l03062"></a>03062     m-&gt;getDatabase()-&gt;transactionAbort();
<a name="l03063"></a>03063     <span class="keywordflow">return</span> 0;
<a name="l03064"></a>03064   }
<a name="l03065"></a>03065 
<a name="l03066"></a>03066   <span class="keywordtype">int</span>
<a name="l03067"></a>03067   odlAgregatClass::manageDifferences(Database *db, Schema *m, Bool diff)
<a name="l03068"></a>03068   {
<a name="l03069"></a>03069     <span class="keywordflow">if</span> (upd_hints &amp;&amp; upd_hints-&gt;type == odlUpdateHint::Remove &amp;&amp;
<a name="l03070"></a>03070         !odl_gencode &amp;&amp; m-&gt;getDatabase()) {
<a name="l03071"></a>03071       <span class="keywordtype">int</span> r = odl_remove_components(m, ocls, cls);
<a name="l03072"></a>03072       <span class="keywordflow">if</span> (r)
<a name="l03073"></a>03073         <span class="keywordflow">return</span> r;
<a name="l03074"></a>03074       <span class="keywordflow">return</span> odl_remove_relationships(db, m, ocls);
<a name="l03075"></a>03075     }
<a name="l03076"></a>03076 
<a name="l03077"></a>03077     <span class="keywordflow">if</span> (odl_gencode || !m-&gt;getDatabase() || !cls)
<a name="l03078"></a>03078       <span class="keywordflow">return</span> 0;
<a name="l03079"></a>03079 
<a name="l03080"></a>03080     odl_migrate_attributes(m, cls);
<a name="l03081"></a>03081     <span class="keywordflow">if</span> (!ocls) {
<a name="l03082"></a>03082 <span class="preprocessor">#ifndef NEW_REORDER</span>
<a name="l03083"></a>03083 <span class="preprocessor"></span>      odl_add_class(m, cls);
<a name="l03084"></a>03084 <span class="preprocessor">#endif</span>
<a name="l03085"></a>03085 <span class="preprocessor"></span>      <span class="keywordflow">return</span> 0;
<a name="l03086"></a>03086     }
<a name="l03087"></a>03087     
<a name="l03088"></a>03088     <span class="comment">// added 31/05/01</span>
<a name="l03089"></a>03089     <span class="keywordflow">if</span> (agrspec == odl_Declare)
<a name="l03090"></a>03090       <span class="keywordflow">return</span> 0;
<a name="l03091"></a>03091 
<a name="l03092"></a>03092     <span class="keywordflow">if</span> (agrspec != odl_NativeClass) {
<a name="l03093"></a>03093       odl_class_compare(m, ocls, cls, upd_hints);
<a name="l03094"></a>03094       <span class="keywordflow">if</span> (odl_error)
<a name="l03095"></a>03095         <span class="keywordflow">return</span> 0;
<a name="l03096"></a>03096       odl_class_parent_compare(m, ocls, cls);
<a name="l03097"></a>03097     }
<a name="l03098"></a>03098 
<a name="l03099"></a>03099     <span class="keyword">const</span> LinkedList *complist = cls-&gt;getCompList();
<a name="l03100"></a>03100     <span class="keyword">const</span> LinkedList *ocomplist = ocls-&gt;getCompList();
<a name="l03101"></a>03101 
<a name="l03102"></a>03102     LinkedListCursor oc(ocomplist);
<a name="l03103"></a>03103     LinkedListCursor c(complist);
<a name="l03104"></a>03104 
<a name="l03105"></a>03105     <span class="comment">//printf(&quot;NEW COMLIST = %d %s\n&quot;, complist-&gt;getCount(), cls-&gt;getName());</span>
<a name="l03106"></a>03106     ClassComponent *clcomp = 0, *fclcomp;
<a name="l03107"></a>03107 
<a name="l03108"></a>03108     m-&gt;getDatabase()-&gt;transactionBegin();
<a name="l03109"></a>03109 
<a name="l03110"></a>03110     <span class="keywordflow">while</span> (oc.getNext((<span class="keywordtype">void</span> *&amp;)clcomp)) {
<a name="l03111"></a>03111       <span class="keywordflow">if</span> (clcomp-&gt;getClassOwner()-&gt;compare(ocls)) {
<a name="l03112"></a>03112         <span class="keywordflow">if</span> (!odl_find_component(clcomp, complist, False, fclcomp)) {
<a name="l03113"></a>03113           <span class="keywordflow">if</span> ((!upd_hints || upd_hints-&gt;type != odlUpdateHint::Extend) &amp;&amp;
<a name="l03114"></a>03114               agrspec != odl_NativeClass)
<a name="l03115"></a>03115             odl_remove_component(m, clcomp);
<a name="l03116"></a>03116         }
<a name="l03117"></a>03117         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (odl_exec_removed(fclcomp))
<a name="l03118"></a>03118           odl_remove_component(m, clcomp);
<a name="l03119"></a>03119       }
<a name="l03120"></a>03120     }
<a name="l03121"></a>03121   
<a name="l03122"></a>03122     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)clcomp)) {
<a name="l03123"></a>03123       ClassComponent *oclcomp = clcomp;
<a name="l03124"></a>03124       <span class="keywordflow">if</span> (clcomp-&gt;getClassOwner()-&gt;compare(cls)) {
<a name="l03125"></a>03125         <span class="keywordflow">if</span> (!odl_find_component(clcomp, ocomplist, True, fclcomp)) {
<a name="l03126"></a>03126           <span class="keywordflow">if</span> (!odl_exec_removed(oclcomp))
<a name="l03127"></a>03127             odl_add_component(m, clcomp);
<a name="l03128"></a>03128           <span class="keywordflow">else</span> {
<a name="l03129"></a>03129             fprintf(stderr, <span class="stringliteral">&quot;warning: cannot remove non existing &apos;&quot;</span>);
<a name="l03130"></a>03130             clcomp-&gt;m_trace(stderr, 0, 0, NoRecurs);
<a name="l03131"></a>03131             fprintf(stderr, <span class="stringliteral">&quot;&apos;\n&quot;</span>);
<a name="l03132"></a>03132           }
<a name="l03133"></a>03133         }
<a name="l03134"></a>03134       }
<a name="l03135"></a>03135     }
<a name="l03136"></a>03136 
<a name="l03137"></a>03137     <span class="keyword">const</span> LinkedList *attr_ocomplist, *attr_complist;
<a name="l03138"></a>03138     Status s = cls-&gt;getAttrCompList(attr_complist);
<a name="l03139"></a>03139     <span class="keywordflow">if</span> (s) {odl_add_error(s); <span class="keywordflow">return</span> 1;}
<a name="l03140"></a>03140     s = ocls-&gt;getAttrCompList(attr_ocomplist);
<a name="l03141"></a>03141     <span class="keywordflow">if</span> (s) {odl_add_error(s); <span class="keywordflow">return</span> 1;}
<a name="l03142"></a>03142 
<a name="l03143"></a>03143     <span class="comment">/*</span>
<a name="l03144"></a>03144 <span class="comment">      printf(&quot;\nClass %s Attribute Component List Count=%d, Old Count=%d\n&quot;,</span>
<a name="l03145"></a>03145 <span class="comment">      cls-&gt;getName(),</span>
<a name="l03146"></a>03146 <span class="comment">      (attr_complist ? attr_complist-&gt;getCount() : -1),</span>
<a name="l03147"></a>03147 <span class="comment">      (attr_ocomplist ? attr_ocomplist-&gt;getCount() : -1));</span>
<a name="l03148"></a>03148 <span class="comment">    */</span>
<a name="l03149"></a>03149 
<a name="l03150"></a>03150     LinkedListCursor attr_oc(attr_ocomplist);
<a name="l03151"></a>03151     LinkedListCursor attr_c(attr_complist);
<a name="l03152"></a>03152 
<a name="l03153"></a>03153     AttributeComponent *attr_comp, *fattr_comp;
<a name="l03154"></a>03154     <span class="keywordtype">int</span> err = 0;
<a name="l03155"></a>03155     <span class="keywordflow">while</span> (attr_oc.getNext((<span class="keywordtype">void</span> *&amp;)attr_comp)) {
<a name="l03156"></a>03156       <span class="keywordflow">if</span> (!odl_find_component(attr_comp, attr_complist, False,
<a name="l03157"></a>03157                               fattr_comp)) {
<a name="l03158"></a>03158         <span class="keyword">const</span> Attribute *attr = odl_getattr(ocls, attr_comp);
<a name="l03159"></a>03159         <span class="keywordflow">if</span> (!attr) <span class="keywordflow">return</span> 1;
<a name="l03160"></a>03160         <span class="keywordflow">if</span> (attr = odl_is_remove_attribute(m, attr)) {
<a name="l03161"></a>03161           std::string s = std::string(<span class="stringliteral">&quot;removed attribute &apos;&quot;</span>) +
<a name="l03162"></a>03162             attr-&gt;getClassOwner()-&gt;getName () + <span class="stringliteral">&quot;::&quot;</span> + attr-&gt;getName() +
<a name="l03163"></a>03163             <span class="stringliteral">&quot;&apos; : must remove &quot;</span> +
<a name="l03164"></a>03164             (attr_comp-&gt;asIndex() ? <span class="stringliteral">&quot;index&quot;</span> : <span class="stringliteral">&quot;constraint&quot;</span>) +
<a name="l03165"></a>03165             <span class="stringliteral">&quot; &apos;&quot;</span> +  attr_comp-&gt;getAttrpath() + <span class="stringliteral">&quot;&apos; manually using &apos;&quot;</span> +
<a name="l03166"></a>03166             (attr_comp-&gt;asIndex() ? <span class="stringliteral">&quot;idxdelete&quot;</span> : <span class="stringliteral">&quot;consdelete&quot;</span>) +
<a name="l03167"></a>03167             <span class="stringliteral">&quot;&apos; before updating the schema\n&quot;</span>;
<a name="l03168"></a>03168           odl_add_error(s);
<a name="l03169"></a>03169           err++;
<a name="l03170"></a>03170         }
<a name="l03171"></a>03171         <span class="comment">// warning: odl_rmv_undef_attrcomp is not well implemented !</span>
<a name="l03172"></a>03172         <span class="keywordflow">if</span> (odl_rmv_undef_attrcomp &amp;&amp;
<a name="l03173"></a>03173             (!upd_hints || upd_hints-&gt;type != odlUpdateHint::Extend))
<a name="l03174"></a>03174           odl_remove_component(m, attr_comp);
<a name="l03175"></a>03175       }
<a name="l03176"></a>03176     }
<a name="l03177"></a>03177     <span class="keywordflow">if</span> (err) <span class="keywordflow">return</span> 1;
<a name="l03178"></a>03178 
<a name="l03179"></a>03179     LinkedList torm_list;
<a name="l03180"></a>03180 
<a name="l03181"></a>03181     <span class="keywordflow">while</span> (attr_c.getNext((<span class="keywordtype">void</span> *&amp;)attr_comp)) {
<a name="l03182"></a>03182       AttributeComponent *oattr_comp = attr_comp;
<a name="l03183"></a>03183       <span class="keywordflow">if</span> (!odl_find_component(attr_comp, attr_ocomplist, True, fattr_comp)) {
<a name="l03184"></a>03184         <span class="comment">//printf(&quot;component %s not found\n&quot;, attr_comp-&gt;getName());</span>
<a name="l03185"></a>03185         odl_add_component(m, attr_comp);
<a name="l03186"></a>03186         <span class="keyword">const</span> Attribute *attr = odl_getattr(cls, attr_comp);
<a name="l03187"></a>03187         <span class="keywordflow">if</span> (!attr) <span class="keywordflow">return</span> 1;
<a name="l03188"></a>03188         <span class="keywordflow">if</span> (odl_is_update_attribute(m, attr))
<a name="l03189"></a>03189           torm_list.insertObject(attr_comp);
<a name="l03190"></a>03190       }
<a name="l03191"></a>03191     }
<a name="l03192"></a>03192 
<a name="l03193"></a>03193     LinkedListCursor ctorm(torm_list);
<a name="l03194"></a>03194     <span class="keywordflow">while</span> (ctorm.getNext((<span class="keywordtype">void</span> *&amp;)attr_comp)) {
<a name="l03195"></a>03195       <span class="comment">//printf(&quot;XCOMP: SUPPRESSING %s\n&quot;, attr_comp-&gt;getName());</span>
<a name="l03196"></a>03196       cls-&gt;suppress(attr_comp-&gt;getInd(), attr_comp);
<a name="l03197"></a>03197     }
<a name="l03198"></a>03198 
<a name="l03199"></a>03199     <span class="keywordflow">if</span> (agrspec != odl_NativeClass &amp;&amp; !odl_error)
<a name="l03200"></a>03200       manageDiffRelationShips(db, m, diff);
<a name="l03201"></a>03201 
<a name="l03202"></a>03202     m-&gt;getDatabase()-&gt;transactionAbort();
<a name="l03203"></a>03203     <span class="keywordflow">return</span> 0;
<a name="l03204"></a>03204   }
<a name="l03205"></a>03205 
<a name="l03206"></a>03206   <span class="comment">// WARNING: this should centralized in a .h</span>
<a name="l03207"></a>03207 <span class="preprocessor">#define HASH_COEF 64</span>
<a name="l03208"></a>03208 <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_MAG_ORDER 60000</span>
<a name="l03209"></a>03209 <span class="preprocessor"></span>  <span class="comment">// .....</span>
<a name="l03210"></a>03210 
<a name="l03211"></a>03211 <span class="preprocessor">#if 0</span>
<a name="l03212"></a>03212 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l03213"></a>03213   odlImplementation::getMagOrder()<span class="keyword"> const</span>
<a name="l03214"></a>03214 <span class="keyword">  </span>{
<a name="l03215"></a>03215     <span class="keywordtype">unsigned</span> magorder;
<a name="l03216"></a>03216     <span class="keywordflow">if</span> (!strcasecmp(ident, <span class="stringliteral">&quot;btree&quot;</span>))
<a name="l03217"></a>03217       <span class="keywordflow">return</span> IDB_COLL_BIDX_MASK;
<a name="l03218"></a>03218 
<a name="l03219"></a>03219     <span class="keywordflow">if</span> (!strcasecmp(ident, <span class="stringliteral">&quot;hash&quot;</span>))
<a name="l03220"></a>03220       <span class="keywordflow">return</span> (nentries ? nentries * HASH_COEF : DEFAULT_MAG_ORDER);
<a name="l03221"></a>03221 
<a name="l03222"></a>03222     odl_add_error(<span class="stringliteral">&quot;expected keyword &apos;btree&apos; or &apos;hash&apos;, got &apos;%s&apos;&quot;</span>, ident);
<a name="l03223"></a>03223     <span class="keywordflow">return</span> 0;
<a name="l03224"></a>03224   }
<a name="l03225"></a>03225 <span class="preprocessor">#endif</span>
<a name="l03226"></a>03226 <span class="preprocessor"></span>
<a name="l03227"></a>03227   odlBool
<a name="l03228"></a>03228   odlAgregatClass::hasSimilarComp(odlAttrComponent *comp,
<a name="l03229"></a>03229                                   <span class="keyword">const</span> Class *cls2)
<a name="l03230"></a>03230   {
<a name="l03231"></a>03231     <span class="comment">//printf(&quot;ODL AGREGAT CLASS %s %s\n&quot;, cls-&gt;getName(), cls2-&gt;getName());</span>
<a name="l03232"></a>03232     odlDeclRootLink *l = decl_list-&gt;first;
<a name="l03233"></a>03233     <span class="keywordflow">while</span>(l) {
<a name="l03234"></a>03234       odlAttrComponent *xcomp = l-&gt;x-&gt;asAttrComponent();
<a name="l03235"></a>03235       <span class="keywordflow">if</span> (xcomp &amp;&amp; xcomp-&gt;similar(comp, cls, cls2))
<a name="l03236"></a>03236         <span class="keywordflow">return</span> odlTrue;
<a name="l03237"></a>03237       l = l-&gt;next;
<a name="l03238"></a>03238     }
<a name="l03239"></a>03239 
<a name="l03240"></a>03240     <span class="keywordflow">return</span> odlFalse;
<a name="l03241"></a>03241   }
<a name="l03242"></a>03242 
<a name="l03243"></a>03243   <span class="keywordtype">void</span>
<a name="l03244"></a>03244   odlAgregatClass::addComp(odlAttrComponent *comp)
<a name="l03245"></a>03245   {
<a name="l03246"></a>03246     decl_list-&gt;add(comp-&gt;clone());
<a name="l03247"></a>03247   }
<a name="l03248"></a>03248 
<a name="l03249"></a>03249   <span class="keywordtype">int</span>
<a name="l03250"></a>03250   odlAgregatClass::propagateComponents(Database *db, Schema *m)
<a name="l03251"></a>03251   {
<a name="l03252"></a>03252     odlDeclRootLink *l = decl_list-&gt;first;
<a name="l03253"></a>03253     <span class="keywordflow">if</span> (!l)
<a name="l03254"></a>03254       <span class="keywordflow">return</span> 0;
<a name="l03255"></a>03255 
<a name="l03256"></a>03256     <span class="comment">//printf(&quot;\npropagate components %s\n&quot;, cls-&gt;getAliasName());</span>
<a name="l03257"></a>03257     Class **subclasses;
<a name="l03258"></a>03258     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subclass_cnt;
<a name="l03259"></a>03259     Status s = cls-&gt;getSubClasses(subclasses, subclass_cnt);
<a name="l03260"></a>03260     <span class="keywordflow">if</span> (s) {
<a name="l03261"></a>03261       odl_add_error(s);
<a name="l03262"></a>03262       <span class="keywordflow">return</span> 1;
<a name="l03263"></a>03263     }
<a name="l03264"></a>03264 
<a name="l03265"></a>03265     <span class="keywordflow">while</span>(l) {
<a name="l03266"></a>03266       odlAttrComponent *comp = l-&gt;x-&gt;asAttrComponent();
<a name="l03267"></a>03267       <span class="keywordflow">if</span> (comp &amp;&amp; comp-&gt;propagate) {
<a name="l03268"></a>03268         <span class="comment">//printf(&quot;checking comp %s\n&quot;, comp-&gt;attrpath);</span>
<a name="l03269"></a>03269         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; subclass_cnt; i++) {
<a name="l03270"></a>03270           Class *clsx = subclasses[i];
<a name="l03271"></a>03271           <span class="keywordflow">if</span> (clsx == cls) <span class="keywordflow">continue</span>;
<a name="l03272"></a>03272           odlAgregatClass *x = (odlAgregatClass *)clsx-&gt;getUserData(odlSELF);
<a name="l03273"></a>03273           <span class="keywordflow">if</span> (x &amp;&amp; !x-&gt;hasSimilarComp(comp, cls)) {
<a name="l03274"></a>03274             <span class="comment">// warning: odl_rmv_undef_attrcomp is not well implemented !</span>
<a name="l03275"></a>03275             <span class="keywordflow">if</span> (odl_rmv_undef_attrcomp) {
<a name="l03276"></a>03276               <span class="comment">//printf(&quot;%s -&gt; %s %s\n&quot;, cls-&gt;getName(), clsx-&gt;getName(), comp-&gt;attrpath);</span>
<a name="l03277"></a>03277               odl_add_error(<span class="stringliteral">&quot;attribute component %s: &quot;</span>
<a name="l03278"></a>03278                             <span class="stringliteral">&quot;when using the -rmv-undef-attrcomp option, all the &quot;</span>
<a name="l03279"></a>03279                             <span class="stringliteral">&quot;attribute components must be defined in the ODL&quot;</span>,
<a name="l03280"></a>03280                             comp-&gt;attrpath);
<a name="l03281"></a>03281               <span class="keywordflow">return</span> 1;
<a name="l03282"></a>03282             }
<a name="l03283"></a>03283             <span class="comment">//printf(&quot;adding component %s to %s\n&quot;, comp-&gt;attrpath, clsx-&gt;getAliasName());</span>
<a name="l03284"></a>03284             x-&gt;addComp(comp);
<a name="l03285"></a>03285           }
<a name="l03286"></a>03286           <span class="comment">/*</span>
<a name="l03287"></a>03287 <span class="comment">            else</span>
<a name="l03288"></a>03288 <span class="comment">            printf(&quot;%s has a similar component %s\n&quot;, clsx-&gt;getAliasName(),</span>
<a name="l03289"></a>03289 <span class="comment">            comp-&gt;attrpath);</span>
<a name="l03290"></a>03290 <span class="comment">          */</span>
<a name="l03291"></a>03291         }
<a name="l03292"></a>03292       }
<a name="l03293"></a>03293       l = l-&gt;next;
<a name="l03294"></a>03294     }
<a name="l03295"></a>03295 
<a name="l03296"></a>03296     <span class="keywordflow">return</span> 0;
<a name="l03297"></a>03297   }
<a name="l03298"></a>03298 
<a name="l03299"></a>03299   <span class="keywordtype">int</span> odlAgregatClass::postRealize(Database *db, Schema *m,
<a name="l03300"></a>03300                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix)
<a name="l03301"></a>03301   {
<a name="l03302"></a>03302     odlDeclRootLink *l = decl_list-&gt;first;
<a name="l03303"></a>03303 
<a name="l03304"></a>03304     <span class="keywordflow">while</span>(l) {
<a name="l03305"></a>03305       <span class="keywordflow">if</span> (l-&gt;x-&gt;asAttrComponent())
<a name="l03306"></a>03306         realize(db, l-&gt;x-&gt;asAttrComponent(), m, prefix);
<a name="l03307"></a>03307       l = l-&gt;next;
<a name="l03308"></a>03308     }
<a name="l03309"></a>03309 
<a name="l03310"></a>03310     <span class="keywordflow">return</span> 0;
<a name="l03311"></a>03311   }
<a name="l03312"></a>03312 
<a name="l03313"></a>03313   <span class="keywordtype">int</span> odlAgregatClass::realize(Database *db, Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l03314"></a>03314                                <span class="keyword">const</span> <span class="keywordtype">char</span> *package, Bool diff)
<a name="l03315"></a>03315   {
<a name="l03316"></a>03316     <span class="keywordflow">if</span> (!cls)
<a name="l03317"></a>03317       <span class="keywordflow">return</span> 0;
<a name="l03318"></a>03318 
<a name="l03319"></a>03319 <span class="preprocessor">#if 0</span>
<a name="l03320"></a>03320 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> magorder = getMagOrder(cls, attr_list);
<a name="l03321"></a>03321 
<a name="l03322"></a>03322     <span class="keywordflow">if</span> (magorder)
<a name="l03323"></a>03323       cls-&gt;setMagOrder(magorder);
<a name="l03324"></a>03324 <span class="preprocessor">#endif</span>
<a name="l03325"></a>03325 <span class="preprocessor"></span>
<a name="l03326"></a>03326     Attribute **agr;
<a name="l03327"></a>03327 
<a name="l03328"></a>03328     agr = <span class="keyword">new</span> Attribute*[decl_list-&gt;count];
<a name="l03329"></a>03329     memset(agr, 0, <span class="keyword">sizeof</span>(Attribute *) * decl_list-&gt;count);
<a name="l03330"></a>03330 
<a name="l03331"></a>03331     ClassComponent **comp = <span class="keyword">new</span> ClassComponent*[decl_list-&gt;count*8];
<a name="l03332"></a>03332 
<a name="l03333"></a>03333     <span class="keywordtype">int</span> comp_cnt = 0, agr_cnt = 0;
<a name="l03334"></a>03334 
<a name="l03335"></a>03335     <span class="keywordtype">char</span> *def_extref_fe = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(package)+strlen(<span class="stringliteral">&quot;mthfe&quot;</span>)+1];
<a name="l03336"></a>03336     sprintf(def_extref_fe, <span class="stringliteral">&quot;%smthfe&quot;</span>, package);
<a name="l03337"></a>03337 
<a name="l03338"></a>03338     <span class="keywordtype">char</span> *def_extref_be = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(package)+strlen(<span class="stringliteral">&quot;mthbe&quot;</span>)+1];
<a name="l03339"></a>03339     sprintf(def_extref_be, <span class="stringliteral">&quot;%smthbe&quot;</span>, package);
<a name="l03340"></a>03340 
<a name="l03341"></a>03341     odlDeclRootLink *l = decl_list-&gt;first;
<a name="l03342"></a>03342 
<a name="l03343"></a>03343     <span class="keywordflow">while</span>(l) {
<a name="l03344"></a>03344       <span class="keywordflow">if</span> (l-&gt;x-&gt;asExecSpec()) {
<a name="l03345"></a>03345         odlBool isClient =
<a name="l03346"></a>03346           (l-&gt;x-&gt;asExecSpec()-&gt;asMethodSpec() ?
<a name="l03347"></a>03347            l-&gt;x-&gt;asExecSpec()-&gt;asMethodSpec()-&gt;mth_hints.isClient : odlFalse);
<a name="l03348"></a>03348         realize(db, m, l-&gt;x-&gt;asExecSpec(),
<a name="l03349"></a>03349                 (isClient ? def_extref_fe : def_extref_be));
<a name="l03350"></a>03350       }
<a name="l03351"></a>03351     
<a name="l03352"></a>03352       l = l-&gt;next;
<a name="l03353"></a>03353     }
<a name="l03354"></a>03354 
<a name="l03355"></a>03355     l = decl_list-&gt;first;
<a name="l03356"></a>03356 
<a name="l03357"></a>03357     <span class="keywordflow">while</span>(l) {
<a name="l03358"></a>03358       <span class="keywordflow">if</span> (l-&gt;x-&gt;asDeclItem()) {
<a name="l03359"></a>03359         realize(l-&gt;x-&gt;asDeclItem(), m, prefix, agr_cnt, comp, comp_cnt, agr);
<a name="l03360"></a>03360         agr_cnt++;
<a name="l03361"></a>03361       }
<a name="l03362"></a>03362       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (l-&gt;x-&gt;asQuotedSeq())
<a name="l03363"></a>03363         add_quoted_seq(cls, l-&gt;x-&gt;asQuotedSeq()-&gt;quoted_seq);
<a name="l03364"></a>03364 
<a name="l03365"></a>03365       l = l-&gt;next;
<a name="l03366"></a>03366     }
<a name="l03367"></a>03367 
<a name="l03368"></a>03368     <span class="keywordflow">if</span> (odl_error) {
<a name="l03369"></a>03369       <span class="keywordflow">if</span> (agrspec != odl_NativeClass &amp;&amp; agrspec != odl_Declare)
<a name="l03370"></a>03370         m-&gt;suppressClass(cls);
<a name="l03371"></a>03371       <span class="keywordflow">return</span> odl_error;
<a name="l03372"></a>03372     }
<a name="l03373"></a>03373 
<a name="l03374"></a>03374     <span class="keywordflow">if</span> (agrspec != odl_NativeClass &amp;&amp; agrspec != odl_Declare) {
<a name="l03375"></a>03375       Status status;
<a name="l03376"></a>03376       status = cls-&gt;setAttributes(agr, agr_cnt);
<a name="l03377"></a>03377 
<a name="l03378"></a>03378       <span class="keywordflow">if</span> (status) {
<a name="l03379"></a>03379         odl_add_error(status);
<a name="l03380"></a>03380         <span class="keywordflow">return</span> 0;
<a name="l03381"></a>03381       }
<a name="l03382"></a>03382     }
<a name="l03383"></a>03383   
<a name="l03384"></a>03384     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; comp_cnt; i++)
<a name="l03385"></a>03385       cls-&gt;add(comp[i]-&gt;getInd(), comp[i]);
<a name="l03386"></a>03386 
<a name="l03387"></a>03387     <span class="keywordflow">return</span> propagateComponents(db, m);
<a name="l03388"></a>03388   }
<a name="l03389"></a>03389 
<a name="l03390"></a>03390   <span class="keywordtype">int</span>
<a name="l03391"></a>03391   odlEnumClass::record(Database *, Schema *m,
<a name="l03392"></a>03392                        <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix)
<a name="l03393"></a>03393   {
<a name="l03394"></a>03394     <span class="keywordflow">if</span> (check(m, prefix))
<a name="l03395"></a>03395       odl_error++;
<a name="l03396"></a>03396 
<a name="l03397"></a>03397     cls = <span class="keyword">new</span> EnumClass(makeName(name, prefix));
<a name="l03398"></a>03398     cls-&gt;setUserData(odlGENCODE, AnyUserData);
<a name="l03399"></a>03399 
<a name="l03400"></a>03400     <span class="keywordflow">if</span> (aliasname)
<a name="l03401"></a>03401       cls-&gt;setAliasName(aliasname);
<a name="l03402"></a>03402     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (db_prefix)
<a name="l03403"></a>03403       cls-&gt;setAliasName(makeName(name, db_prefix));
<a name="l03404"></a>03404 
<a name="l03405"></a>03405     <span class="comment">// added the 17/01/01</span>
<a name="l03406"></a>03406     ocls = eyedb::getClass(m, (aliasname ? aliasname : name), prefix);
<a name="l03407"></a>03407     <span class="keywordflow">if</span> (ocls &amp;&amp; ocls != cls)
<a name="l03408"></a>03408       {
<a name="l03409"></a>03409         m-&gt;suppressClass(ocls);
<a name="l03410"></a>03410         cls-&gt;setUserData(ocls);
<a name="l03411"></a>03411         ObjectPeer::setOid(cls, ocls-&gt;getOid());
<a name="l03412"></a>03412       }
<a name="l03413"></a>03413     <span class="comment">// ...</span>
<a name="l03414"></a>03414 
<a name="l03415"></a>03415     m-&gt;addClass(cls);
<a name="l03416"></a>03416     <span class="keywordflow">if</span> (odl_system_class)
<a name="l03417"></a>03417       ClassPeer::setMType(cls, Class::System);
<a name="l03418"></a>03418     <span class="keywordflow">return</span> 0;
<a name="l03419"></a>03419   }
<a name="l03420"></a>03420 
<a name="l03421"></a>03421   <span class="keywordtype">int</span> odlEnumClass::realize(Database *db, Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l03422"></a>03422                             <span class="keyword">const</span> <span class="keywordtype">char</span> *, Bool)
<a name="l03423"></a>03423   {
<a name="l03424"></a>03424     EnumItem **en = <span class="keyword">new</span> EnumItem*[enum_list-&gt;count];
<a name="l03425"></a>03425 
<a name="l03426"></a>03426     memset(en, 0, <span class="keyword">sizeof</span>(EnumItem *) * enum_list-&gt;count);
<a name="l03427"></a>03427 
<a name="l03428"></a>03428     odlEnumItemLink *l = enum_list-&gt;first;
<a name="l03429"></a>03429   
<a name="l03430"></a>03430     <span class="keywordtype">int</span> n = 0;
<a name="l03431"></a>03431     <span class="keywordtype">int</span> lastvalue, value;
<a name="l03432"></a>03432     lastvalue = 0;
<a name="l03433"></a>03433 
<a name="l03434"></a>03434     <span class="keywordflow">while</span>(l)
<a name="l03435"></a>03435       {
<a name="l03436"></a>03436         odlEnumItem *item = l-&gt;x;
<a name="l03437"></a>03437 
<a name="l03438"></a>03438         <span class="keywordflow">if</span> (item-&gt;novalue)
<a name="l03439"></a>03439           value = lastvalue;
<a name="l03440"></a>03440         <span class="keywordflow">else</span>
<a name="l03441"></a>03441           value = item-&gt;value;
<a name="l03442"></a>03442 
<a name="l03443"></a>03443         <span class="comment">//      if (check_name(m, name, 0, item-&gt;name, prefix))</span>
<a name="l03444"></a>03444         <span class="keywordflow">if</span> (check_name(m, (aliasname ? aliasname : name), 0, item-&gt;name, prefix))
<a name="l03445"></a>03445           odl_error++;
<a name="l03446"></a>03446 
<a name="l03447"></a>03447         en[n++] = <span class="keyword">new</span> EnumItem(item-&gt;name, item-&gt;aliasname, value);
<a name="l03448"></a>03448 
<a name="l03449"></a>03449         lastvalue = value + 1;
<a name="l03450"></a>03450         l = l-&gt;next;
<a name="l03451"></a>03451       }
<a name="l03452"></a>03452 
<a name="l03453"></a>03453     Status status;
<a name="l03454"></a>03454     status = ((EnumClass *)cls)-&gt;setEnumItems(en, n);
<a name="l03455"></a>03455 
<a name="l03456"></a>03456     <span class="keywordflow">if</span> (status)
<a name="l03457"></a>03457       odl_add_error(status);
<a name="l03458"></a>03458 
<a name="l03459"></a>03459     <span class="keywordflow">return</span> 0;
<a name="l03460"></a>03460   }
<a name="l03461"></a>03461 
<a name="l03462"></a>03462   <span class="keyword">const</span> <span class="keywordtype">char</span> *odl_get_typname(<span class="keyword">const</span> <span class="keywordtype">char</span> *typname)
<a name="l03463"></a>03463   {
<a name="l03464"></a>03464     <span class="keywordflow">if</span> (!strcmp(typname, <span class="stringliteral">&quot;int&quot;</span>))
<a name="l03465"></a>03465       <span class="keywordflow">return</span> int32_class_name;
<a name="l03466"></a>03466 
<a name="l03467"></a>03467     <span class="keywordflow">if</span> (!strcmp(typname, <span class="stringliteral">&quot;short&quot;</span>))
<a name="l03468"></a>03468       <span class="keywordflow">return</span> int16_class_name;
<a name="l03469"></a>03469 
<a name="l03470"></a>03470     <span class="keywordflow">if</span> (!strcmp(typname, <span class="stringliteral">&quot;long&quot;</span>))
<a name="l03471"></a>03471       <span class="keywordflow">return</span> int64_class_name;
<a name="l03472"></a>03472 
<a name="l03473"></a>03473     <span class="keywordflow">if</span> (!strcmp(typname, <span class="stringliteral">&quot;octet&quot;</span>))
<a name="l03474"></a>03474       <span class="keywordflow">return</span> <span class="stringliteral">&quot;byte&quot;</span>;
<a name="l03475"></a>03475 
<a name="l03476"></a>03476     <span class="keywordflow">if</span> (!strcmp(typname, <span class="stringliteral">&quot;boolean&quot;</span>))
<a name="l03477"></a>03477       <span class="keywordflow">return</span> int32_class_name;
<a name="l03478"></a>03478 
<a name="l03479"></a>03479     <span class="keywordflow">if</span> (!strcmp(typname, <span class="stringliteral">&quot;double&quot;</span>))
<a name="l03480"></a>03480       <span class="keywordflow">return</span> <span class="stringliteral">&quot;float&quot;</span>;
<a name="l03481"></a>03481 
<a name="l03482"></a>03482     <span class="keywordflow">if</span> (!strcmp(typname, <span class="stringliteral">&quot;sequence&quot;</span>))
<a name="l03483"></a>03483       <span class="keywordflow">return</span> <span class="stringliteral">&quot;array&quot;</span>;
<a name="l03484"></a>03484 
<a name="l03485"></a>03485     <span class="keywordflow">return</span> typname;
<a name="l03486"></a>03486   }
<a name="l03487"></a>03487 
<a name="l03488"></a>03488   <span class="keywordtype">int</span>
<a name="l03489"></a>03489   odl_generate(Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *ofile)
<a name="l03490"></a>03490   {
<a name="l03491"></a>03491     FILE *fd;
<a name="l03492"></a>03492 
<a name="l03493"></a>03493     Class *superclass = NULL;
<a name="l03494"></a>03494     <span class="keywordflow">if</span> (odlAgregatClass::superclass)
<a name="l03495"></a>03495       {
<a name="l03496"></a>03496         superclass = m-&gt;getClass(get_superclass_name());
<a name="l03497"></a>03497         <span class="keywordflow">if</span> (odlAgregatClass::superclass-&gt;getAgregSpec() == odl_RootClass)
<a name="l03498"></a>03498           superclass-&gt;setIsRootClass();
<a name="l03499"></a>03499       }
<a name="l03500"></a>03500 
<a name="l03501"></a>03501     <span class="keywordflow">if</span> (!ofile)
<a name="l03502"></a>03502       fd = odl_fd;
<a name="l03503"></a>03503     <span class="keywordflow">else</span>
<a name="l03504"></a>03504       {
<a name="l03505"></a>03505         fd = fopen(ofile, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l03506"></a>03506         <span class="keywordflow">if</span> (!fd)
<a name="l03507"></a>03507           {
<a name="l03508"></a>03508             odl_add_error(<span class="stringliteral">&quot;cannot open file &apos;%s&apos; for reading.\n&quot;</span>,
<a name="l03509"></a>03509                           ofile);
<a name="l03510"></a>03510             <span class="keywordflow">return</span> 1;
<a name="l03511"></a>03511           }
<a name="l03512"></a>03512       }
<a name="l03513"></a>03513 
<a name="l03514"></a>03514     m-&gt;genODL(fd);
<a name="l03515"></a>03515 
<a name="l03516"></a>03516     <span class="keywordflow">return</span> 0;
<a name="l03517"></a>03517   }
<a name="l03518"></a>03518 
<a name="l03519"></a>03519   <span class="keyword">static</span> <span class="keywordtype">int</span> odl_echo;
<a name="l03520"></a>03520 
<a name="l03521"></a>03521   <span class="keywordtype">void</span>
<a name="l03522"></a>03522   odl_prompt_init(FILE *fd)
<a name="l03523"></a>03523   {
<a name="l03524"></a>03524     odl_echo = isatty(fileno(fd));
<a name="l03525"></a>03525   }
<a name="l03526"></a>03526 
<a name="l03527"></a>03527   <span class="keywordtype">void</span>
<a name="l03528"></a>03528   odl_prompt(<span class="keyword">const</span> <span class="keywordtype">char</span> *prompt)
<a name="l03529"></a>03529   {
<a name="l03530"></a>03530     <span class="keywordflow">if</span> (odl_echo)
<a name="l03531"></a>03531       {
<a name="l03532"></a>03532         fprintf(odl_fd, prompt);
<a name="l03533"></a>03533         fflush(odl_fd);
<a name="l03534"></a>03534       }
<a name="l03535"></a>03535   }
<a name="l03536"></a>03536 
<a name="l03537"></a>03537   <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03538"></a>03538   <span class="comment">//</span>
<a name="l03539"></a>03539   <span class="comment">// Database API</span>
<a name="l03540"></a>03540   <span class="comment">//</span>
<a name="l03541"></a>03541   <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03542"></a>03542 
<a name="l03543"></a>03543   <span class="keyword">static</span> Status
<a name="l03544"></a>03544   odl_post_update_non_components(Database *db, Schema *m)
<a name="l03545"></a>03545   {
<a name="l03546"></a>03546     LinkedList *list = odlUPDLIST(m);
<a name="l03547"></a>03547     LinkedListCursor c(list);
<a name="l03548"></a>03548     Status s;
<a name="l03549"></a>03549     odlUpdateItem *ci;
<a name="l03550"></a>03550     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci)) {
<a name="l03551"></a>03551       <span class="keywordflow">if</span> (ci-&gt;asUpdateComponent() ||
<a name="l03552"></a>03552           ci-&gt;asUpdateRelationship() ||
<a name="l03553"></a>03553           ci-&gt;asRemoveClass())
<a name="l03554"></a>03554         <span class="keywordflow">continue</span>;
<a name="l03555"></a>03555 
<a name="l03556"></a>03556       s = ci-&gt;postPerform(db, m);
<a name="l03557"></a>03557       <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03558"></a>03558     }
<a name="l03559"></a>03559 
<a name="l03560"></a>03560     <span class="keywordflow">return</span> Success;
<a name="l03561"></a>03561   }
<a name="l03562"></a>03562 
<a name="l03563"></a>03563   <span class="keyword">static</span> Status
<a name="l03564"></a>03564   odl_post_update_components_1(Database *db, Schema *m)
<a name="l03565"></a>03565   {
<a name="l03566"></a>03566     LinkedList *list = odlUPDLIST(m);
<a name="l03567"></a>03567     LinkedListCursor c(list);
<a name="l03568"></a>03568     Status s;
<a name="l03569"></a>03569     odlUpdateItem *ci;
<a name="l03570"></a>03570     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci)) {
<a name="l03571"></a>03571       <span class="keywordflow">if</span> (!ci-&gt;asUpdateComponent())
<a name="l03572"></a>03572         <span class="keywordflow">continue</span>;
<a name="l03573"></a>03573 
<a name="l03574"></a>03574       ClassComponent *comp = ci-&gt;asUpdateComponent()-&gt;cls_comp;
<a name="l03575"></a>03575 
<a name="l03576"></a>03576       <span class="keywordflow">if</span> (comp &amp;&amp; comp-&gt;asMethod()) {
<a name="l03577"></a>03577         s = ci-&gt;postPerform(db, m);
<a name="l03578"></a>03578         <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03579"></a>03579       }
<a name="l03580"></a>03580     }
<a name="l03581"></a>03581 
<a name="l03582"></a>03582     <span class="keywordflow">return</span> Success;
<a name="l03583"></a>03583   }
<a name="l03584"></a>03584 
<a name="l03585"></a>03585   <span class="keyword">static</span> Status
<a name="l03586"></a>03586   odl_post_update_components_2(Database *db, Schema *m)
<a name="l03587"></a>03587   {
<a name="l03588"></a>03588     LinkedList *list = odlUPDLIST(m);
<a name="l03589"></a>03589     LinkedListCursor c(list);
<a name="l03590"></a>03590     Status s;
<a name="l03591"></a>03591     odlUpdateItem *ci;
<a name="l03592"></a>03592     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci)) {
<a name="l03593"></a>03593       <span class="keywordflow">if</span> (!ci-&gt;asUpdateComponent())
<a name="l03594"></a>03594         <span class="keywordflow">continue</span>;
<a name="l03595"></a>03595 
<a name="l03596"></a>03596       ClassComponent *cls_comp = ci-&gt;asUpdateComponent()-&gt;cls_comp;
<a name="l03597"></a>03597       AttributeComponent *attr_comp = ci-&gt;asUpdateComponent()-&gt;attr_comp;
<a name="l03598"></a>03598     
<a name="l03599"></a>03599       <span class="keywordflow">if</span> ((cls_comp &amp;&amp; cls_comp-&gt;asMethod()) ||
<a name="l03600"></a>03600           (attr_comp &amp;&amp; attr_comp-&gt;asIndex()))
<a name="l03601"></a>03601         <span class="keywordflow">continue</span>;
<a name="l03602"></a>03602     
<a name="l03603"></a>03603       s = ci-&gt;postPerform(db, m);
<a name="l03604"></a>03604       <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03605"></a>03605     }
<a name="l03606"></a>03606 
<a name="l03607"></a>03607     <span class="keywordflow">return</span> Success;
<a name="l03608"></a>03608   }
<a name="l03609"></a>03609 
<a name="l03610"></a>03610   <span class="keyword">static</span> Status
<a name="l03611"></a>03611   odl_post_update_indexes(Database *db, Schema *m)
<a name="l03612"></a>03612   {
<a name="l03613"></a>03613     LinkedList *list = odlUPDLIST(m);
<a name="l03614"></a>03614     LinkedListCursor c(list);
<a name="l03615"></a>03615     odlUpdateItem *ci;
<a name="l03616"></a>03616     Status s;
<a name="l03617"></a>03617 
<a name="l03618"></a>03618     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci)) {
<a name="l03619"></a>03619       <span class="keywordflow">if</span> (!ci-&gt;asUpdateComponent())
<a name="l03620"></a>03620         <span class="keywordflow">continue</span>;
<a name="l03621"></a>03621 
<a name="l03622"></a>03622       AttributeComponent *comp = ci-&gt;asUpdateComponent()-&gt;attr_comp;
<a name="l03623"></a>03623     
<a name="l03624"></a>03624       <span class="keywordflow">if</span> (comp &amp;&amp; comp-&gt;asIndex()) {
<a name="l03625"></a>03625         s = ci-&gt;postPerform(db, m);
<a name="l03626"></a>03626         <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03627"></a>03627       }
<a name="l03628"></a>03628     }
<a name="l03629"></a>03629 
<a name="l03630"></a>03630     <span class="keywordflow">return</span> Success;
<a name="l03631"></a>03631   }
<a name="l03632"></a>03632 
<a name="l03633"></a>03633   <span class="keyword">static</span> Status
<a name="l03634"></a>03634   odl_post_update_relships(Database *db, Schema *m)
<a name="l03635"></a>03635   {
<a name="l03636"></a>03636     LinkedList *list = odlUPDLIST(m);
<a name="l03637"></a>03637     LinkedListCursor c(list);
<a name="l03638"></a>03638     Status s;
<a name="l03639"></a>03639     odlUpdateItem *ci;
<a name="l03640"></a>03640     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci)) {
<a name="l03641"></a>03641       <span class="keywordflow">if</span> (!ci-&gt;asUpdateRelationship())
<a name="l03642"></a>03642         <span class="keywordflow">continue</span>;
<a name="l03643"></a>03643 
<a name="l03644"></a>03644       <span class="keyword">const</span> Attribute *invitem = ci-&gt;asUpdateRelationship()-&gt;invitem;
<a name="l03645"></a>03645 
<a name="l03646"></a>03646       <span class="keywordflow">if</span> (!invitem)
<a name="l03647"></a>03647         <span class="keywordflow">continue</span>;
<a name="l03648"></a>03648     
<a name="l03649"></a>03649       s = ci-&gt;postPerform(db, m);
<a name="l03650"></a>03650       <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03651"></a>03651     }
<a name="l03652"></a>03652 
<a name="l03653"></a>03653     <span class="keywordflow">return</span> Success;
<a name="l03654"></a>03654   }
<a name="l03655"></a>03655 
<a name="l03656"></a>03656   <span class="keyword">static</span> Status
<a name="l03657"></a>03657   odl_post_update_remove_classes(Database *db, Schema *m)
<a name="l03658"></a>03658   {
<a name="l03659"></a>03659     LinkedList *list = odlUPDLIST(m);
<a name="l03660"></a>03660     LinkedListCursor c(list);
<a name="l03661"></a>03661     Status s;
<a name="l03662"></a>03662     odlUpdateItem *ci;
<a name="l03663"></a>03663     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci)) {
<a name="l03664"></a>03664       <span class="keywordflow">if</span> (!ci-&gt;asRemoveClass())
<a name="l03665"></a>03665         <span class="keywordflow">continue</span>;
<a name="l03666"></a>03666 
<a name="l03667"></a>03667       s = ci-&gt;postPerform(db, m);
<a name="l03668"></a>03668       <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03669"></a>03669     }
<a name="l03670"></a>03670 
<a name="l03671"></a>03671     <span class="keywordflow">return</span> Success;
<a name="l03672"></a>03672   }
<a name="l03673"></a>03673 
<a name="l03674"></a>03674   <span class="keyword">static</span> Status
<a name="l03675"></a>03675   odl_post_update_components(Database *db, Schema *m)
<a name="l03676"></a>03676   {
<a name="l03677"></a>03677     Status s;
<a name="l03678"></a>03678     s = odl_post_update_components_1(db, m);
<a name="l03679"></a>03679     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03680"></a>03680 
<a name="l03681"></a>03681     s = odl_post_update_indexes(db, m);
<a name="l03682"></a>03682     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03683"></a>03683 
<a name="l03684"></a>03684     s = odl_post_update_components_2(db, m);
<a name="l03685"></a>03685     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03686"></a>03686 
<a name="l03687"></a>03687     <span class="keywordflow">return</span> odl_post_update_relships(db, m);
<a name="l03688"></a>03688   }
<a name="l03689"></a>03689 
<a name="l03690"></a>03690   <span class="keyword">static</span> Status
<a name="l03691"></a>03691   odl_post_update_items(Database *db, Schema *m)
<a name="l03692"></a>03692   {
<a name="l03693"></a>03693     <span class="keywordflow">if</span> (odlUPDLIST(m)) {
<a name="l03694"></a>03694       Status s;
<a name="l03695"></a>03695       s = odl_post_update_non_components(db, m);
<a name="l03696"></a>03696       <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03697"></a>03697 
<a name="l03698"></a>03698       s = odl_post_update_components(db, m);
<a name="l03699"></a>03699       <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03700"></a>03700 
<a name="l03701"></a>03701       s = odl_post_update_remove_classes(db, m);
<a name="l03702"></a>03702       <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03703"></a>03703     }
<a name="l03704"></a>03704 
<a name="l03705"></a>03705     <span class="keywordflow">return</span> odl_post_update(db);
<a name="l03706"></a>03706   }
<a name="l03707"></a>03707 
<a name="l03708"></a>03708   <span class="keyword">static</span> Status
<a name="l03709"></a>03709   odl_pre_update_items(Database *db, Schema *m)
<a name="l03710"></a>03710   {
<a name="l03711"></a>03711     <span class="keywordflow">if</span> (!odlUPDLIST(m))
<a name="l03712"></a>03712       <span class="keywordflow">return</span> Success;
<a name="l03713"></a>03713 
<a name="l03714"></a>03714     LinkedList *list = odlUPDLIST(m);
<a name="l03715"></a>03715     LinkedListCursor c(list);
<a name="l03716"></a>03716     Status s;
<a name="l03717"></a>03717     odlUpdateItem *ci;
<a name="l03718"></a>03718     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci))
<a name="l03719"></a>03719       {
<a name="l03720"></a>03720         s = ci-&gt;prePerform(db, m);
<a name="l03721"></a>03721         <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03722"></a>03722       }
<a name="l03723"></a>03723 
<a name="l03724"></a>03724     <span class="keywordflow">return</span> Success;
<a name="l03725"></a>03725   }
<a name="l03726"></a>03726 
<a name="l03727"></a>03727   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03728"></a>03728   odl_diff_realize(Database *db, Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile)
<a name="l03729"></a>03729   {
<a name="l03730"></a>03730     LinkedList *list = odlUPDLIST(m);
<a name="l03731"></a>03731 
<a name="l03732"></a>03732     <span class="keywordflow">if</span> (!list)
<a name="l03733"></a>03733       <span class="keywordflow">return</span>;
<a name="l03734"></a>03734 
<a name="l03735"></a>03735     <span class="comment">//m-&gt;trace();</span>
<a name="l03736"></a>03736 
<a name="l03737"></a>03737     LinkedListCursor c(list);
<a name="l03738"></a>03738     odlUpdateItem *ci;
<a name="l03739"></a>03739     <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)ci))
<a name="l03740"></a>03740       {
<a name="l03741"></a>03741         odl_diff++;
<a name="l03742"></a>03742         ci-&gt;displayDiff(db, odlfile);
<a name="l03743"></a>03743       }
<a name="l03744"></a>03744 
<a name="l03745"></a>03745     db-&gt;transactionAbort();
<a name="l03746"></a>03746   }
<a name="l03747"></a>03747 
<a name="l03748"></a>03748 
<a name="l03749"></a>03749   <span class="keyword">static</span> <span class="keywordtype">int</span> odl_finished;
<a name="l03750"></a>03750 
<a name="l03751"></a>03751   <span class="keyword">static</span> <span class="keywordtype">void</span>  *
<a name="l03752"></a>03752   patient_thr(<span class="keywordtype">void</span> *arg)
<a name="l03753"></a>03753   {
<a name="l03754"></a>03754     <span class="keywordflow">if</span> (getenv(<span class="stringliteral">&quot;EYEDBNOPATIENT&quot;</span>)) <span class="comment">// for debugging only</span>
<a name="l03755"></a>03755       <span class="keywordflow">return</span> 0;
<a name="l03756"></a>03756 
<a name="l03757"></a>03757     sleep(4);
<a name="l03758"></a>03758     <span class="keywordflow">while</span> (!odl_finished)
<a name="l03759"></a>03759       {
<a name="l03760"></a>03760         fprintf(odl_fd, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l03761"></a>03761         fflush(odl_fd);
<a name="l03762"></a>03762         sleep(1);
<a name="l03763"></a>03763       }
<a name="l03764"></a>03764 
<a name="l03765"></a>03765     <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)0;
<a name="l03766"></a>03766   }
<a name="l03767"></a>03767 
<a name="l03768"></a>03768   <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03769"></a>03769   run_patient()
<a name="l03770"></a>03770   {
<a name="l03771"></a>03771     pthread_t tid;
<a name="l03772"></a>03772     pthread_create(&amp;tid, NULL, patient_thr, NULL);
<a name="l03773"></a>03773   }
<a name="l03774"></a>03774 
<a name="l03775"></a>03775   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03776"></a>03776   odl_update_realize(Database *db, Schema *m, <span class="keyword">const</span> <span class="keywordtype">char</span> *dbname,
<a name="l03777"></a>03777                      <span class="keyword">const</span> <span class="keywordtype">char</span> *schname)
<a name="l03778"></a>03778   {
<a name="l03779"></a>03779     odl_skip_volatiles(db, m);
<a name="l03780"></a>03780 
<a name="l03781"></a>03781     fprintf(odl_fd, <span class="stringliteral">&quot;Updating &apos;%s&apos; schema in database %s...&quot;</span>,  schname, dbname);
<a name="l03782"></a>03782     fflush(odl_fd);
<a name="l03783"></a>03783 
<a name="l03784"></a>03784     Status s;
<a name="l03785"></a>03785 
<a name="l03786"></a>03786     <span class="keywordflow">if</span> (db-&gt;getUserData() &amp;&amp; (s = m-&gt;storeName()))
<a name="l03787"></a>03787       {
<a name="l03788"></a>03788         odl_add_error(s);
<a name="l03789"></a>03789         <span class="keywordflow">return</span> 1;
<a name="l03790"></a>03790       }
<a name="l03791"></a>03791 
<a name="l03792"></a>03792     s = odl_pre_update_items(db, m);
<a name="l03793"></a>03793 
<a name="l03794"></a>03794     <span class="keywordflow">if</span> (s)
<a name="l03795"></a>03795       {
<a name="l03796"></a>03796         odl_add_error(s);
<a name="l03797"></a>03797         <span class="keywordflow">return</span> 1;
<a name="l03798"></a>03798       }
<a name="l03799"></a>03799 
<a name="l03800"></a>03800     run_patient();
<a name="l03801"></a>03801     s = m-&gt;realize();
<a name="l03802"></a>03802 
<a name="l03803"></a>03803     <span class="keywordflow">if</span> (s)
<a name="l03804"></a>03804       {
<a name="l03805"></a>03805         odl_add_error(s);
<a name="l03806"></a>03806         <span class="keywordflow">return</span> 1;
<a name="l03807"></a>03807       }
<a name="l03808"></a>03808 
<a name="l03809"></a>03809     s = odl_post_update_items(db, m);
<a name="l03810"></a>03810 
<a name="l03811"></a>03811     <span class="keywordflow">if</span> (s)
<a name="l03812"></a>03812       {
<a name="l03813"></a>03813         odl_add_error(s);
<a name="l03814"></a>03814         <span class="keywordflow">return</span> 1;
<a name="l03815"></a>03815       }
<a name="l03816"></a>03816 
<a name="l03817"></a>03817     <span class="keywordflow">if</span> (!getenv(<span class="stringliteral">&quot;EYEDBABORT&quot;</span>))
<a name="l03818"></a>03818       s = db-&gt;transactionCommit();
<a name="l03819"></a>03819     odl_finished = 1;
<a name="l03820"></a>03820 
<a name="l03821"></a>03821     <span class="keywordflow">if</span> (s)
<a name="l03822"></a>03822       {
<a name="l03823"></a>03823         odl_add_error(s);
<a name="l03824"></a>03824         <span class="keywordflow">return</span> 1;
<a name="l03825"></a>03825       }
<a name="l03826"></a>03826 
<a name="l03827"></a>03827     fprintf(odl_fd, <span class="stringliteral">&quot;\nDone\n&quot;</span>);
<a name="l03828"></a>03828 
<a name="l03829"></a>03829     <span class="keywordflow">return</span> 0;
<a name="l03830"></a>03830   }
<a name="l03831"></a>03831 
<a name="l03832"></a>03832   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03833"></a>03833   check_odlfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l03834"></a>03834   {
<a name="l03835"></a>03835     odl_decl_list = <span class="keyword">new</span> LinkedList();
<a name="l03836"></a>03836 
<a name="l03837"></a>03837     <span class="keywordflow">if</span> (file) {
<a name="l03838"></a>03838       FILE *fd;
<a name="l03839"></a>03839       
<a name="l03840"></a>03840       <span class="keywordflow">if</span> (!strcmp(file, <span class="stringliteral">&quot;-&quot;</span>))
<a name="l03841"></a>03841         odlin = stdin;
<a name="l03842"></a>03842       <span class="keywordflow">else</span> {
<a name="l03843"></a>03843         fd = fopen(file, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l03844"></a>03844         <span class="keywordflow">if</span> (!fd) {
<a name="l03845"></a>03845           odl_add_error(<span class="stringliteral">&quot;cannot open file &apos;%s&apos; for reading\n&quot;</span>,
<a name="l03846"></a>03846                         file);
<a name="l03847"></a>03847           <span class="keywordflow">return</span> 1;
<a name="l03848"></a>03848         }
<a name="l03849"></a>03849 
<a name="l03850"></a>03850         <span class="keywordflow">if</span> (odlin &amp;&amp; odlin != stdin)
<a name="l03851"></a>03851           fclose(odlin);
<a name="l03852"></a>03852         
<a name="l03853"></a>03853         odlin = run_cpp(fd, cpp_cmd, cpp_flags, file);
<a name="l03854"></a>03854         <span class="keywordflow">if</span> (!odlin)
<a name="l03855"></a>03855           <span class="keywordflow">return</span> 1;
<a name="l03856"></a>03856       }
<a name="l03857"></a>03857     }
<a name="l03858"></a>03858 
<a name="l03859"></a>03859     <span class="keywordflow">if</span> (file) {
<a name="l03860"></a>03860       odl_prompt_init(odlin);
<a name="l03861"></a>03861       odl_prompt(<span class="stringliteral">&quot;ODL construct expected on standard input (end input by a ^D) :\n&quot;</span>);
<a name="l03862"></a>03862       odl_prompt();
<a name="l03863"></a>03863     }
<a name="l03864"></a>03864   
<a name="l03865"></a>03865     <span class="keywordflow">return</span> 0;
<a name="l03866"></a>03866   }
<a name="l03867"></a>03867 
<a name="l03868"></a>03868   <span class="comment">/*</span>
<a name="l03869"></a>03869 <span class="comment">    static Status</span>
<a name="l03870"></a>03870 <span class="comment">    x_transaction_begin(Database *db)</span>
<a name="l03871"></a>03871 <span class="comment">    {</span>
<a name="l03872"></a>03872 <span class="comment">    TransactionParams params = Database::getGlobalDefaultTransactionParams();</span>
<a name="l03873"></a>03873 <span class="comment">    params.lockmode = DatabaseX;</span>
<a name="l03874"></a>03874 <span class="comment">    params.wait_timeout = 1;</span>
<a name="l03875"></a>03875 <span class="comment"></span>
<a name="l03876"></a>03876 <span class="comment">    Status s = db-&gt;transactionBegin(params);</span>
<a name="l03877"></a>03877 <span class="comment">    if (s) {</span>
<a name="l03878"></a>03878 <span class="comment">    if (s-&gt;getStatus() == SE_LOCK_TIMEOUT) {</span>
<a name="l03879"></a>03879 <span class="comment">    fprintf(stderr,</span>
<a name="l03880"></a>03880 <span class="comment">    &quot;cannot acquire exclusive lock on database %s\n&quot;,</span>
<a name="l03881"></a>03881 <span class="comment">    db-&gt;getName());</span>
<a name="l03882"></a>03882 <span class="comment">    exit(1);</span>
<a name="l03883"></a>03883 <span class="comment">    }</span>
<a name="l03884"></a>03884 <span class="comment">    }</span>
<a name="l03885"></a>03885 <span class="comment"></span>
<a name="l03886"></a>03886 <span class="comment">    return s;</span>
<a name="l03887"></a>03887 <span class="comment">    }</span>
<a name="l03888"></a>03888 <span class="comment">  */</span>
<a name="l03889"></a>03889 
<a name="l03890"></a>03890   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03891"></a>03891   odl_check_db(Database *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *&amp;schname, <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l03892"></a>03892                Schema *&amp;m, Bool update = False)
<a name="l03893"></a>03893   {
<a name="l03894"></a>03894     <span class="keywordflow">if</span> (!schname)
<a name="l03895"></a>03895       schname = package;
<a name="l03896"></a>03896 
<a name="l03897"></a>03897     <span class="keywordflow">if</span> (db) {
<a name="l03898"></a>03898       Status s;
<a name="l03899"></a>03899       Exception::Mode mode =
<a name="l03900"></a>03900         <a class="code" href="classeyedb_1_1Exception.html#a6593ce9ad1bc7686290829fe1fa15cd4" title="Not yet documented.">Exception::setMode</a>(Exception::StatusMode);
<a name="l03901"></a>03901 
<a name="l03902"></a>03902       <span class="keywordflow">if</span> (update)
<a name="l03903"></a>03903         s = db-&gt;transactionBeginExclusive();
<a name="l03904"></a>03904       <span class="keywordflow">else</span>
<a name="l03905"></a>03905         s = db-&gt;transactionBegin();
<a name="l03906"></a>03906 
<a name="l03907"></a>03907       <span class="keywordflow">if</span> (s) {
<a name="l03908"></a>03908         odl_add_error(s);
<a name="l03909"></a>03909         <span class="keywordflow">return</span> 1;
<a name="l03910"></a>03910       }
<a name="l03911"></a>03911 
<a name="l03912"></a>03912       <a class="code" href="classeyedb_1_1Exception.html#a6593ce9ad1bc7686290829fe1fa15cd4" title="Not yet documented.">Exception::setMode</a>(mode);
<a name="l03913"></a>03913       m = db-&gt;getSchema();
<a name="l03914"></a>03914       <span class="keywordflow">if</span> (strcmp(m-&gt;getName(), schname))
<a name="l03915"></a>03915         db-&gt;setUserData(AnyUserData);
<a name="l03916"></a>03916 
<a name="l03917"></a>03917       LinkedListCursor c(m-&gt;getClassList());
<a name="l03918"></a>03918       Class *cls;
<a name="l03919"></a>03919       <span class="keywordflow">while</span> (c.getNext((<span class="keywordtype">void</span> *&amp;)cls))
<a name="l03920"></a>03920         <span class="keywordflow">if</span> (!cls-&gt;isSystem())
<a name="l03921"></a>03921           cls-&gt;setUserData(odlGENCODE, AnyUserData);
<a name="l03922"></a>03922     }
<a name="l03923"></a>03923     <span class="keywordflow">else</span> {
<a name="l03924"></a>03924       m = <span class="keyword">new</span> Schema();
<a name="l03925"></a>03925       m-&gt;init();
<a name="l03926"></a>03926       syscls::updateSchema(m);
<a name="l03927"></a>03927       oqlctb::updateSchema(m);
<a name="l03928"></a>03928       utils::updateSchema(m);
<a name="l03929"></a>03929     }
<a name="l03930"></a>03930     
<a name="l03931"></a>03931     m-&gt;setName(schname);
<a name="l03932"></a>03932     <span class="keywordflow">return</span> 0;
<a name="l03933"></a>03933   }
<a name="l03934"></a>03934 
<a name="l03935"></a>03935   Status
<a name="l03936"></a>03936   odl_prelim(Database *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile, <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l03937"></a>03937              <span class="keyword">const</span> <span class="keywordtype">char</span> *&amp;schname, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l03938"></a>03938              Bool diff, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd,  <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags,
<a name="l03939"></a>03939              Schema *&amp;m, Bool update = False)
<a name="l03940"></a>03940   {
<a name="l03941"></a>03941     odl_error = 0;
<a name="l03942"></a>03942     odl_str_error = <span class="stringliteral">&quot;&quot;</span>;
<a name="l03943"></a>03943 
<a name="l03944"></a>03944     <span class="keywordtype">int</span> r;
<a name="l03945"></a>03945     r = odl_check_db(db, schname, package, m, update);
<a name="l03946"></a>03946     <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l03947"></a>03947 
<a name="l03948"></a>03948     r = check_odlfile(odlfile, cpp_cmd, cpp_flags);
<a name="l03949"></a>03949 
<a name="l03950"></a>03950     <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l03951"></a>03951 
<a name="l03952"></a>03952     <span class="keywordflow">if</span> (odlfile) {
<a name="l03953"></a>03953       r = odlparse();
<a name="l03954"></a>03954       <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l03955"></a>03955     }
<a name="l03956"></a>03956 
<a name="l03957"></a>03957     odl_realize(db, m, odl_decl_list, prefix, db_prefix, package, diff);
<a name="l03958"></a>03958 
<a name="l03959"></a>03959     <span class="keywordflow">return</span> odl_status_error();
<a name="l03960"></a>03960   }
<a name="l03961"></a>03961 
<a name="l03962"></a>03962   Status
<a name="l03963"></a>03963   Database::updateSchema(<span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile, <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l03964"></a>03964                          <span class="keyword">const</span> <span class="keywordtype">char</span> *schname, <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l03965"></a>03965                          FILE *fd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd,
<a name="l03966"></a>03966                          <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l03967"></a>03967   {
<a name="l03968"></a>03968     odl_fd = (fd ? fd : odl_fdnull);
<a name="l03969"></a>03969     Schema *m;
<a name="l03970"></a>03970     Status s;
<a name="l03971"></a>03971     s = odl_prelim(<span class="keyword">this</span>, odlfile, package, schname, db_prefix, db_prefix,
<a name="l03972"></a>03972                    False, cpp_cmd, cpp_flags, m, True);
<a name="l03973"></a>03973     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03974"></a>03974 
<a name="l03975"></a>03975     odl_update_realize(<span class="keyword">this</span>, sch, name, schname);
<a name="l03976"></a>03976     <span class="keywordflow">return</span> odl_status_error();
<a name="l03977"></a>03977   }
<a name="l03978"></a>03978 
<a name="l03979"></a>03979   Status
<a name="l03980"></a>03980   Schema::displaySchemaDiff(Database *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile,
<a name="l03981"></a>03981                             <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l03982"></a>03982                             <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l03983"></a>03983                             FILE *fd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd,
<a name="l03984"></a>03984                             <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l03985"></a>03985   {
<a name="l03986"></a>03986     odl_fd = (fd ? fd : odl_fdnull);
<a name="l03987"></a>03987     <a class="code" href="classeyedb_1_1Schema.html#a26e982852f4294fb1f8d751d532de93c" title="Not yet documented.">Schema</a> *m;
<a name="l03988"></a>03988     <span class="keyword">const</span> <span class="keywordtype">char</span> *schname = <span class="stringliteral">&quot;&quot;</span>;
<a name="l03989"></a>03989     Status s;
<a name="l03990"></a>03990     s =  odl_prelim(db, odlfile, package, schname, db_prefix, db_prefix,
<a name="l03991"></a>03991                     True, cpp_cmd, cpp_flags, m);
<a name="l03992"></a>03992     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l03993"></a>03993     <span class="keywordflow">if</span> (odl_error) <span class="keywordflow">return</span> odl_status_error();
<a name="l03994"></a>03994     odl_diff_realize(db, m, odlfile);
<a name="l03995"></a>03995     <span class="keywordflow">return</span> odl_status_error();
<a name="l03996"></a>03996   }
<a name="l03997"></a>03997 
<a name="l03998"></a>03998 <span class="preprocessor">#ifdef SUPPORT_CORBA</span>
<a name="l03999"></a>03999 <span class="preprocessor"></span>  Status
<a name="l04000"></a>04000   Schema::genIDL(Database *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile,
<a name="l04001"></a>04001                  <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l04002"></a>04002                  <span class="keyword">const</span> <span class="keywordtype">char</span> *module,
<a name="l04003"></a>04003                  <span class="keyword">const</span> <span class="keywordtype">char</span> *schname,
<a name="l04004"></a>04004                  <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l04005"></a>04005                  <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l04006"></a>04006                  <span class="keyword">const</span> <span class="keywordtype">char</span> *idltarget,
<a name="l04007"></a>04007                  <span class="keyword">const</span> <span class="keywordtype">char</span> *imdlfile,
<a name="l04008"></a>04008                  Bool no_generic_idl,
<a name="l04009"></a>04009                  <span class="keyword">const</span> <span class="keywordtype">char</span> *generic_idl,
<a name="l04010"></a>04010                  Bool no_factory,
<a name="l04011"></a>04011                  Bool imdl_synchro,
<a name="l04012"></a>04012                  GenCodeHints *gc_hints,
<a name="l04013"></a>04013                  Bool comments,
<a name="l04014"></a>04014                  <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags,
<a name="l04015"></a>04015                  <span class="keyword">const</span> <span class="keywordtype">char</span> *ofile)
<a name="l04016"></a>04016   {
<a name="l04017"></a>04017     <span class="keywordflow">if</span> (!gc_hints) gc_hints = <span class="keyword">new</span> GenCodeHints();
<a name="l04018"></a>04018     <a class="code" href="classeyedb_1_1Schema.html#a26e982852f4294fb1f8d751d532de93c" title="Not yet documented.">Schema</a> *m;
<a name="l04019"></a>04019     Status s;
<a name="l04020"></a>04020     s = odl_prelim(db, odlfile, package, schname, prefix, db_prefix,
<a name="l04021"></a>04021                    False, cpp_cmd, cpp_flags, m);
<a name="l04022"></a>04022     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l04023"></a>04023 
<a name="l04024"></a>04024     imdl_realize(db, m, package, module, False, False,
<a name="l04025"></a>04025                  schname, prefix,
<a name="l04026"></a>04026                  db_prefix, cpp_cmd, cpp_flags,
<a name="l04027"></a>04027                  idltarget, imdlfile,
<a name="l04028"></a>04028                  no_generic_idl, generic_idl,
<a name="l04029"></a>04029                  no_factory, imdl_synchro, gc_hints, comments,
<a name="l04030"></a>04030                  ofile);
<a name="l04031"></a>04031 
<a name="l04032"></a>04032     <span class="keywordflow">return</span> odl_status_error();
<a name="l04033"></a>04033   }
<a name="l04034"></a>04034 
<a name="l04035"></a>04035   Status
<a name="l04036"></a>04036   Schema::genORB(<span class="keyword">const</span> <span class="keywordtype">char</span> *orb,
<a name="l04037"></a>04037                  Database *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile,
<a name="l04038"></a>04038                  <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l04039"></a>04039                  <span class="keyword">const</span> <span class="keywordtype">char</span> *module,
<a name="l04040"></a>04040                  <span class="keyword">const</span> <span class="keywordtype">char</span> *schname,
<a name="l04041"></a>04041                  <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l04042"></a>04042                  <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l04043"></a>04043                  <span class="keyword">const</span> <span class="keywordtype">char</span> *idltarget,
<a name="l04044"></a>04044                  <span class="keyword">const</span> <span class="keywordtype">char</span> *imdlfile,
<a name="l04045"></a>04045                  Bool no_generic_idl,
<a name="l04046"></a>04046                  <span class="keyword">const</span> <span class="keywordtype">char</span> *generic_idl,
<a name="l04047"></a>04047                  Bool no_factory,
<a name="l04048"></a>04048                  Bool imdl_synchro,
<a name="l04049"></a>04049                  GenCodeHints *gc_hints,
<a name="l04050"></a>04050                  Bool comments,
<a name="l04051"></a>04051                  <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l04052"></a>04052   {
<a name="l04053"></a>04053     <span class="keywordflow">if</span> (!gc_hints) gc_hints = <span class="keyword">new</span> GenCodeHints();
<a name="l04054"></a>04054     <a class="code" href="classeyedb_1_1Schema.html#a26e982852f4294fb1f8d751d532de93c" title="Not yet documented.">Schema</a> *m;
<a name="l04055"></a>04055     Status s;
<a name="l04056"></a>04056     s = odl_prelim(db, odlfile, package, schname, prefix, db_prefix,
<a name="l04057"></a>04057                    False, cpp_cmd, cpp_flags, m);
<a name="l04058"></a>04058     <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l04059"></a>04059 
<a name="l04060"></a>04060     Bool orbix_gen, orbacus_gen;
<a name="l04061"></a>04061     <span class="keywordflow">if</span> (!strcasecmp(orb, <span class="stringliteral">&quot;orbix&quot;</span>))
<a name="l04062"></a>04062       {
<a name="l04063"></a>04063         orbix_gen = True;
<a name="l04064"></a>04064         orbacus_gen = False;
<a name="l04065"></a>04065       }
<a name="l04066"></a>04066     <span class="keywordflow">else</span>
<a name="l04067"></a>04067       {
<a name="l04068"></a>04068         orbix_gen = False;
<a name="l04069"></a>04069         orbacus_gen = True;
<a name="l04070"></a>04070       }
<a name="l04071"></a>04071 
<a name="l04072"></a>04072     imdl_realize(db, m, package, module, orbix_gen, orbacus_gen,
<a name="l04073"></a>04073                  schname, prefix,
<a name="l04074"></a>04074                  db_prefix, cpp_cmd, cpp_flags,
<a name="l04075"></a>04075                  idltarget, imdlfile,
<a name="l04076"></a>04076                  no_generic_idl, generic_idl,
<a name="l04077"></a>04077                  no_factory, imdl_synchro, gc_hints, comments, 0);
<a name="l04078"></a>04078 
<a name="l04079"></a>04079     <span class="keywordflow">return</span> odl_status_error();
<a name="l04080"></a>04080   }
<a name="l04081"></a>04081 <span class="preprocessor">#endif</span>
<a name="l04082"></a>04082 <span class="preprocessor"></span>
<a name="l04083"></a>04083   Status
<a name="l04084"></a>04084   Schema::genC_API(Database *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile,
<a name="l04085"></a>04085                    <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l04086"></a>04086                    <span class="keyword">const</span> <span class="keywordtype">char</span> *schname,
<a name="l04087"></a>04087                    <span class="keyword">const</span> <span class="keywordtype">char</span> *c_namespace,
<a name="l04088"></a>04088                    <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l04089"></a>04089                    <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l04090"></a>04090                    Bool _export,
<a name="l04091"></a>04091                    GenCodeHints *gc_hints,
<a name="l04092"></a>04092                    <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l04093"></a>04093   {
<a name="l04094"></a>04094     odl_error = 0;
<a name="l04095"></a>04095     odl_str_error = <span class="stringliteral">&quot;&quot;</span>;
<a name="l04096"></a>04096 
<a name="l04097"></a>04097     <span class="keywordflow">if</span> (!gc_hints) gc_hints = <span class="keyword">new</span> GenCodeHints();
<a name="l04098"></a>04098     <a class="code" href="classeyedb_1_1Schema.html#a26e982852f4294fb1f8d751d532de93c" title="Not yet documented.">Schema</a> *m;
<a name="l04099"></a>04099     odl_check_db(db, schname, package, m);
<a name="l04100"></a>04100 
<a name="l04101"></a>04101     <span class="keywordtype">int</span> r = check_odlfile(odlfile, cpp_cmd, cpp_flags);
<a name="l04102"></a>04102 
<a name="l04103"></a>04103     <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l04104"></a>04104 
<a name="l04105"></a>04105     <span class="keywordflow">if</span> (odlfile)
<a name="l04106"></a>04106       {
<a name="l04107"></a>04107         r = odlparse();
<a name="l04108"></a>04108         <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l04109"></a>04109       }
<a name="l04110"></a>04110 
<a name="l04111"></a>04111     odl_generate_code(db, m, ProgLang_C,
<a name="l04112"></a>04112                       odl_decl_list,
<a name="l04113"></a>04113                       package,
<a name="l04114"></a>04114                       schname,
<a name="l04115"></a>04115                       c_namespace,
<a name="l04116"></a>04116                       prefix,
<a name="l04117"></a>04117                       db_prefix,
<a name="l04118"></a>04118                       _export,
<a name="l04119"></a>04119                       *gc_hints);
<a name="l04120"></a>04120 
<a name="l04121"></a>04121     <span class="keywordflow">return</span> odl_status_error();
<a name="l04122"></a>04122   }
<a name="l04123"></a>04123 
<a name="l04124"></a>04124   Status
<a name="l04125"></a>04125   Schema::genJava_API(Database *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile,
<a name="l04126"></a>04126                       <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l04127"></a>04127                       <span class="keyword">const</span> <span class="keywordtype">char</span> *schname,
<a name="l04128"></a>04128                       <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l04129"></a>04129                       <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l04130"></a>04130                       Bool _export,
<a name="l04131"></a>04131                       GenCodeHints *gc_hints,
<a name="l04132"></a>04132                       <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l04133"></a>04133   {
<a name="l04134"></a>04134     <span class="keywordflow">if</span> (!gc_hints) gc_hints = <span class="keyword">new</span> GenCodeHints();
<a name="l04135"></a>04135     <a class="code" href="classeyedb_1_1Schema.html#a26e982852f4294fb1f8d751d532de93c" title="Not yet documented.">Schema</a> *m;
<a name="l04136"></a>04136     Status s;
<a name="l04137"></a>04137 
<a name="l04138"></a>04138     odl_check_db(db, schname, package, m);
<a name="l04139"></a>04139 
<a name="l04140"></a>04140     <span class="keywordtype">int</span> r = check_odlfile(odlfile, cpp_cmd, cpp_flags);
<a name="l04141"></a>04141 
<a name="l04142"></a>04142     <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l04143"></a>04143 
<a name="l04144"></a>04144     <span class="keywordflow">if</span> (odlfile)
<a name="l04145"></a>04145       {
<a name="l04146"></a>04146         r = odlparse();
<a name="l04147"></a>04147         <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l04148"></a>04148       }
<a name="l04149"></a>04149 
<a name="l04150"></a>04150     odl_generate_code(db, m, ProgLang_Java,
<a name="l04151"></a>04151                       odl_decl_list,
<a name="l04152"></a>04152                       package,
<a name="l04153"></a>04153                       schname,
<a name="l04154"></a>04154                       NULL,
<a name="l04155"></a>04155                       prefix,
<a name="l04156"></a>04156                       db_prefix,
<a name="l04157"></a>04157                       _export,
<a name="l04158"></a>04158                       *gc_hints);
<a name="l04159"></a>04159 
<a name="l04160"></a>04160     <span class="keywordflow">return</span> odl_status_error();
<a name="l04161"></a>04161   }
<a name="l04162"></a>04162 
<a name="l04163"></a>04163   Status
<a name="l04164"></a>04164   Schema::checkODL(<span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile, <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l04165"></a>04165                    <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l04166"></a>04166   {
<a name="l04167"></a>04167     odl_error = 0;
<a name="l04168"></a>04168     odl_str_error = <span class="stringliteral">&quot;&quot;</span>;
<a name="l04169"></a>04169 
<a name="l04170"></a>04170     <a class="code" href="classeyedb_1_1Schema.html#a26e982852f4294fb1f8d751d532de93c" title="Not yet documented.">Schema</a> *m;
<a name="l04171"></a>04171     <span class="keyword">const</span> <span class="keywordtype">char</span> *schname = <span class="stringliteral">&quot;&quot;</span>;
<a name="l04172"></a>04172     <span class="keywordflow">return</span> odl_prelim(0, odlfile, package, schname, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,
<a name="l04173"></a>04173                       False, cpp_cmd, cpp_flags, m);
<a name="l04174"></a>04174   }
<a name="l04175"></a>04175 
<a name="l04176"></a>04176   Status
<a name="l04177"></a>04177   <a class="code" href="classeyedb_1_1Schema.html#a3dab1ad0a71cf4f371db2dc3398a0603" title="Not yet documented.">Schema::genODL</a>(Database *db,
<a name="l04178"></a>04178                  <span class="keyword">const</span> <span class="keywordtype">char</span> *odlfile,
<a name="l04179"></a>04179                  <span class="keyword">const</span> <span class="keywordtype">char</span> *package,
<a name="l04180"></a>04180                  <span class="keyword">const</span> <span class="keywordtype">char</span> *schname,
<a name="l04181"></a>04181                  <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l04182"></a>04182                  <span class="keyword">const</span> <span class="keywordtype">char</span> *db_prefix,
<a name="l04183"></a>04183                  <span class="keyword">const</span> <span class="keywordtype">char</span> *ofile,
<a name="l04184"></a>04184                  <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_cmd, <span class="keyword">const</span> <span class="keywordtype">char</span> *cpp_flags)
<a name="l04185"></a>04185   {
<a name="l04186"></a>04186     odl_error = 0;
<a name="l04187"></a>04187     odl_str_error = <span class="stringliteral">&quot;&quot;</span>;
<a name="l04188"></a>04188 
<a name="l04189"></a>04189     <a class="code" href="classeyedb_1_1Schema.html#a26e982852f4294fb1f8d751d532de93c" title="Not yet documented.">Schema</a> *m;
<a name="l04190"></a>04190 
<a name="l04191"></a>04191     <span class="keywordflow">if</span> (odlfile)
<a name="l04192"></a>04192       {
<a name="l04193"></a>04193         Status s;
<a name="l04194"></a>04194         s = odl_prelim(db, odlfile, package, schname, prefix, db_prefix,
<a name="l04195"></a>04195                        False, cpp_cmd, cpp_flags, m);
<a name="l04196"></a>04196         <span class="keywordflow">if</span> (s) <span class="keywordflow">return</span> s;
<a name="l04197"></a>04197       }
<a name="l04198"></a>04198     <span class="keywordflow">else</span>
<a name="l04199"></a>04199       {
<a name="l04200"></a>04200         <span class="keywordtype">int</span> r = odl_check_db(db, schname, package, m);
<a name="l04201"></a>04201         <span class="keywordflow">if</span> (r || odl_error) <span class="keywordflow">return</span> odl_status_error(r);
<a name="l04202"></a>04202       }
<a name="l04203"></a>04203 
<a name="l04204"></a>04204     odl_generate(m, ofile);
<a name="l04205"></a>04205 
<a name="l04206"></a>04206     <span class="keywordflow">return</span> odl_status_error();
<a name="l04207"></a>04207   }
<a name="l04208"></a>04208 }
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 26 10:25:01 2010 for eyedb by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
