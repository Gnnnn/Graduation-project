<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>eyedb: HIdx.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>HIdx.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* </span>
<a name="l00002"></a>00002 <span class="comment">   EyeDB Object Database Management System</span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1994-2008 SYSRA</span>
<a name="l00004"></a>00004 <span class="comment">   </span>
<a name="l00005"></a>00005 <span class="comment">   EyeDB is free software; you can redistribute it and/or</span>
<a name="l00006"></a>00006 <span class="comment">   modify it under the terms of the GNU Lesser General Public</span>
<a name="l00007"></a>00007 <span class="comment">   License as published by the Free Software Foundation; either</span>
<a name="l00008"></a>00008 <span class="comment">   version 2.1 of the License, or (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment">   </span>
<a name="l00010"></a>00010 <span class="comment">   EyeDB is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment">   Lesser General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment">   </span>
<a name="l00015"></a>00015 <span class="comment">   You should have received a copy of the GNU Lesser General Public</span>
<a name="l00016"></a>00016 <span class="comment">   License along with this library; if not, write to the Free Software</span>
<a name="l00017"></a>00017 <span class="comment">   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA </span>
<a name="l00018"></a>00018 <span class="comment">*/</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/*</span>
<a name="l00021"></a>00021 <span class="comment">   Author: Eric Viara &lt;viara@sysra.com&gt;</span>
<a name="l00022"></a>00022 <span class="comment">*/</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;eyedbconfig.h&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">//#define CACHE_FOR_LOCK</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">//#define TRUSS1_GC</span>
<a name="l00029"></a>00029 <span class="comment">//#define TRUSS2_GC</span>
<a name="l00030"></a>00030 <span class="preprocessor">#define OPT_FREELIST</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;eyedbsm/eyedbsm.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;eyedbsm/HIdx.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;IdxP.h&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;eyedblib/rpc_lib.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;eyedblib/performer.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;eyedblib/strutils.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;eyedbsm/xdr.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;eyedblib/log.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;eyedblib/m_mem.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;lib/m_mem_p.h&quot;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keyword">namespace </span>eyedbsm {
<a name="l00052"></a>00052   <span class="keyword">class </span>MapHeader;
<a name="l00053"></a>00053   <span class="keyword">class </span>DbHeader;
<a name="l00054"></a>00054   <span class="keyword">class </span>DatafileDesc;
<a name="l00055"></a>00055   <span class="keyword">class </span>DataspaceDesc;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#define OPTIM_LARGE_OBJECTS</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00059"></a>00059 <span class="preprocessor">#define DATASZ_SIZE 4</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="preprocessor">#define NEW_WAIT</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="comment">//#define MULTI_LIST</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment">//#define TRACK_MAP</span>
<a name="l00065"></a>00065 <span class="comment">//#define TRACK_MAP_2</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#define HIDX_XDR</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define HIDX_XDR_OID</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#define HIDX_XDR_OVERHEAD</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>
<a name="l00071"></a>00071 <span class="preprocessor">#define NO_EXTEND</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>
<a name="l00073"></a>00073 <span class="preprocessor">#define NullOffset (-1)</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="comment">//#define TRACE_HIDX</span>
<a name="l00076"></a>00076 <span class="comment">//#define ESM_HIDX_REGISTER</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="preprocessor">#define VARSZ_DATACNT</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080 <span class="preprocessor">#define NEW_HASH_KEY</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#define NEW_HASH_KEY_VERSION 206004</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>
<a name="l00083"></a>00083 <span class="preprocessor">#define STRTYPE(IDX) \</span>
<a name="l00084"></a>00084 <span class="preprocessor">    ((IDX)-&gt;hidx.keytype == Idx::tString)</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>
<a name="l00086"></a>00086 <span class="preprocessor">#define IDXSZ(V) (sizeof(HIdx::_Idx))</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088   <span class="keyword">extern</span> Boolean backend_interrupt;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="preprocessor">#define data_group_sz(I, THIS) \</span>
<a name="l00091"></a>00091 <span class="preprocessor"> (THIS)-&gt;data_grouped_sizeof + (I) * (THIS)-&gt;hidx.datasz</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00094"></a>00094 dump_keytype(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg, <span class="keyword">const</span> Idx::KeyType &amp;keytype,
<a name="l00095"></a>00095              <span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00096"></a>00096 {
<a name="l00097"></a>00097   printf(<span class="stringliteral">&quot;%s:\n&quot;</span>
<a name="l00098"></a>00098          <span class="stringliteral">&quot;    type=%s count=%d offset=%d\n&quot;</span>, msg,
<a name="l00099"></a>00099          Idx::typeString(keytype.type), keytype.count, keytype.offset);
<a name="l00100"></a>00100   printf(<span class="stringliteral">&quot;    hidx.keytype=%s hidx.keysz=%d hidx.offset=%d\n&quot;</span>,
<a name="l00101"></a>00101          Idx::typeString((Idx::Type)hidx.keytype), hidx.keysz, hidx.offset);
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keyword">static</span> <span class="keywordtype">void</span> cmp_offset(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> off, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l00105"></a>00105 {
<a name="l00106"></a>00106   printf(<span class="stringliteral">&quot;SAME OFFSET %s: %d\n&quot;</span>, str, off);
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#define mcp(D, S, N) \</span>
<a name="l00110"></a>00110 <span class="preprocessor">do { \</span>
<a name="l00111"></a>00111 <span class="preprocessor">  int __n__ = (N); \</span>
<a name="l00112"></a>00112 <span class="preprocessor">  char *__d__ = (char *)(D), *__s__ = (char *)(S); \</span>
<a name="l00113"></a>00113 <span class="preprocessor">  while(__n__--) \</span>
<a name="l00114"></a>00114 <span class="preprocessor">    *__d__++ = *__s__++; \</span>
<a name="l00115"></a>00115 <span class="preprocessor">} while(0)</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="preprocessor">#define mset(D, V, N) \</span>
<a name="l00118"></a>00118 <span class="preprocessor">do { \</span>
<a name="l00119"></a>00119 <span class="preprocessor">  int __n__ = (N); \</span>
<a name="l00120"></a>00120 <span class="preprocessor">  char *__d__ = (char *)(D); \</span>
<a name="l00121"></a>00121 <span class="preprocessor">  while(__n__--) \</span>
<a name="l00122"></a>00122 <span class="preprocessor">    *__d__++ = V; \</span>
<a name="l00123"></a>00123 <span class="preprocessor">} while(0)</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span>
<a name="l00125"></a>00125 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_idx(HIdx::_Idx *idx);
<a name="l00126"></a>00126 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_idx(HIdx::_Idx *idx, <span class="keyword">const</span> HIdx::_Idx *);
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_chd(HIdx::CListHeader *);
<a name="l00128"></a>00128 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_chd(HIdx::CListHeader *, <span class="keyword">const</span> HIdx::CListHeader *);
<a name="l00129"></a>00129 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_header(HIdx::CListObjHeader *);
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_header(HIdx::CListObjHeader *, <span class="keyword">const</span> HIdx::CListObjHeader *);
<a name="l00131"></a>00131 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_overhead(HIdx::CellHeader *);
<a name="l00132"></a>00132 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_overhead(HIdx::CellHeader *, <span class="keyword">const</span> HIdx::CellHeader *);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="preprocessor">#define KEY_OFF (3)</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 <span class="preprocessor">#define OFFSET(T, X) (unsigned long)(&amp;((T *)0)-&gt;X)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>
<a name="l00138"></a>00138 <span class="keyword">const</span> <span class="keywordtype">char</span> HIdxCursor::defaultSKey[] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="preprocessor">#define MIN(X,Y) ((X) &lt; (Y) ? (X) : (Y))</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> IniSize_Default = 4096;
<a name="l00143"></a>00143 <span class="comment">//static const int IniObjCnt_Default = 256;</span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SmallThreshold_Default = 4;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> IniSizeSmall_Default = 256;
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> IniObjCntSmall_Default = 8;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> XCoef_Default = 1;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00153"></a>00153 get_iniobjcnt_def(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00154"></a>00154 {
<a name="l00155"></a>00155   <span class="keywordflow">if</span> (hidx.keysz == HIdx::VarSize)
<a name="l00156"></a>00156     <span class="keywordflow">return</span> 0;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="keywordflow">return</span> hidx.key_count &lt;= SmallThreshold_Default ? IniObjCntSmall_Default :
<a name="l00159"></a>00159     (hidx.mag_order+1) / hidx.key_count;
<a name="l00160"></a>00160 }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00163"></a>00163 get_inisize_small_def(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165   assert(hidx.key_count &lt;= SmallThreshold_Default);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="keywordflow">if</span> (hidx.keysz != HIdx::VarSize) {
<a name="l00168"></a>00168     assert(hidx.impl_hints[HIdx::IniObjCnt_Hints]);
<a name="l00169"></a>00169     <span class="keywordflow">return</span> (<span class="keyword">sizeof</span>(HIdx::CellHeader) + hidx.keysz + hidx.datasz) * 
<a name="l00170"></a>00170       hidx.impl_hints[HIdx::IniObjCnt_Hints];
<a name="l00171"></a>00171     <span class="comment">// - sizeof(HIdx::CellHeader); necessary ?</span>
<a name="l00172"></a>00172   }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="keywordflow">return</span> IniSizeSmall_Default;
<a name="l00175"></a>00175 }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00178"></a>00178 get_inisize_def(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180   <span class="keywordflow">if</span> (hidx.key_count &lt;= SmallThreshold_Default)
<a name="l00181"></a>00181     <span class="keywordflow">return</span> get_inisize_small_def(hidx);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="keywordflow">if</span> (hidx.keysz != HIdx::VarSize) {
<a name="l00184"></a>00184     assert(hidx.impl_hints[HIdx::IniObjCnt_Hints]);
<a name="l00185"></a>00185     <span class="keywordflow">return</span> (<span class="keyword">sizeof</span>(HIdx::CellHeader) + hidx.keysz + hidx.datasz) * 
<a name="l00186"></a>00186       hidx.impl_hints[HIdx::IniObjCnt_Hints];
<a name="l00187"></a>00187     <span class="comment">// - sizeof(HIdx::CellHeader); necessary ?</span>
<a name="l00188"></a>00188   }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="keywordflow">return</span> IniSize_Default;
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00194"></a>00194 get_xcoef_def(<span class="keyword">const</span> HIdx::_Idx &amp;)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196   <span class="keywordflow">return</span> XCoef_Default;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00200"></a>00200 get_sizemax_def(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202   assert(hidx.impl_hints[HIdx::XCoef_Hints] &amp;&amp;
<a name="l00203"></a>00203          hidx.impl_hints[HIdx::IniSize_Hints]);
<a name="l00204"></a>00204          
<a name="l00205"></a>00205   <span class="keywordtype">int</span> xcoef = hidx.impl_hints[HIdx::XCoef_Hints];
<a name="l00206"></a>00206   <span class="keywordflow">return</span> xcoef * xcoef * hidx.impl_hints[HIdx::IniSize_Hints];
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00210"></a>00210 key_offset(<span class="keywordtype">int</span> x)
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212   <span class="keywordflow">return</span> x + KEY_OFF;
<a name="l00213"></a>00213 }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="comment">//#define IDX_DBG</span>
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 Boolean trace_idx;
<a name="l00218"></a>00218 FILE *trace_idx_fd = stdout;
<a name="l00219"></a>00219 Boolean trace_idx_sync;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="comment">/*extern &quot;C&quot; */</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getDbVersion(<span class="keywordtype">void</span> *);
<a name="l00222"></a>00222 <span class="comment">/*extern &quot;C&quot; */</span> Boolean isWholeMapped(<span class="keywordtype">void</span> *);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="keyword">static</span> Boolean
<a name="l00225"></a>00225 isPower2(<span class="keywordtype">int</span> x)
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227   <span class="keywordtype">int</span> n = 0;
<a name="l00228"></a>00228   <span class="keywordflow">while</span>(x) {
<a name="l00229"></a>00229       <span class="keywordflow">if</span> ((x &amp; 1) &amp;&amp; ++n &gt; 1)
<a name="l00230"></a>00230         <span class="keywordflow">return</span> False;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232       x &gt;&gt;= 1;
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keywordflow">return</span> True;
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> HIdx::MaxKeys = 0x800000;
<a name="l00239"></a>00239 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> HIdx::VarSize = 0xffffffff;
<a name="l00240"></a>00240 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> HIdx::MagorderKeycountCoef = 64;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="preprocessor">#define get_gkey(V) key_offset</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span>
<a name="l00244"></a>00244 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00245"></a>00245 computeKeyCount(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_count, <span class="keywordtype">int</span> &amp;mag_order,
<a name="l00246"></a>00246                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxkeys, Boolean &amp;pow2)
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248   <span class="keywordflow">if</span> (key_count) {
<a name="l00249"></a>00249     key_count = (key_count &gt; maxkeys ? maxkeys : key_count);
<a name="l00250"></a>00250     pow2 = isPower2(key_count);
<a name="l00251"></a>00251   }
<a name="l00252"></a>00252   <span class="keywordflow">else</span> {
<a name="l00253"></a>00253     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ncells = (mag_order/HIdx::MagorderKeycountCoef)+1;
<a name="l00254"></a>00254     <span class="keywordflow">if</span> (ncells &gt;= maxkeys-1)
<a name="l00255"></a>00255       key_count = maxkeys;
<a name="l00256"></a>00256     <span class="keywordflow">else</span> {
<a name="l00257"></a>00257       key_count = 1;
<a name="l00258"></a>00258       
<a name="l00259"></a>00259       <span class="keywordflow">for</span> (;;) {
<a name="l00260"></a>00260         <span class="keywordflow">if</span> (key_count &gt;= ncells)
<a name="l00261"></a>00261           <span class="keywordflow">break</span>;
<a name="l00262"></a>00262         key_count &lt;&lt;= 1;
<a name="l00263"></a>00263       }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265       pow2 = True;
<a name="l00266"></a>00266     }
<a name="l00267"></a>00267   }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   mag_order = key_count * HIdx::MagorderKeycountCoef-1;
<a name="l00270"></a>00270   <span class="keywordflow">return</span> key_count;
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00274"></a>00274 get_keyTypeCount(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276   <span class="keywordflow">if</span> (hidx.keysz == HIdx::VarSize)
<a name="l00277"></a>00277     <span class="keywordflow">return</span> HIdx::VarSize; <span class="comment">// changed the 29/01/02: was return 0</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="keywordtype">unsigned</span> tsz = Idx::typeSize((Idx::Type)hidx.keytype);
<a name="l00280"></a>00280   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = (hidx.keysz - hidx.offset) / tsz;
<a name="l00281"></a>00281   assert(count * tsz == (hidx.keysz - hidx.offset));
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="keywordflow">return</span> count;
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="comment">//#define FORCE_COPY</span>
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="keyword">static</span> Boolean _isUExtend(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00289"></a>00289 {
<a name="l00290"></a>00290   <span class="keywordflow">return</span> (hidx.impl_hints[HIdx::XCoef_Hints] &gt; 1) ? True : False;
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="keyword">static</span> Boolean _isDataGroupedByKey(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295   <span class="keywordflow">return</span> (hidx.impl_hints[HIdx::DataGroupedByKey_Hints] != 0) ? True : False;
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _dataGroupedByKeySize(<span class="keyword">const</span> HIdx::_Idx &amp;hidx)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)hidx.impl_hints[HIdx::DataGroupedByKey_Hints];
<a name="l00301"></a>00301 }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="keywordtype">void</span>
<a name="l00304"></a>00304 HIdx::init(DbHandle *_dbh, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _keytype,
<a name="l00305"></a>00305               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keysz, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset,
<a name="l00306"></a>00306               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz, <span class="keywordtype">short</span> _dspid, <span class="keywordtype">int</span> mag_order,
<a name="l00307"></a>00307               <span class="keywordtype">int</span> key_count,
<a name="l00308"></a>00308               <span class="keyword">const</span> <span class="keywordtype">int</span> *impl_hints,
<a name="l00309"></a>00309               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> impl_hints_cnt)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311   dbh = _dbh;
<a name="l00312"></a>00312   version = getDbVersion(dbh);
<a name="l00313"></a>00313 <span class="preprocessor">#ifdef FORCE_COPY</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>  nocopy = False;
<a name="l00315"></a>00315 <span class="preprocessor">#else</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>  nocopy = isWholeMapped(dbh);
<a name="l00317"></a>00317 <span class="preprocessor">#endif</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>  memset(&amp;hidx, 0, <span class="keyword">sizeof</span>(hidx));
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   hidx.key_count = computeKeyCount(key_count, mag_order, MaxKeys, pow2);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   hidx.idxtype = HashType;
<a name="l00323"></a>00323   hidx.mag_order = mag_order;
<a name="l00324"></a>00324   hidx.object_count = 0;
<a name="l00325"></a>00325   hidx.dspid = _dspid;
<a name="l00326"></a>00326   hidx.keytype = _keytype;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   hidx.keysz = keysz;
<a name="l00329"></a>00329   hidx.datasz = datasz;
<a name="l00330"></a>00330   hidx.offset = offset;
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   memset(&amp;treeoid, 0, <span class="keyword">sizeof</span>(treeoid));
<a name="l00333"></a>00333 <span class="preprocessor">#ifdef NEW_HASH_TRACE</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span>  keytype.type = (Type)hidx.keytype;
<a name="l00335"></a>00335   keytype.count = get_keyTypeCount(hidx);
<a name="l00336"></a>00336   dump_keytype(<span class="stringliteral">&quot;creating hash index&quot;</span>, keytype, hidx);;
<a name="l00337"></a>00337 <span class="preprocessor">#endif</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span>
<a name="l00339"></a>00339   hash_data = 0;
<a name="l00340"></a>00340   hash_key = 0;
<a name="l00341"></a>00341 <span class="preprocessor">#ifdef NEW_HASH_KEY</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span>  set_hash_key();
<a name="l00343"></a>00343 <span class="preprocessor">#endif</span>
<a name="l00344"></a>00344 <span class="preprocessor"></span>
<a name="l00345"></a>00345   <span class="keywordflow">if</span> (impl_hints)
<a name="l00346"></a>00346     memcpy(hidx.impl_hints, impl_hints, impl_hints_cnt*<span class="keyword">sizeof</span>(impl_hints[0]));
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="keywordflow">if</span> (hidx.keysz == HIdx::VarSize)
<a name="l00349"></a>00349     hidx.impl_hints[IniObjCnt_Hints] = 0; <span class="comment">// ignored</span>
<a name="l00350"></a>00350   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!hidx.impl_hints[IniObjCnt_Hints])
<a name="l00351"></a>00351     hidx.impl_hints[IniObjCnt_Hints] = get_iniobjcnt_def(hidx);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="keywordflow">if</span> (!hidx.impl_hints[IniSize_Hints])
<a name="l00354"></a>00354     hidx.impl_hints[IniSize_Hints] = get_inisize_def(hidx);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   <span class="keywordflow">if</span> (!hidx.impl_hints[XCoef_Hints])
<a name="l00357"></a>00357     hidx.impl_hints[XCoef_Hints] = get_xcoef_def(hidx);
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <span class="keywordflow">if</span> (!hidx.impl_hints[SzMax_Hints])
<a name="l00360"></a>00360     hidx.impl_hints[SzMax_Hints] = get_sizemax_def(hidx);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="keywordflow">if</span> (_isDataGroupedByKey(hidx) &amp;&amp; <a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l00363"></a>00363     stat = statusMake(NOT_YET_IMPLEMENTED, <span class="stringliteral">&quot;data_grouped_by_key hash indexes does not yet support variable size data&quot;</span>);
<a name="l00364"></a>00364     <span class="keywordflow">return</span>;
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   mask = hidx.key_count - 1;
<a name="l00368"></a>00368   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370   <span class="keywordtype">int</span> len = gkey(hidx.key_count);
<a name="l00371"></a>00371   IDB_LOG(IDB_LOG_IDX_CREATE,
<a name="l00372"></a>00372           (<span class="stringliteral">&quot;Creating Hash Index: magorder=%u, entries=%u &quot;</span>
<a name="l00373"></a>00373            <span class="stringliteral">&quot;keysz=%u, datasz=%u, &quot;</span>
<a name="l00374"></a>00374            <span class="stringliteral">&quot;size=%u [%d objects of size %u + 1 object of size %u]\n&quot;</span>,
<a name="l00375"></a>00375            hidx.mag_order,
<a name="l00376"></a>00376            hidx.key_count,
<a name="l00377"></a>00377            hidx.keysz,
<a name="l00378"></a>00378            hidx.datasz,
<a name="l00379"></a>00379            <span class="keyword">sizeof</span>(CListHeader)*hidx.key_count+len*<span class="keyword">sizeof</span>(Oid),
<a name="l00380"></a>00380            hidx.key_count,
<a name="l00381"></a>00381            <span class="keyword">sizeof</span>(CListHeader),
<a name="l00382"></a>00382            len*<span class="keyword">sizeof</span>(Oid)));
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   CListHeader *chds;
<a name="l00385"></a>00385   chds = <span class="keyword">new</span> CListHeader[len];
<a name="l00386"></a>00386 
<a name="l00387"></a>00387   memset(chds, 0, <span class="keyword">sizeof</span>(CListHeader) * len);
<a name="l00388"></a>00388   _Idx xidx;
<a name="l00389"></a>00389   h2x_idx(&amp;xidx, &amp;hidx);
<a name="l00390"></a>00390   mcp(chds, &amp;xidx, <span class="keyword">sizeof</span>(xidx));
<a name="l00391"></a>00391   assert(<span class="keyword">sizeof</span>(xidx) &lt;= KEY_OFF * <span class="keyword">sizeof</span>(CListHeader));
<a name="l00392"></a>00392 
<a name="l00393"></a>00393   bsize = hidx.impl_hints[IniSize_Hints];
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="comment">/*</span>
<a name="l00396"></a>00396 <span class="comment">    printf(&quot;creating index header size=%d, magorder=%d\n&quot;, sizeof(Oid) * len,</span>
<a name="l00397"></a>00397 <span class="comment">    hidx.mag_order);</span>
<a name="l00398"></a>00398 <span class="comment">  */</span>
<a name="l00399"></a>00399 <span class="preprocessor">#ifdef TRACE_HIDX</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;creating index %d\n&quot;</span>,  <span class="keyword">sizeof</span>(Oid) * len);
<a name="l00401"></a>00401 <span class="preprocessor">#endif</span>
<a name="l00402"></a>00402 <span class="preprocessor"></span>
<a name="l00403"></a>00403   CListHeader *tchds = <span class="keyword">new</span> CListHeader[len];
<a name="l00404"></a>00404   memcpy(tchds, chds, <span class="keyword">sizeof</span>(CListHeader) * KEY_OFF);
<a name="l00405"></a>00405   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = KEY_OFF; i &lt; len; i++)
<a name="l00406"></a>00406     h2x_chd(&amp;tchds[i], &amp;chds[i]);
<a name="l00407"></a>00407   stat = objectCreate(dbh, tchds, <span class="keyword">sizeof</span>(CListHeader) * len, hidx.dspid,
<a name="l00408"></a>00408                          &amp;treeoid);
<a name="l00409"></a>00409   <span class="keyword">delete</span> [] tchds;
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <span class="keywordflow">if</span> (!stat)
<a name="l00412"></a>00412     IDB_LOG(IDB_LOG_IDX_CREATE,
<a name="l00413"></a>00413             (<span class="stringliteral">&quot;Have Created Hash Index: treeoid=%s\n&quot;</span>,
<a name="l00414"></a>00414              getOidString(&amp;treeoid)));
<a name="l00415"></a>00415   <span class="keyword">delete</span> [] chds;
<a name="l00416"></a>00416   uextend = _isUExtend(hidx);
<a name="l00417"></a>00417   data_grouped_by_key = _isDataGroupedByKey(hidx);
<a name="l00418"></a>00418   data_grouped_sizeof = _dataGroupedByKeySize(hidx);
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00421"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a550ece58eb70ec91d93d4b586b95666d">00421</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a550ece58eb70ec91d93d4b586b95666d" title="Not yet documented.">HIdx::HIdx</a>(DbHandle *_dbh, KeyType _keytype,
<a name="l00422"></a>00422            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz, <span class="keywordtype">short</span> _dspid,
<a name="l00423"></a>00423            <span class="keywordtype">int</span> _mag_order, <span class="keywordtype">int</span> key_count,
<a name="l00424"></a>00424            <span class="keyword">const</span> <span class="keywordtype">int</span> *impl_hints,
<a name="l00425"></a>00425            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> impl_hints_cnt)
<a name="l00426"></a>00426   : Idx(False)
<a name="l00427"></a>00427 {
<a name="l00428"></a>00428   keytype = _keytype;
<a name="l00429"></a>00429   init(_dbh, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)keytype.type,
<a name="l00430"></a>00430        ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)keytype.count == VarSize ? VarSize :
<a name="l00431"></a>00431         (typeSize(keytype.type) * keytype.count) + keytype.offset),
<a name="l00432"></a>00432        keytype.offset,
<a name="l00433"></a>00433        datasz, _dspid, _mag_order, key_count,
<a name="l00434"></a>00434        impl_hints, impl_hints_cnt);
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00438"></a><a class="code" href="classeyedbsm_1_1HIdx.html#ada3505cfeb52a2ec93a35d05ff0817ad">00438</a> <a class="code" href="classeyedbsm_1_1HIdx.html#ada3505cfeb52a2ec93a35d05ff0817ad" title="Not yet documented.">HIdx::getMagOrder</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keycount)
<a name="l00439"></a>00439 {
<a name="l00440"></a>00440   <span class="keywordflow">return</span> keycount * HIdx::MagorderKeycountCoef;
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00444"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a946bd7af14f28b92764ea4c2ddaa8dd9">00444</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a7580fdf0eae875286cda3167896a22b7" title="Not yet documented.">HIdx::getKeyCount</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> magorder)
<a name="l00445"></a>00445 {
<a name="l00446"></a>00446   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keycount = magorder / MagorderKeycountCoef;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="keywordflow">if</span> (keycount &gt;= MaxKeys)
<a name="l00449"></a>00449     <span class="keywordflow">return</span> MaxKeys;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   <span class="keywordflow">return</span> keycount ? keycount : 1;
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a><a class="code" href="classeyedbsm_1_1HIdx.html#aa7986f060c68736198ae7040382e6576">00454</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a550ece58eb70ec91d93d4b586b95666d" title="Not yet documented.">HIdx::HIdx</a>(DbHandle *_dbh, <span class="keyword">const</span> Oid *_oid,
<a name="l00455"></a>00455                  hash_key_t _hash_key,
<a name="l00456"></a>00456                  <span class="keywordtype">void</span> *_hash_data,
<a name="l00457"></a>00457                  Boolean (*precmp)(<span class="keywordtype">void</span> <span class="keyword">const</span> * p, <span class="keywordtype">void</span> <span class="keyword">const</span> * q,
<a name="l00458"></a>00458                                       KeyType <span class="keyword">const</span> * type, <span class="keywordtype">int</span> &amp; r))
<a name="l00459"></a>00459   : Idx(True, precmp), dbh(_dbh)
<a name="l00460"></a>00460 {
<a name="l00461"></a>00461   version = getDbVersion(_dbh);
<a name="l00462"></a>00462   stat = objectRead(dbh, 0, IDXSZ(version), &amp;hidx, DefaultLock, 0, 0, _oid);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="comment">/*</span>
<a name="l00465"></a>00465 <span class="comment">    printf(&quot;version = %d %d [%d vs. %d] status %d\n&quot;,</span>
<a name="l00466"></a>00466 <span class="comment">    version, IDXSZ(version), sizeof(HIdx::_Idx),</span>
<a name="l00467"></a>00467 <span class="comment">    sizeof(OIdx), stat);</span>
<a name="l00468"></a>00468 <span class="comment">  */</span>
<a name="l00469"></a>00469     
<a name="l00470"></a>00470   <span class="keywordflow">if</span> (stat)
<a name="l00471"></a>00471     <span class="keywordflow">return</span>;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="preprocessor">#ifdef FORCE_COPY</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>  nocopy = False;
<a name="l00475"></a>00475 <span class="preprocessor">#else</span>
<a name="l00476"></a>00476 <span class="preprocessor"></span>  nocopy = isWholeMapped(dbh);
<a name="l00477"></a>00477 <span class="preprocessor">#endif</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>  x2h_idx(&amp;hidx);
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   keytype.type = (Type)hidx.keytype;
<a name="l00481"></a>00481   keytype.count = get_keyTypeCount(hidx);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   hash_key = _hash_key;
<a name="l00484"></a>00484   hash_data = _hash_data;
<a name="l00485"></a>00485   treeoid = *_oid;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="preprocessor">#ifdef NEW_HASH_KEY</span>
<a name="l00488"></a>00488 <span class="preprocessor"></span>  set_hash_key();
<a name="l00489"></a>00489 <span class="preprocessor">#endif</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>
<a name="l00491"></a>00491   keytype.offset = hidx.offset;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="comment">//dump_keytype(&quot;Idx::HIdx&quot;, keytype, hidx);;</span>
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="comment">//unsigned int (*gkey)(int) = get_gkey(version);</span>
<a name="l00496"></a>00496   <span class="comment">//int len = gkey(hidx.key_count);</span>
<a name="l00497"></a>00497   mask = hidx.key_count - 1;
<a name="l00498"></a>00498   pow2 = isPower2(hidx.key_count);
<a name="l00499"></a>00499   bsize = hidx.impl_hints[IniSize_Hints];
<a name="l00500"></a>00500   uextend = _isUExtend(hidx);
<a name="l00501"></a>00501   data_grouped_by_key = _isDataGroupedByKey(hidx);
<a name="l00502"></a>00502   data_grouped_sizeof = _dataGroupedByKeySize(hidx);
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="preprocessor">#ifdef NEW_HASH_KEY</span>
<a name="l00506"></a>00506 <span class="preprocessor"></span>
<a name="l00507"></a>00507 <span class="comment">//  mcp(&amp;t, (unsigned char *)(key)+((HIdx::_Idx *)xhidx)-&gt;offset, sizeof(T));</span>
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="preprocessor">#define MK_DEF_HASH_KEY(T, F) \</span>
<a name="l00510"></a>00510 <span class="preprocessor">Status \</span>
<a name="l00511"></a>00511 <span class="preprocessor">HIdx::F(const void *key, unsigned int len, void *xhidx, unsigned int &amp;x) \</span>
<a name="l00512"></a>00512 <span class="preprocessor">{ \</span>
<a name="l00513"></a>00513 <span class="preprocessor">  T t; \</span>
<a name="l00514"></a>00514 <span class="preprocessor">  mcp(&amp;t, (unsigned char *)key, sizeof(T)); \</span>
<a name="l00515"></a>00515 <span class="preprocessor">  x = (int)t; \</span>
<a name="l00516"></a>00516 <span class="preprocessor">  return Success; \</span>
<a name="l00517"></a>00517 <span class="preprocessor">}</span>
<a name="l00518"></a>00518 <span class="preprocessor"></span>
<a name="l00519"></a>00519 Status
<a name="l00520"></a>00520 HIdx::get_def_oiddata_hash_key(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len,
<a name="l00521"></a>00521                                   <span class="keywordtype">void</span> *xhidx, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;x)
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523   Oid <a class="code" href="classeyedbsm_1_1HIdx.html#a1394aa7916e5cb8214280f96d6cce83a" title="Not yet documented.">oid</a>;
<a name="l00524"></a>00524   mcp(&amp;oid, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(key), <span class="keyword">sizeof</span>(oid));
<a name="l00525"></a>00525   x = oid.getNX();
<a name="l00526"></a>00526   <span class="keywordflow">return</span> Success;
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 MK_DEF_HASH_KEY(eyedblib::int16, get_def_int16data_hash_key);
<a name="l00530"></a>00530 MK_DEF_HASH_KEY(eyedblib::int32, get_def_int32data_hash_key);
<a name="l00531"></a>00531 MK_DEF_HASH_KEY(eyedblib::int64, get_def_int64data_hash_key);
<a name="l00532"></a>00532 MK_DEF_HASH_KEY(eyedblib::float32, get_def_float32data_hash_key);
<a name="l00533"></a>00533 MK_DEF_HASH_KEY(eyedblib::float64, get_def_float64data_hash_key);
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="keywordtype">void</span>
<a name="l00536"></a>00536 HIdx::set_hash_key()
<a name="l00537"></a>00537 {
<a name="l00538"></a>00538 <span class="preprocessor">#ifdef NEW_HASH_TRACE</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;hash_key for index %s [hash_key=%p]\n&quot;</span>,
<a name="l00540"></a>00540          getOidString(&amp;treeoid), hash_key);
<a name="l00541"></a>00541   dump_keytype(<span class="stringliteral">&quot;hash_key : &quot;</span>, keytype, hidx);;
<a name="l00542"></a>00542 <span class="preprocessor">#endif</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (hash_key) <span class="keywordflow">return</span>;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   hash_data = 0;
<a name="l00546"></a>00546   <span class="comment">/*</span>
<a name="l00547"></a>00547 <span class="comment">  if (hidx.keytype == tString) {</span>
<a name="l00548"></a>00548 <span class="comment">    hash_key = get_def_string_hash_key;</span>
<a name="l00549"></a>00549 <span class="comment">    return;</span>
<a name="l00550"></a>00550 <span class="comment">  }</span>
<a name="l00551"></a>00551 <span class="comment">  */</span>
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="keywordflow">if</span> (version &gt;= NEW_HASH_KEY_VERSION) {
<a name="l00554"></a>00554     hash_data = &amp;hidx;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="keywordflow">switch</span>(hidx.keytype) {
<a name="l00557"></a>00557     <span class="keywordflow">case</span> tString:
<a name="l00558"></a>00558       hash_key = get_def_nstring_hash_key;
<a name="l00559"></a>00559       <span class="keywordflow">return</span>;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="keywordflow">case</span> tInt16:
<a name="l00562"></a>00562     <span class="keywordflow">case</span> tUnsignedInt16:
<a name="l00563"></a>00563       hash_key = get_def_int16data_hash_key;
<a name="l00564"></a>00564       <span class="keywordflow">return</span>;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     <span class="keywordflow">case</span> tInt32:
<a name="l00567"></a>00567     <span class="keywordflow">case</span> tUnsignedInt32:
<a name="l00568"></a>00568       hash_key = get_def_int32data_hash_key;
<a name="l00569"></a>00569       <span class="keywordflow">return</span>;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571     <span class="keywordflow">case</span> tInt64:
<a name="l00572"></a>00572     <span class="keywordflow">case</span> tUnsignedInt64:
<a name="l00573"></a>00573       hash_key = get_def_int64data_hash_key;
<a name="l00574"></a>00574       <span class="keywordflow">return</span>;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     <span class="keywordflow">case</span> tOid:
<a name="l00577"></a>00577       hash_key = get_def_oiddata_hash_key;
<a name="l00578"></a>00578       <span class="keywordflow">return</span>;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580     <span class="keywordflow">case</span> tFloat32:
<a name="l00581"></a>00581       hash_key = get_def_float32data_hash_key;
<a name="l00582"></a>00582       <span class="keywordflow">return</span>;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     <span class="keywordflow">case</span> tFloat64:
<a name="l00585"></a>00585       hash_key = get_def_float64data_hash_key;
<a name="l00586"></a>00586       <span class="keywordflow">return</span>;
<a name="l00587"></a>00587     }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589     hash_data = 0;
<a name="l00590"></a>00590   }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   <span class="keywordflow">if</span> (hidx.keytype == tString) {
<a name="l00593"></a>00593     hash_key = get_def_string_hash_key;
<a name="l00594"></a>00594     <span class="keywordflow">return</span>;
<a name="l00595"></a>00595   }
<a name="l00596"></a>00596 
<a name="l00597"></a>00597   hash_key = get_def_rawdata_hash_key;
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 <span class="preprocessor">#endif</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>
<a name="l00601"></a>00601 <span class="keywordtype">void</span>
<a name="l00602"></a><a class="code" href="classeyedbsm_1_1HIdx.html#ad63311b1209b685bfdf8a23e34c18b52">00602</a> <a class="code" href="classeyedbsm_1_1HIdx.html#ad63311b1209b685bfdf8a23e34c18b52" title="Not yet documented.">HIdx::open</a>(hash_key_t _hash_key,
<a name="l00603"></a>00603               <span class="keywordtype">void</span> *_hash_data,
<a name="l00604"></a>00604               Boolean (*_precmp)(<span class="keywordtype">void</span> <span class="keyword">const</span> * p, <span class="keywordtype">void</span> <span class="keyword">const</span> * q,
<a name="l00605"></a>00605                                     KeyType <span class="keyword">const</span> * type, <span class="keywordtype">int</span> &amp; r))
<a name="l00606"></a>00606 {
<a name="l00607"></a>00607   keytype.type = (Type)hidx.keytype;
<a name="l00608"></a>00608   keytype.count = get_keyTypeCount(hidx);
<a name="l00609"></a>00609   keytype.offset = hidx.offset;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   hash_key = _hash_key;
<a name="l00612"></a>00612   hash_data = _hash_data;
<a name="l00613"></a>00613 <span class="preprocessor">#ifdef NEW_HASH_KEY</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span>  set_hash_key();
<a name="l00615"></a>00615   assert(hash_key);
<a name="l00616"></a>00616 <span class="preprocessor">#endif</span>
<a name="l00617"></a>00617 <span class="preprocessor"></span>  precmp = _precmp;
<a name="l00618"></a>00618   opened = True;
<a name="l00619"></a>00619 }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 HIdx::~HIdx()
<a name="l00622"></a>00622 {
<a name="l00623"></a>00623   <a class="code" href="classeyedbsm_1_1HIdx.html#a54fef60f1dedcbf237513e413a5f0c4e" title="Not yet documented.">flush_cache</a>(<span class="keyword">false</span>);
<a name="l00624"></a>00624 }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 Boolean trace_it;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="preprocessor">#define first_char &apos; &apos;</span>
<a name="l00629"></a>00629 <span class="preprocessor"></span><span class="preprocessor">#define last_char  &apos;~&apos;</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span><span class="preprocessor">#define asc(x) ((unsigned int)((x) - first_char))</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span><span class="preprocessor">#define asc_len ((unsigned int)(last_char - first_char + 1))</span>
<a name="l00632"></a>00632 <span class="preprocessor"></span>
<a name="l00633"></a>00633 <span class="preprocessor">#define NEW_HASH_KEY2</span>
<a name="l00634"></a>00634 <span class="preprocessor"></span>
<a name="l00635"></a>00635 Status
<a name="l00636"></a>00636 HIdx::get_def_string_hash_key(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;x)
<a name="l00637"></a>00637 {
<a name="l00638"></a>00638 <span class="preprocessor">#ifdef NEW_HASH_KEY2</span>
<a name="l00639"></a>00639 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *k = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)key;
<a name="l00640"></a>00640   x = 1;
<a name="l00641"></a>00641   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; len; i++) {
<a name="l00642"></a>00642     x *= *k++;
<a name="l00643"></a>00643     x ^= x &gt;&gt; 8;
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645 <span class="preprocessor">#else</span>
<a name="l00646"></a>00646 <span class="preprocessor"></span>  x = 0;
<a name="l00647"></a>00647   <span class="keywordtype">char</span> *k = (<span class="keywordtype">char</span> *)key;
<a name="l00648"></a>00648   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; len; i++)
<a name="l00649"></a>00649     x += *k++ * (i+1); <span class="comment">//x += *k++;</span>
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="preprocessor">#endif</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span>  <span class="keywordflow">return</span> Success;
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 Status
<a name="l00656"></a>00656 HIdx::get_def_nstring_hash_key(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;x)
<a name="l00657"></a>00657 {
<a name="l00658"></a>00658   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *k = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)key;
<a name="l00659"></a>00659   <span class="keywordflow">if</span> (len &gt; 12)
<a name="l00660"></a>00660     len = 12;
<a name="l00661"></a>00661 <span class="preprocessor">#ifdef NEW_HASH_KEY2</span>
<a name="l00662"></a>00662 <span class="preprocessor"></span>  x = 1;
<a name="l00663"></a>00663   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; len; i++) {
<a name="l00664"></a>00664     x *= *k++;
<a name="l00665"></a>00665     x ^= x &gt;&gt; 8;
<a name="l00666"></a>00666   }
<a name="l00667"></a>00667 <span class="preprocessor">#else</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span>  <span class="keywordtype">int</span> coef = 1;
<a name="l00669"></a>00669   eyedblib::int64 r = 0;
<a name="l00670"></a>00670   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; len; n++, k++) {
<a name="l00671"></a>00671     r += coef * asc(*k);
<a name="l00672"></a>00672     coef *= asc_len;
<a name="l00673"></a>00673   }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   x = r;
<a name="l00676"></a>00676 <span class="preprocessor">#endif</span>
<a name="l00677"></a>00677 <span class="preprocessor"></span>  <span class="keywordflow">return</span> Success;
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 Status
<a name="l00681"></a>00681 HIdx::get_string_hash_key(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;x)<span class="keyword"> const</span>
<a name="l00682"></a>00682 <span class="keyword"></span>{
<a name="l00683"></a>00683 <span class="preprocessor">#ifdef NEW_HASH_KEY</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span>  assert(hash_key);
<a name="l00685"></a>00685 <span class="preprocessor">#endif</span>
<a name="l00686"></a>00686 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (hash_key)
<a name="l00687"></a>00687     <span class="keywordflow">return</span> hash_key(key, len, hash_data, x);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   abort();
<a name="l00690"></a>00690   <span class="keywordflow">return</span> get_def_string_hash_key(key, len, 0, x);
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 Status
<a name="l00694"></a>00694 HIdx::get_def_rawdata_hash_key(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;x)
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696   x = 0;
<a name="l00697"></a>00697   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *k = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)key;
<a name="l00698"></a>00698   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; len; i++)
<a name="l00699"></a>00699     x += *k++;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   <span class="keywordflow">return</span> Success;
<a name="l00702"></a>00702 }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 Status
<a name="l00705"></a>00705 HIdx::get_rawdata_hash_key(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;x)<span class="keyword"> const</span>
<a name="l00706"></a>00706 <span class="keyword"></span>{
<a name="l00707"></a>00707 <span class="preprocessor">#ifdef NEW_HASH_KEY</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span>  assert(hash_key);
<a name="l00709"></a>00709 <span class="preprocessor">#endif</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (hash_key)
<a name="l00711"></a>00711     <span class="keywordflow">return</span> hash_key(key, len, hash_data, x);
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   <span class="keywordflow">return</span> get_def_rawdata_hash_key(key, len, 0, x);
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <span class="keyword">const</span> *
<a name="l00717"></a>00717 fpos_(<span class="keywordtype">void</span> <span class="keyword">const</span> * p, <span class="keywordtype">int</span> offset)
<a name="l00718"></a>00718 {
<a name="l00719"></a>00719   <span class="keywordflow">return</span> (<span class="keywordtype">char</span> <span class="keyword">const</span> *)p + offset;
<a name="l00720"></a>00720 }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="keyword">inline</span> Status HIdx::get_key(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;n, <span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *size)<span class="keyword"> const</span>
<a name="l00723"></a>00723 <span class="keyword"></span>{
<a name="l00724"></a>00724   key = fpos_(key, keytype.offset);
<a name="l00725"></a>00725   Status s;
<a name="l00726"></a>00726   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz = (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>() ? 0 : hidx.datasz);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="keywordflow">if</span> (STRTYPE(<span class="keyword">this</span>)) {
<a name="l00731"></a>00731     <span class="keywordtype">int</span> len = strlen((<span class="keywordtype">char</span> *)key);
<a name="l00732"></a>00732     s = get_string_hash_key(key, len, x);
<a name="l00733"></a>00733     <span class="keywordflow">if</span> (s)
<a name="l00734"></a>00734       <span class="keywordflow">return</span> s;
<a name="l00735"></a>00735     
<a name="l00736"></a>00736     <span class="keywordflow">if</span> (size) {
<a name="l00737"></a>00737       <span class="keywordflow">if</span> (hidx.keysz == VarSize) {
<a name="l00738"></a>00738         *size = datasz + len + 1;
<a name="l00739"></a>00739       }
<a name="l00740"></a>00740       <span class="keywordflow">else</span> {
<a name="l00741"></a>00741         *size = datasz + hidx.keysz;
<a name="l00742"></a>00742       }
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744     
<a name="l00745"></a>00745     n = (pow2 ? (x &amp; mask) : (x % mask));
<a name="l00746"></a>00746     <span class="keywordflow">return</span> Success;
<a name="l00747"></a>00747   }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   s = get_rawdata_hash_key(key, hidx.keysz - keytype.offset, x);
<a name="l00750"></a>00750   <span class="keywordflow">if</span> (s)
<a name="l00751"></a>00751     <span class="keywordflow">return</span> s;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <span class="keywordflow">if</span> (size) {
<a name="l00754"></a>00754     *size = datasz + hidx.keysz;
<a name="l00755"></a>00755   }
<a name="l00756"></a>00756   
<a name="l00757"></a>00757   n = (pow2 ? (x &amp; mask) : (x % mask));
<a name="l00758"></a>00758   <span class="keywordflow">return</span> Success;
<a name="l00759"></a>00759 }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 Status
<a name="l00762"></a>00762 HIdx::suppressObjectFromFreeList(CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k, CListObjHeader &amp;h,
<a name="l00763"></a>00763                                     <span class="keyword">const</span> Oid &amp;koid)
<a name="l00764"></a>00764 {
<a name="l00765"></a>00765 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;suppressObjectFromFreeList(%s)\n&quot;</span>, getOidString(&amp;koid));
<a name="l00767"></a>00767 <span class="preprocessor">#endif  </span>
<a name="l00768"></a>00768 <span class="preprocessor"></span>  Status s;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770   <span class="keywordflow">if</span> (h.clobj_free_prev.getNX()) {
<a name="l00771"></a>00771     Oid xoid;
<a name="l00772"></a>00772     h2x_oid(&amp;xoid, &amp;h.clobj_free_next);
<a name="l00773"></a>00773     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_free_next), <span class="keyword">sizeof</span>(Oid),
<a name="l00774"></a>00774                        &amp;xoid, &amp;h.clobj_free_prev);
<a name="l00775"></a>00775     <span class="keywordflow">if</span> (s)
<a name="l00776"></a>00776       <span class="keywordflow">return</span> s;
<a name="l00777"></a>00777   }
<a name="l00778"></a>00778   
<a name="l00779"></a>00779   <span class="keywordflow">if</span> (h.clobj_free_next.getNX()) {
<a name="l00780"></a>00780     Oid xoid;
<a name="l00781"></a>00781     h2x_oid(&amp;xoid, &amp;h.clobj_free_prev);
<a name="l00782"></a>00782     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_free_prev), <span class="keyword">sizeof</span>(Oid),
<a name="l00783"></a>00783                        &amp;xoid, &amp;h.clobj_free_next);
<a name="l00784"></a>00784     <span class="keywordflow">if</span> (s)
<a name="l00785"></a>00785       <span class="keywordflow">return</span> s;
<a name="l00786"></a>00786   }
<a name="l00787"></a>00787   
<a name="l00788"></a>00788   <span class="keywordflow">if</span> (chd.clobj_free_first.getNX() == koid.getNX()) {
<a name="l00789"></a>00789     chd.clobj_free_first = h.clobj_free_next;
<a name="l00790"></a>00790     s = writeCListHeader(chd_k, chd);
<a name="l00791"></a>00791     <span class="keywordflow">if</span> (s)
<a name="l00792"></a>00792       <span class="keywordflow">return</span> s;
<a name="l00793"></a>00793   }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   mset(&amp;h.clobj_free_prev, 0, <span class="keyword">sizeof</span>(h.clobj_free_prev));
<a name="l00796"></a>00796   mset(&amp;h.clobj_free_next, 0, <span class="keyword">sizeof</span>(h.clobj_free_next));
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="keywordflow">return</span> Success;
<a name="l00799"></a>00799 }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 Status
<a name="l00802"></a>00802 HIdx::suppressObjectFromList(CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k, CListObjHeader &amp;h,
<a name="l00803"></a>00803                                 <span class="keyword">const</span> Oid &amp;koid)
<a name="l00804"></a>00804 {
<a name="l00805"></a>00805 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l00806"></a>00806 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;suppressObjectFromList(%s)\n&quot;</span>, getOidString(&amp;koid));
<a name="l00807"></a>00807 <span class="preprocessor">#endif  </span>
<a name="l00808"></a>00808 <span class="preprocessor"></span>  Status s;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="keywordflow">if</span> (h.clobj_prev.getNX()) {
<a name="l00811"></a>00811     Oid xoid;
<a name="l00812"></a>00812     h2x_oid(&amp;xoid, &amp;h.clobj_next);
<a name="l00813"></a>00813     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_next), <span class="keyword">sizeof</span>(Oid),
<a name="l00814"></a>00814                        &amp;xoid, &amp;h.clobj_prev);
<a name="l00815"></a>00815     <span class="keywordflow">if</span> (s)
<a name="l00816"></a>00816       <span class="keywordflow">return</span> s;
<a name="l00817"></a>00817   }
<a name="l00818"></a>00818   
<a name="l00819"></a>00819   <span class="keywordflow">if</span> (h.clobj_next.getNX()) {
<a name="l00820"></a>00820     Oid xoid;
<a name="l00821"></a>00821     h2x_oid(&amp;xoid, &amp;h.clobj_prev);
<a name="l00822"></a>00822     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_prev), <span class="keyword">sizeof</span>(Oid),
<a name="l00823"></a>00823                        &amp;xoid, &amp;h.clobj_next);
<a name="l00824"></a>00824     <span class="keywordflow">if</span> (s)
<a name="l00825"></a>00825       <span class="keywordflow">return</span> s;
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827   
<a name="l00828"></a>00828   Boolean write_chd = False;
<a name="l00829"></a>00829   <span class="keywordflow">if</span> (chd.clobj_first.getNX() == koid.getNX()) {
<a name="l00830"></a>00830     chd.clobj_first = h.clobj_next;
<a name="l00831"></a>00831     write_chd = True;
<a name="l00832"></a>00832   }
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="keywordflow">if</span> (chd.clobj_last.getNX() == koid.getNX()) {
<a name="l00835"></a>00835     chd.clobj_last = h.clobj_prev;
<a name="l00836"></a>00836     write_chd = True;
<a name="l00837"></a>00837   }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <span class="keywordflow">if</span> (write_chd) {
<a name="l00840"></a>00840     s = writeCListHeader(chd_k, chd);
<a name="l00841"></a>00841     <span class="keywordflow">if</span> (s)
<a name="l00842"></a>00842       <span class="keywordflow">return</span> s;
<a name="l00843"></a>00843   }
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   <span class="keywordflow">return</span> objectDelete(dbh, &amp;koid);
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 Status
<a name="l00849"></a>00849 HIdx::modifyObjectSize(<span class="keywordtype">int</span> osize, <span class="keywordtype">int</span> nsize, <span class="keyword">const</span> Oid &amp;koid, 
<a name="l00850"></a>00850                        Oid &amp;nkoid)
<a name="l00851"></a>00851 {
<a name="l00852"></a>00852   <span class="comment">// ATTENTION:</span>
<a name="l00853"></a>00853   <span class="comment">// 1. il ne faut utiliser cette fonction qui si koid est un oid physique</span>
<a name="l00854"></a>00854   <span class="comment">//    test: if (isPhysicalOid(dbh, &amp;koid))</span>
<a name="l00855"></a>00855   <span class="comment">// 2. il faut creer le nouvel objet sur le meme dataspace !!</span>
<a name="l00856"></a>00856   <span class="comment">//    =&gt; objectRead() permet de recuperer le datid mais objectCreate()</span>
<a name="l00857"></a>00857   <span class="comment">//       necessite le dspid. Comment fait-on ?</span>
<a name="l00858"></a>00858   <span class="comment">//       crer une fonction: datGetDspid(dbh, short datid, short *dspid)</span>
<a name="l00859"></a>00859   <span class="comment">//printf(&quot;Modify Object Size from %d to %d\n&quot;, osize, nsize);</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[osize];
<a name="l00862"></a>00862   <span class="keywordtype">short</span> datid;
<a name="l00863"></a>00863   Status s = objectRead(dbh, 0, osize, data, DefaultLock, &amp;datid,
<a name="l00864"></a>00864                               0, &amp;koid);
<a name="l00865"></a>00865   <span class="keywordflow">if</span> (s) {
<a name="l00866"></a>00866     <span class="keyword">delete</span> [] data;
<a name="l00867"></a>00867     <span class="keywordflow">return</span> s;
<a name="l00868"></a>00868   }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870   <span class="keywordtype">short</span> dspid;
<a name="l00871"></a>00871   s = datGetDspid(dbh, datid, &amp;dspid);
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="preprocessor">#ifdef OPTIM_LARGE_OBJECTS</span>
<a name="l00874"></a>00874 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!s)
<a name="l00875"></a>00875     s = objectCreate(dbh, ObjectNone, nsize, dspid, &amp;nkoid);
<a name="l00876"></a>00876 <span class="preprocessor">#else</span>
<a name="l00877"></a>00877 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!s)
<a name="l00878"></a>00878     s = objectCreate(dbh, 0, nsize, dspid, &amp;nkoid);
<a name="l00879"></a>00879 <span class="preprocessor">#endif</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>
<a name="l00881"></a>00881   <span class="keywordflow">if</span> (s) {
<a name="l00882"></a>00882     <span class="keyword">delete</span>[] data;
<a name="l00883"></a>00883     <span class="keywordflow">return</span> s;
<a name="l00884"></a>00884   }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   s = objectWrite(dbh, 0, osize, data, &amp;nkoid);
<a name="l00887"></a>00887   <span class="keyword">delete</span> [] data;
<a name="l00888"></a>00888   <span class="keywordflow">if</span> (s) {
<a name="l00889"></a>00889     (void)objectDelete(dbh, &amp;nkoid);
<a name="l00890"></a>00890     <span class="keywordflow">return</span> s;
<a name="l00891"></a>00891   }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893   s = objectDelete(dbh, &amp;koid);
<a name="l00894"></a>00894   <span class="keywordflow">if</span> (s)
<a name="l00895"></a>00895     (void)objectDelete(dbh, &amp;nkoid);
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   <span class="keywordflow">return</span> s;
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 Status
<a name="l00901"></a>00901 HIdx::replaceObjectInList(CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k, CListObjHeader &amp;h,
<a name="l00902"></a>00902                              <span class="keyword">const</span> Oid &amp;koid, <span class="keyword">const</span> Oid &amp;nkoid)
<a name="l00903"></a>00903 {
<a name="l00904"></a>00904 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l00905"></a>00905 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;replaceObjectFromList(%s, %s)\n&quot;</span>, getOidString(&amp;koid),
<a name="l00906"></a>00906          getOidString(&amp;nkoid));
<a name="l00907"></a>00907   printf(<span class="stringliteral">&quot;CHD first=%s last=%s\n&quot;</span>, getOidString(&amp;chd.first), getOidString(&amp;chd.last));
<a name="l00908"></a>00908   printf(<span class="stringliteral">&quot;CHD2 free_first=%s\n&quot;</span>,
<a name="l00909"></a>00909          getOidString(&amp;chd.free_first));
<a name="l00910"></a>00910   printf(<span class="stringliteral">&quot;HEADER prev=%s, next=%s, free_prev=%s, free_next=%s\n&quot;</span>,
<a name="l00911"></a>00911          getOidString(&amp;h.clobj_prev),
<a name="l00912"></a>00912          getOidString(&amp;h.clobj_next),
<a name="l00913"></a>00913          getOidString(&amp;h.clobj_free_prev),
<a name="l00914"></a>00914          getOidString(&amp;h.clobj_free_next));
<a name="l00915"></a>00915 <span class="preprocessor">#endif  </span>
<a name="l00916"></a>00916 <span class="preprocessor"></span>  Status s;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   Oid xoid;
<a name="l00919"></a>00919   h2x_oid(&amp;xoid, &amp;nkoid);
<a name="l00920"></a>00920 
<a name="l00921"></a>00921   <span class="keywordflow">if</span> (h.clobj_prev.getNX()) {
<a name="l00922"></a>00922     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_next), <span class="keyword">sizeof</span>(Oid),
<a name="l00923"></a>00923                        &amp;xoid, &amp;h.clobj_prev);
<a name="l00924"></a>00924     <span class="keywordflow">if</span> (s)
<a name="l00925"></a>00925       <span class="keywordflow">return</span> s;
<a name="l00926"></a>00926   }
<a name="l00927"></a>00927   
<a name="l00928"></a>00928   <span class="keywordflow">if</span> (h.clobj_next.getNX()) {
<a name="l00929"></a>00929     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_prev), <span class="keyword">sizeof</span>(Oid),
<a name="l00930"></a>00930                        &amp;xoid, &amp;h.clobj_next);
<a name="l00931"></a>00931     <span class="keywordflow">if</span> (s)
<a name="l00932"></a>00932       <span class="keywordflow">return</span> s;
<a name="l00933"></a>00933   }
<a name="l00934"></a>00934   
<a name="l00935"></a>00935   <span class="keywordflow">if</span> (h.clobj_free_prev.getNX()) {
<a name="l00936"></a>00936     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_free_next), <span class="keyword">sizeof</span>(Oid),
<a name="l00937"></a>00937                        &amp;xoid, &amp;h.clobj_free_prev);
<a name="l00938"></a>00938     <span class="keywordflow">if</span> (s)
<a name="l00939"></a>00939       <span class="keywordflow">return</span> s;
<a name="l00940"></a>00940   }
<a name="l00941"></a>00941   
<a name="l00942"></a>00942   <span class="keywordflow">if</span> (h.clobj_free_next.getNX()) {
<a name="l00943"></a>00943     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_free_prev), <span class="keyword">sizeof</span>(Oid),
<a name="l00944"></a>00944                        &amp;xoid, &amp;h.clobj_free_next);
<a name="l00945"></a>00945     <span class="keywordflow">if</span> (s)
<a name="l00946"></a>00946       <span class="keywordflow">return</span> s;
<a name="l00947"></a>00947   }
<a name="l00948"></a>00948   
<a name="l00949"></a>00949   Boolean write_chd = False;
<a name="l00950"></a>00950   <span class="keywordflow">if</span> (chd.clobj_first.getNX() == koid.getNX()) {
<a name="l00951"></a>00951     chd.clobj_first = xoid;
<a name="l00952"></a>00952     write_chd = True;
<a name="l00953"></a>00953   }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955   <span class="keywordflow">if</span> (chd.clobj_last.getNX() == koid.getNX()) {
<a name="l00956"></a>00956     chd.clobj_last = xoid;
<a name="l00957"></a>00957     write_chd = True;
<a name="l00958"></a>00958   }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960   <span class="keywordflow">if</span> (chd.clobj_free_first.getNX() == koid.getNX()) {
<a name="l00961"></a>00961     chd.clobj_free_first = xoid;
<a name="l00962"></a>00962     write_chd = True;
<a name="l00963"></a>00963   }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965   <span class="keywordflow">if</span> (write_chd) {
<a name="l00966"></a>00966     s = writeCListHeader(chd_k, chd);
<a name="l00967"></a>00967     <span class="keywordflow">if</span> (s)
<a name="l00968"></a>00968       <span class="keywordflow">return</span> s;
<a name="l00969"></a>00969   }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971   <span class="keywordflow">return</span> Success;
<a name="l00972"></a>00972 }
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 <span class="comment">//#define BUG_DATA_STORE</span>
<a name="l00975"></a>00975 <span class="preprocessor">#define BUG_DATA_STORE2</span>
<a name="l00976"></a>00976 <span class="preprocessor"></span>
<a name="l00977"></a>00977 Status
<a name="l00978"></a>00978 HIdx::insert_realize(CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k, <span class="keyword">const</span> <span class="keywordtype">void</span> *key,
<a name="l00979"></a>00979                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, <span class="keyword">const</span> <span class="keywordtype">void</span> *xdata,
<a name="l00980"></a>00980                      <span class="keyword">const</span> Oid &amp;koid,
<a name="l00981"></a>00981                      CListObjHeader &amp;h, <span class="keywordtype">int</span> offset, CellHeader &amp;o, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz)
<a name="l00982"></a>00982 {
<a name="l00983"></a>00983   <span class="keywordtype">int</span> osize = o.size, onext = o.cell_free_next;
<a name="l00984"></a>00984   <span class="keywordtype">int</span> ovsize = size + <span class="keyword">sizeof</span>(CellHeader);
<a name="l00985"></a>00985   Status s;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987   assert(o.free);
<a name="l00988"></a>00988 
<a name="l00989"></a>00989   <span class="comment">/*</span>
<a name="l00990"></a>00990 <span class="comment">  printf(&quot;insert_realize offset %d o.free %d o.cell_free_next %d o.cell_free_prev %d\n&quot;,</span>
<a name="l00991"></a>00991 <span class="comment">         offset, o.free, o.cell_free_next, o.cell_free_prev);</span>
<a name="l00992"></a>00992 <span class="comment">  */</span>
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l00995"></a>00995 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;insert_realize(%d vs. %d&quot;</span>, osize, size);
<a name="l00996"></a>00996   <span class="keywordflow">if</span> (hidx.datasz &gt;= <span class="keyword">sizeof</span>(Oid)) {
<a name="l00997"></a>00997     Oid xdata_oid;
<a name="l00998"></a>00998     memcpy(&amp;xdata_oid, xdata, <span class="keyword">sizeof</span>(Oid));
<a name="l00999"></a>00999     printf(<span class="stringliteral">&quot;. [%s]&quot;</span>, getOidString(&amp;xdata_oid));
<a name="l01000"></a>01000   }
<a name="l01001"></a>01001   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01002"></a>01002 <span class="preprocessor">#endif</span>
<a name="l01003"></a>01003 <span class="preprocessor"></span>
<a name="l01004"></a>01004 <span class="preprocessor">#ifdef BUG_DATA_STORE</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (osize &gt; size + <span class="keyword">sizeof</span>(CellHeader))
<a name="l01006"></a>01006     o.size = size;
<a name="l01007"></a>01007   <span class="keywordflow">else</span>
<a name="l01008"></a>01008     ovsize += osize - size;
<a name="l01009"></a>01009 <span class="preprocessor">#endif</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span>
<a name="l01011"></a>01011 <span class="preprocessor">#ifdef HAS_ALLOC_BUFFER</span>
<a name="l01012"></a>01012 <span class="preprocessor"></span>  <span class="keywordtype">char</span> *data = insert_buffer.alloc(ovsize);
<a name="l01013"></a>01013 <span class="preprocessor">#else</span>
<a name="l01014"></a>01014 <span class="preprocessor"></span>  <span class="keywordtype">char</span> *data = (<span class="keywordtype">char</span> *)m_malloc(ovsize);
<a name="l01015"></a>01015 <span class="preprocessor">#endif</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (STRTYPE(<span class="keyword">this</span>))
<a name="l01017"></a>01017     memcpy(data + <span class="keyword">sizeof</span>(CellHeader), key, strlen((<span class="keywordtype">char</span> *)key)+1);
<a name="l01018"></a>01018   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hidx.keytype == tUnsignedChar || hidx.keytype == tChar ||
<a name="l01019"></a>01019            hidx.keytype == tSignedChar)
<a name="l01020"></a>01020     memcpy(data + <span class="keyword">sizeof</span>(CellHeader), key, size - datasz);
<a name="l01021"></a>01021   <span class="keywordflow">else</span> {
<a name="l01022"></a>01022     <span class="keywordtype">char</span> xkey[Idx_max_type_size];
<a name="l01023"></a>01023     assert(size - datasz &lt;= Idx_max_type_size);
<a name="l01024"></a>01024     h2x(xkey, key, keytype);
<a name="l01025"></a>01025     memcpy(data + <span class="keyword">sizeof</span>(CellHeader), xkey, size - datasz);
<a name="l01026"></a>01026   }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028   <span class="keywordflow">if</span> (o.cell_free_next != NullOffset) {
<a name="l01029"></a>01029     CellHeader no;
<a name="l01030"></a>01030     s = readCellHeader(o.cell_free_next, koid, no);
<a name="l01031"></a>01031     <span class="keywordflow">if</span> (s)
<a name="l01032"></a>01032       <span class="keywordflow">return</span> s;
<a name="l01033"></a>01033     assert(no.free);
<a name="l01034"></a>01034     no.cell_free_prev = o.cell_free_prev;
<a name="l01035"></a>01035     s = writeCellHeader(o.cell_free_next, koid, no);
<a name="l01036"></a>01036     <span class="keywordflow">if</span> (s)
<a name="l01037"></a>01037       <span class="keywordflow">return</span> s;
<a name="l01038"></a>01038   }
<a name="l01039"></a>01039 
<a name="l01040"></a>01040   <span class="keywordflow">if</span> (o.cell_free_prev != NullOffset) {
<a name="l01041"></a>01041     CellHeader no;
<a name="l01042"></a>01042     s = readCellHeader(o.cell_free_prev, koid, no);
<a name="l01043"></a>01043     <span class="keywordflow">if</span> (s)
<a name="l01044"></a>01044       <span class="keywordflow">return</span> s;
<a name="l01045"></a>01045     assert(no.free);
<a name="l01046"></a>01046     no.cell_free_next = o.cell_free_next;
<a name="l01047"></a>01047     s = writeCellHeader(o.cell_free_prev, koid, no);
<a name="l01048"></a>01048     <span class="keywordflow">if</span> (s)
<a name="l01049"></a>01049       <span class="keywordflow">return</span> s;
<a name="l01050"></a>01050   }
<a name="l01051"></a>01051   <span class="keywordflow">else</span> {
<a name="l01052"></a>01052     assert(h.cell_free_first == offset);
<a name="l01053"></a>01053     h.cell_free_first = o.cell_free_next;
<a name="l01054"></a>01054   }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 <span class="preprocessor">#if 0</span>
<a name="l01057"></a>01057 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (h.cell_free_first == offset) {
<a name="l01058"></a>01058     printf(<span class="stringliteral">&quot;h.cell_free_first == offset %d\n&quot;</span>, offset);
<a name="l01059"></a>01059     <span class="keywordflow">if</span> (o.cell_free_next != NullOffset) {
<a name="l01060"></a>01060       CellHeader no;
<a name="l01061"></a>01061       s = readCellHeader(o.cell_free_next, koid, no);
<a name="l01062"></a>01062       <span class="keywordflow">if</span> (s)
<a name="l01063"></a>01063         <span class="keywordflow">return</span> s;
<a name="l01064"></a>01064       <span class="comment">// EV : 3/05/07</span>
<a name="l01065"></a>01065       assert(no.free);
<a name="l01066"></a>01066       no.cell_free_prev = NullOffset;
<a name="l01067"></a>01067       s = writeCellHeader(o.cell_free_next, koid, no);
<a name="l01068"></a>01068       <span class="keywordflow">if</span> (s)
<a name="l01069"></a>01069         <span class="keywordflow">return</span> s;
<a name="l01070"></a>01070     }
<a name="l01071"></a>01071     h.cell_free_first = o.cell_free_next;
<a name="l01072"></a>01072     printf(<span class="stringliteral">&quot;setting free_first to %d\n&quot;</span>, h.cell_free_first);
<a name="l01073"></a>01073   }
<a name="l01074"></a>01074 <span class="preprocessor">#endif</span>
<a name="l01075"></a>01075 <span class="preprocessor"></span>
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 <span class="preprocessor">#ifndef BUG_DATA_STORE</span>
<a name="l01078"></a>01078 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (osize &gt; size + <span class="keyword">sizeof</span>(CellHeader))
<a name="l01079"></a>01079     o.size = size;
<a name="l01080"></a>01080 <span class="preprocessor">#endif</span>
<a name="l01081"></a>01081 <span class="preprocessor"></span>
<a name="l01082"></a>01082   o.free = 0;
<a name="l01083"></a>01083   o.cell_free_next = NullOffset;
<a name="l01084"></a>01084   o.cell_free_prev = NullOffset;
<a name="l01085"></a>01085   CellHeader to;
<a name="l01086"></a>01086   h2x_overhead(&amp;to, &amp;o);
<a name="l01087"></a>01087   mcp(data, &amp;to, <span class="keyword">sizeof</span>(to));
<a name="l01088"></a>01088   <span class="comment">//  memcpy(data + ovsize - hidx.datasz, xdata, hidx.datasz);</span>
<a name="l01089"></a>01089   <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l01090"></a>01090     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xdatasz = h2x_u32(datasz);
<a name="l01091"></a>01091     memcpy(data + ovsize - datasz - DATASZ_SIZE, &amp;xdatasz, DATASZ_SIZE);
<a name="l01092"></a>01092     memcpy(data + ovsize - datasz, xdata, datasz);
<a name="l01093"></a>01093   }
<a name="l01094"></a>01094   <span class="keywordflow">else</span> {
<a name="l01095"></a>01095     memcpy(data + ovsize - datasz, xdata, datasz);
<a name="l01096"></a>01096   }
<a name="l01097"></a>01097   <span class="comment">//printf(&quot;writing OBJECT %s of size %d offset = %d total = %d\n&quot;, getOidString(&amp;koid), ovsize, offset, offset+ovsize);</span>
<a name="l01098"></a>01098   s = objectWrite(dbh, offset, ovsize, data, &amp;koid);
<a name="l01099"></a>01099 <span class="preprocessor">#ifndef HAS_ALLOC_BUFFER</span>
<a name="l01100"></a>01100 <span class="preprocessor"></span>  free(data);
<a name="l01101"></a>01101 <span class="preprocessor">#endif</span>
<a name="l01102"></a>01102 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (s)
<a name="l01103"></a>01103     <span class="keywordflow">return</span> s;  
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   h.free_whole -= osize;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="preprocessor">#if 0</span>
<a name="l01108"></a>01108 <span class="preprocessor"></span>  assert(!writeCListObjHeader(koid, h));
<a name="l01109"></a>01109 <span class="preprocessor">#endif</span>
<a name="l01110"></a>01110 <span class="preprocessor"></span>
<a name="l01111"></a>01111   <span class="keywordflow">if</span> (osize == size) {
<a name="l01112"></a>01112 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l01113"></a>01113 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;exact size %d\n&quot;</span>, size);
<a name="l01114"></a>01114 <span class="preprocessor">#endif</span>
<a name="l01115"></a>01115 <span class="preprocessor"></span>  }
<a name="l01116"></a>01116   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (osize &gt; size + <span class="keyword">sizeof</span>(CellHeader)) {
<a name="l01117"></a>01117     <span class="comment">/* generation d&apos;une nouvelle cellule */</span>
<a name="l01118"></a>01118 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l01119"></a>01119 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;split cell %d %d %d %d\n&quot;</span>, size+<span class="keyword">sizeof</span>(CellHeader), osize, offset, h.cell_free_first);
<a name="l01120"></a>01120 <span class="preprocessor">#endif</span>
<a name="l01121"></a>01121 <span class="preprocessor"></span>    <span class="keywordtype">int</span> noffset = offset + size + <span class="keyword">sizeof</span>(CellHeader);
<a name="l01122"></a>01122     s = insertCell(noffset, osize - size - <span class="keyword">sizeof</span>(CellHeader), h, koid);
<a name="l01123"></a>01123     <span class="keywordflow">if</span> (s)
<a name="l01124"></a>01124       <span class="keywordflow">return</span> s;
<a name="l01125"></a>01125   }
<a name="l01126"></a>01126 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l01127"></a>01127 <span class="preprocessor"></span>  <span class="keywordflow">else</span> {
<a name="l01128"></a>01128     printf(<span class="stringliteral">&quot;special case: we are loosing some place %s ?\n&quot;</span>, getOidString(&amp;koid));
<a name="l01129"></a>01129   }
<a name="l01130"></a>01130 <span class="preprocessor">#endif</span>
<a name="l01131"></a>01131 <span class="preprocessor"></span>
<a name="l01132"></a>01132   h.free_cnt--;
<a name="l01133"></a>01133   h.alloc_cnt++;
<a name="l01134"></a>01134 
<a name="l01135"></a>01135   <span class="comment">/*</span>
<a name="l01136"></a>01136 <span class="comment">  printf(&quot;insert: ovsize=%d, free_whole=%d, free_cnt=%d, alloc_cnt=%d\n&quot;,</span>
<a name="l01137"></a>01137 <span class="comment">         ovsize, h.free_whole, h.free_cnt, h.alloc_cnt);</span>
<a name="l01138"></a>01138 <span class="comment">  */</span>
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="comment">// changed this test the 29/06/02 to allow to get rid of unuseful objects</span>
<a name="l01141"></a>01141 <span class="preprocessor">#ifdef OPT_FREELIST</span>
<a name="l01142"></a>01142 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!h.free_cnt || (STRTYPE(<span class="keyword">this</span>) &amp;&amp; h.free_whole &lt;= <span class="keyword">sizeof</span>(CellHeader)+8))
<a name="l01143"></a>01143 <span class="preprocessor">#else</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!h.free_cnt)
<a name="l01145"></a>01145 <span class="preprocessor">#endif</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span>    {
<a name="l01147"></a>01147 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;making chain for new object\n&quot;</span>);
<a name="l01149"></a>01149 <span class="preprocessor">#endif</span>
<a name="l01150"></a>01150 <span class="preprocessor"></span>    Status s;
<a name="l01151"></a>01151     <span class="comment">// ASTUCE : si la taille n&apos;est pas au maximum, alors ne pas supprimer</span>
<a name="l01152"></a>01152     <span class="comment">// cet objet de la free list mais, au contraire, l&apos;tendre en utilisant</span>
<a name="l01153"></a>01153     <span class="comment">// hints[XCoef_Hints].</span>
<a name="l01154"></a>01154     <span class="keywordflow">if</span> (!uextend || !candidateForExtension(h)) {
<a name="l01155"></a>01155 <span class="preprocessor">#ifdef TRUSS2_GC</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (h.free_cnt) {
<a name="l01157"></a>01157         printf(<span class="stringliteral">&quot;get rid of this fucking object %d %s\n&quot;</span>, h.free_whole, getOidString(&amp;koid));
<a name="l01158"></a>01158       }
<a name="l01159"></a>01159 <span class="preprocessor">#endif</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>      s = suppressObjectFromFreeList(chd, chd_k, h, koid);
<a name="l01161"></a>01161       <span class="keywordflow">if</span> (s)
<a name="l01162"></a>01162         <span class="keywordflow">return</span> s;
<a name="l01163"></a>01163     }
<a name="l01164"></a>01164   }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   s = writeCListObjHeader(koid, h);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168   <span class="keywordflow">if</span> (!s)
<a name="l01169"></a>01169     s = count_manage(dbh, 1);
<a name="l01170"></a>01170 
<a name="l01171"></a>01171   <span class="keywordflow">return</span> s;
<a name="l01172"></a>01172 }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174 Status
<a name="l01175"></a>01175 HIdx::count_manage(DbHandle *_dbh, <span class="keywordtype">int</span> inc)
<a name="l01176"></a>01176 {
<a name="l01177"></a>01177   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count;
<a name="l01178"></a>01178   Status s = objectRead(_dbh, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>),
<a name="l01179"></a>01179                         <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), &amp;count,
<a name="l01180"></a>01180                         DefaultLock, 0, 0, &amp;treeoid);
<a name="l01181"></a>01181   <span class="keywordflow">if</span> (s)
<a name="l01182"></a>01182     <span class="keywordflow">return</span> s;
<a name="l01183"></a>01183   count = x2h_u32(count);
<a name="l01184"></a>01184   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> o_count = hidx.object_count;
<a name="l01185"></a>01185 
<a name="l01186"></a>01186   hidx.object_count = count + inc;
<a name="l01187"></a>01187   count = h2x_u32(hidx.object_count);
<a name="l01188"></a>01188 
<a name="l01189"></a>01189   s = objectWrite(_dbh, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>),
<a name="l01190"></a>01190                   <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), &amp;count, &amp;treeoid);
<a name="l01191"></a>01191   
<a name="l01192"></a>01192   <span class="keywordflow">if</span> (s) hidx.object_count = o_count;
<a name="l01193"></a>01193   <span class="keywordflow">return</span> s;
<a name="l01194"></a>01194 }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 Status
<a name="l01197"></a>01197 HIdx::readCListHeader(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k, CListHeader &amp;chd)<span class="keyword"> const</span>
<a name="l01198"></a>01198 <span class="keyword"></span>{
<a name="l01199"></a>01199   Status s;
<a name="l01200"></a>01200   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l01201"></a>01201 
<a name="l01202"></a>01202   s = objectRead(dbh, gkey(k) * <span class="keyword">sizeof</span>(CListHeader), <span class="keyword">sizeof</span>(CListHeader), &amp;chd,
<a name="l01203"></a>01203                     DefaultLock, 0, 0, &amp;treeoid);
<a name="l01204"></a>01204   <span class="keywordflow">if</span> (s)
<a name="l01205"></a>01205     <span class="keywordflow">return</span> s;
<a name="l01206"></a>01206   x2h_chd(&amp;chd);
<a name="l01207"></a>01207   <span class="keywordflow">return</span> Success;
<a name="l01208"></a>01208 }
<a name="l01209"></a>01209 
<a name="l01210"></a>01210 Status
<a name="l01211"></a>01211 HIdx::readCListObjHeader(<span class="keyword">const</span> Oid &amp;koid, CListObjHeader &amp;h)<span class="keyword"> const</span>
<a name="l01212"></a>01212 <span class="keyword"></span>{
<a name="l01213"></a>01213   Status s;
<a name="l01214"></a>01214   s = objectRead(dbh, 0, <span class="keyword">sizeof</span>(CListObjHeader), &amp;h, DefaultLock,
<a name="l01215"></a>01215                     0, 0, &amp;koid);
<a name="l01216"></a>01216   <span class="keywordflow">if</span> (s)
<a name="l01217"></a>01217     <span class="keywordflow">return</span> s;
<a name="l01218"></a>01218   x2h_header(&amp;h);
<a name="l01219"></a>01219   <span class="keywordflow">return</span> Success;
<a name="l01220"></a>01220 }
<a name="l01221"></a>01221 
<a name="l01222"></a>01222 Status
<a name="l01223"></a>01223 HIdx::writeCListObjHeader(<span class="keyword">const</span> Oid &amp;koid, <span class="keyword">const</span> CListObjHeader &amp;h)<span class="keyword"> const</span>
<a name="l01224"></a>01224 <span class="keyword"></span>{
<a name="l01225"></a>01225 <span class="preprocessor">#if 0</span>
<a name="l01226"></a>01226 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (h.cell_free_first != NullOffset) {
<a name="l01227"></a>01227     CellHeader o = {0};
<a name="l01228"></a>01228     Status s = readCellHeader(h.cell_free_first, koid, o);
<a name="l01229"></a>01229     <span class="keywordflow">if</span> (s)
<a name="l01230"></a>01230       statusPrint(s, <span class="stringliteral">&quot;...&quot;</span>);
<a name="l01231"></a>01231     assert(o.free);
<a name="l01232"></a>01232   }
<a name="l01233"></a>01233 <span class="preprocessor">#endif</span>
<a name="l01234"></a>01234 <span class="preprocessor"></span>  CListObjHeader th;
<a name="l01235"></a>01235   h2x_header(&amp;th, &amp;h);
<a name="l01236"></a>01236   <span class="keywordflow">return</span> objectWrite(dbh, 0, <span class="keyword">sizeof</span>(CListObjHeader), &amp;th, &amp;koid);
<a name="l01237"></a>01237 }
<a name="l01238"></a>01238 
<a name="l01239"></a>01239 Status
<a name="l01240"></a>01240 HIdx::readCellHeader(<span class="keywordtype">int</span> offset, <span class="keyword">const</span> Oid &amp;koid, CellHeader &amp;o)<span class="keyword"> const</span>
<a name="l01241"></a>01241 <span class="keyword"></span>{
<a name="l01242"></a>01242   Status s;
<a name="l01243"></a>01243   s = objectRead(dbh, offset, <span class="keyword">sizeof</span>(CellHeader), &amp;o, DefaultLock,
<a name="l01244"></a>01244                     0, 0, &amp;koid);
<a name="l01245"></a>01245   <span class="keywordflow">if</span> (s)
<a name="l01246"></a>01246     <span class="keywordflow">return</span> s;
<a name="l01247"></a>01247   x2h_overhead(&amp;o);
<a name="l01248"></a>01248   <span class="keywordflow">return</span> Success;
<a name="l01249"></a>01249 }
<a name="l01250"></a>01250 
<a name="l01251"></a>01251 <span class="keywordtype">void</span> HIdx::printCellHeader(<span class="keyword">const</span> HIdx::CellHeader *o, <span class="keywordtype">int</span> offset)<span class="keyword"> const</span>
<a name="l01252"></a>01252 <span class="keyword"></span>{
<a name="l01253"></a>01253   printf(<span class="stringliteral">&quot;CellHeader at %d\n&quot;</span>, offset);
<a name="l01254"></a>01254   printf(<span class="stringliteral">&quot;  o.free %d\n&quot;</span>, o-&gt;free);
<a name="l01255"></a>01255   printf(<span class="stringliteral">&quot;  o.size %d\n&quot;</span>, o-&gt;size);
<a name="l01256"></a>01256   printf(<span class="stringliteral">&quot;  o.cell_free_prev %d\n&quot;</span>, o-&gt;cell_free_prev);
<a name="l01257"></a>01257   printf(<span class="stringliteral">&quot;  o.cell_free_next %d\n&quot;</span>, o-&gt;cell_free_next);
<a name="l01258"></a>01258 }
<a name="l01259"></a>01259 
<a name="l01260"></a>01260 <span class="keywordtype">void</span> HIdx::checkCellHeader(<span class="keywordtype">int</span> offset, <span class="keyword">const</span> Oid *koid)<span class="keyword"> const</span>
<a name="l01261"></a>01261 <span class="keyword"></span>{
<a name="l01262"></a>01262   HIdx::CellHeader o;
<a name="l01263"></a>01263   readCellHeader(offset, *koid, o);
<a name="l01264"></a>01264   printCellHeader(&amp;o, offset);
<a name="l01265"></a>01265 }
<a name="l01266"></a>01266 
<a name="l01267"></a>01267 <span class="keywordtype">void</span> HIdx::printCListObjHeader(<span class="keyword">const</span> HIdx::CListObjHeader *h)<span class="keyword"> const</span>
<a name="l01268"></a>01268 <span class="keyword"></span>{
<a name="l01269"></a>01269   printf(<span class="stringliteral">&quot;CListObjHeader\n&quot;</span>);
<a name="l01270"></a>01270   printf(<span class="stringliteral">&quot;  h.size %u\n&quot;</span>, h-&gt;size);
<a name="l01271"></a>01271   printf(<span class="stringliteral">&quot;  h.free_cnt %d\n&quot;</span>, h-&gt;free_cnt);
<a name="l01272"></a>01272   printf(<span class="stringliteral">&quot;  h.alloc_cnt %d\n&quot;</span>, h-&gt;alloc_cnt);
<a name="l01273"></a>01273   printf(<span class="stringliteral">&quot;  h.free_whole %d\n&quot;</span>, h-&gt;free_whole);
<a name="l01274"></a>01274   printf(<span class="stringliteral">&quot;  h.cell_free_first %d\n&quot;</span>, h-&gt;cell_free_first);
<a name="l01275"></a>01275   printf(<span class="stringliteral">&quot;  h.clobj_free_prev %s\n&quot;</span>, getOidString(&amp;h-&gt;clobj_free_prev));
<a name="l01276"></a>01276   printf(<span class="stringliteral">&quot;  h.clobj_free_next %s\n&quot;</span>, getOidString(&amp;h-&gt;clobj_free_next));
<a name="l01277"></a>01277   printf(<span class="stringliteral">&quot;  h.clobj_prev %s\n&quot;</span>, getOidString(&amp;h-&gt;clobj_prev));
<a name="l01278"></a>01278   printf(<span class="stringliteral">&quot;  h.clobj_next %s\n&quot;</span>, getOidString(&amp;h-&gt;clobj_next));
<a name="l01279"></a>01279 }
<a name="l01280"></a>01280 
<a name="l01281"></a>01281 <span class="keywordtype">void</span> HIdx::checkCListObjHeader(<span class="keyword">const</span> Oid *koid)<span class="keyword"> const</span>
<a name="l01282"></a>01282 <span class="keyword"></span>{
<a name="l01283"></a>01283   HIdx::CListObjHeader h;
<a name="l01284"></a>01284   readCListObjHeader(*koid, h);
<a name="l01285"></a>01285   printCListObjHeader(&amp;h);
<a name="l01286"></a>01286 }
<a name="l01287"></a>01287 
<a name="l01288"></a>01288 <span class="keywordtype">void</span> HIdx::checkChain(<span class="keyword">const</span> Oid *koid)<span class="keyword"> const</span>
<a name="l01289"></a>01289 <span class="keyword"></span>{
<a name="l01290"></a>01290   CListObjHeader h;
<a name="l01291"></a>01291   readCListObjHeader(*koid, h);
<a name="l01292"></a>01292   <span class="keywordtype">int</span> offset = h.cell_free_first;
<a name="l01293"></a>01293   <span class="keywordtype">int</span> prev = NullOffset;
<a name="l01294"></a>01294   <span class="comment">//printCListObjHeader(&amp;h);</span>
<a name="l01295"></a>01295 
<a name="l01296"></a>01296   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; offset != NullOffset &amp;&amp; n &lt; 100; n++) {
<a name="l01297"></a>01297     CellHeader o;
<a name="l01298"></a>01298     assert(!readCellHeader(offset, *koid, o));
<a name="l01299"></a>01299     assert(o.free);
<a name="l01300"></a>01300     assert(o.cell_free_prev == prev);
<a name="l01301"></a>01301     prev = offset;
<a name="l01302"></a>01302     <span class="comment">//printCellHeader(&amp;o, offset);</span>
<a name="l01303"></a>01303     offset = o.cell_free_next;
<a name="l01304"></a>01304     <span class="keywordflow">if</span> (n &gt; 90)
<a name="l01305"></a>01305       printf(<span class="stringliteral">&quot;chain loop\n&quot;</span>);
<a name="l01306"></a>01306   }
<a name="l01307"></a>01307 }
<a name="l01308"></a>01308 
<a name="l01309"></a>01309 <span class="keywordtype">void</span> HIdx::checkChain(<span class="keyword">const</span> CListHeader *chd, <span class="keyword">const</span> std::string &amp;msg)<span class="keyword"> const</span>
<a name="l01310"></a>01310 <span class="keyword"></span>{
<a name="l01311"></a>01311  Oid koid = chd-&gt;clobj_free_first;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313  <span class="comment">//printf(&quot;\nChecking chain %s {\n&quot;, msg.c_str());</span>
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   <span class="keywordtype">int</span> cnt = 0;
<a name="l01316"></a>01316   <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l01317"></a>01317     CListObjHeader h;
<a name="l01318"></a>01318     assert(!readCListObjHeader(koid, h));
<a name="l01319"></a>01319     <span class="comment">//printf(&quot;h.cell_free_first %d\n&quot;, h.cell_free_first);</span>
<a name="l01320"></a>01320     checkChain(&amp;koid);
<a name="l01321"></a>01321     koid = h.clobj_free_next;
<a name="l01322"></a>01322     cnt++;
<a name="l01323"></a>01323   }
<a name="l01324"></a>01324   <span class="comment">//printf(&quot;} %d found\n&quot;, cnt);</span>
<a name="l01325"></a>01325 }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327 <span class="keyword">static</span> <span class="keywordtype">bool</span> dont_check = <span class="keyword">false</span>;
<a name="l01328"></a>01328 <span class="comment">//static bool dont_check = true;</span>
<a name="l01329"></a>01329 
<a name="l01330"></a>01330 Status
<a name="l01331"></a>01331 HIdx::writeCellHeader(<span class="keywordtype">int</span> offset, <span class="keyword">const</span> Oid &amp;koid,
<a name="l01332"></a>01332                        <span class="keyword">const</span> CellHeader &amp;o)<span class="keyword"> const</span>
<a name="l01333"></a>01333 <span class="keyword"></span>{
<a name="l01334"></a>01334   CellHeader to;
<a name="l01335"></a>01335   h2x_overhead(&amp;to, &amp;o);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 <span class="preprocessor">#if 0</span>
<a name="l01338"></a>01338 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!dont_check) {
<a name="l01339"></a>01339     std::map&lt;unsigned int, bool&gt; map;
<a name="l01340"></a>01340     map[offset] = <span class="keyword">true</span>;
<a name="l01341"></a>01341 
<a name="l01342"></a>01342     <span class="keywordtype">unsigned</span> off = o.cell_free_prev;
<a name="l01343"></a>01343     <span class="keywordtype">bool</span> loop = <span class="keyword">false</span>;
<a name="l01344"></a>01344     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; !loop &amp;&amp; n &lt; 10; n++) {
<a name="l01345"></a>01345       <span class="keywordflow">if</span> (off == NullOffset)
<a name="l01346"></a>01346         <span class="keywordflow">break</span>;
<a name="l01347"></a>01347 
<a name="l01348"></a>01348       <span class="keywordflow">if</span> (loop) {
<a name="l01349"></a>01349         printf(<span class="stringliteral">&quot;offset %u at #%d\n&quot;</span>, off, n);
<a name="l01350"></a>01350       }
<a name="l01351"></a>01351 
<a name="l01352"></a>01352       <span class="keywordflow">if</span> (map.find(off) != map.end()) {
<a name="l01353"></a>01353         printf(<span class="stringliteral">&quot;loop in writeCellHeader prev %u at #%d [prev %d]\n&quot;</span>, off, n, o.cell_free_prev);
<a name="l01354"></a>01354         loop = <span class="keyword">true</span>;
<a name="l01355"></a>01355       }
<a name="l01356"></a>01356       map[off] = <span class="keyword">true</span>;
<a name="l01357"></a>01357       CellHeader no;
<a name="l01358"></a>01358       readCellHeader(off, koid, no);
<a name="l01359"></a>01359       off = no.cell_free_prev;
<a name="l01360"></a>01360     }
<a name="l01361"></a>01361     <span class="keywordflow">if</span> (loop)
<a name="l01362"></a>01362       printf(<span class="stringliteral">&quot;*** prev EOL\n&quot;</span>);
<a name="l01363"></a>01363 
<a name="l01364"></a>01364     off = o.cell_free_next;
<a name="l01365"></a>01365     loop = <span class="keyword">false</span>;
<a name="l01366"></a>01366     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; !loop &amp;&amp; n &lt; 10; n++) {
<a name="l01367"></a>01367       <span class="keywordflow">if</span> (off == NullOffset)
<a name="l01368"></a>01368         <span class="keywordflow">break</span>;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370       <span class="keywordflow">if</span> (loop) {
<a name="l01371"></a>01371         printf(<span class="stringliteral">&quot;offset %u at #%d\n&quot;</span>, off, n);
<a name="l01372"></a>01372       }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374       <span class="keywordflow">if</span> (map.find(off) != map.end()) {
<a name="l01375"></a>01375         printf(<span class="stringliteral">&quot;loop in writeCellHeader next %u at #%d [next %d]\n&quot;</span>, off, n, o.cell_free_next);
<a name="l01376"></a>01376         loop = <span class="keyword">true</span>;
<a name="l01377"></a>01377       }
<a name="l01378"></a>01378       map[off] = <span class="keyword">true</span>;
<a name="l01379"></a>01379       CellHeader no;
<a name="l01380"></a>01380       readCellHeader(off, koid, no);
<a name="l01381"></a>01381       off = no.cell_free_next;
<a name="l01382"></a>01382     }
<a name="l01383"></a>01383     <span class="keywordflow">if</span> (loop)
<a name="l01384"></a>01384       printf(<span class="stringliteral">&quot;*** next EOL\n&quot;</span>);
<a name="l01385"></a>01385   }
<a name="l01386"></a>01386 <span class="preprocessor">#endif</span>
<a name="l01387"></a>01387 <span class="preprocessor"></span>  <span class="keywordflow">return</span> objectWrite(dbh, offset, <span class="keyword">sizeof</span>(CellHeader), &amp;to, &amp;koid);
<a name="l01388"></a>01388 }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390 Status
<a name="l01391"></a>01391 HIdx::readCListHeaders(CListHeader *&amp;chds)<span class="keyword"> const</span>
<a name="l01392"></a>01392 <span class="keyword"></span>{
<a name="l01393"></a>01393   Status s;
<a name="l01394"></a>01394   <span class="keywordtype">int</span> len = get_gkey(version)(hidx.key_count);
<a name="l01395"></a>01395   chds = <span class="keyword">new</span> CListHeader[len];
<a name="l01396"></a>01396 
<a name="l01397"></a>01397   s = objectRead(dbh, 0, len * <span class="keyword">sizeof</span>(CListHeader), chds,
<a name="l01398"></a>01398                     DefaultLock, 0, 0, &amp;treeoid);
<a name="l01399"></a>01399   <span class="keywordflow">if</span> (s)
<a name="l01400"></a>01400     <span class="keywordflow">return</span> s;
<a name="l01401"></a>01401   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = KEY_OFF; i &lt; len; i++)
<a name="l01402"></a>01402     x2h_chd(&amp;chds[i]);
<a name="l01403"></a>01403   <span class="keywordflow">return</span> Success;
<a name="l01404"></a>01404 }
<a name="l01405"></a>01405 
<a name="l01406"></a>01406 Status
<a name="l01407"></a>01407 HIdx::writeCListHeaders(<span class="keyword">const</span> CListHeader *chds)<span class="keyword"> const</span>
<a name="l01408"></a>01408 <span class="keyword"></span>{
<a name="l01409"></a>01409   <span class="keywordtype">int</span> len = get_gkey(version)(hidx.key_count);
<a name="l01410"></a>01410   CListHeader *nchds = <span class="keyword">new</span> CListHeader[len];
<a name="l01411"></a>01411   memcpy(nchds, chds, <span class="keyword">sizeof</span>(CListHeader) * KEY_OFF);
<a name="l01412"></a>01412   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = KEY_OFF; i &lt; len; i++)
<a name="l01413"></a>01413     h2x_chd(&amp;nchds[i], &amp;chds[i]);
<a name="l01414"></a>01414 
<a name="l01415"></a>01415   Status s = objectWrite(dbh, 0, len * <span class="keyword">sizeof</span>(CListHeader), nchds,
<a name="l01416"></a>01416                                &amp;treeoid);
<a name="l01417"></a>01417   <span class="keyword">delete</span> [] nchds;
<a name="l01418"></a>01418   <span class="keywordflow">return</span> s;
<a name="l01419"></a>01419 }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421 Status
<a name="l01422"></a>01422 HIdx::writeCListHeader(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k, <span class="keyword">const</span> CListHeader &amp;chd)<span class="keyword"> const</span>
<a name="l01423"></a>01423 <span class="keyword"></span>{
<a name="l01424"></a>01424   Status s;
<a name="l01425"></a>01425   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l01426"></a>01426 
<a name="l01427"></a>01427   CListHeader tchd;
<a name="l01428"></a>01428   h2x_chd(&amp;tchd, &amp;chd);
<a name="l01429"></a>01429   s = objectWrite(dbh, gkey(k) * <span class="keyword">sizeof</span>(CListHeader), <span class="keyword">sizeof</span>(CListHeader), &amp;tchd,
<a name="l01430"></a>01430                      &amp;treeoid);
<a name="l01431"></a>01431   <span class="keywordflow">if</span> (s)
<a name="l01432"></a>01432     <span class="keywordflow">return</span> s;
<a name="l01433"></a>01433   <span class="keywordflow">return</span> Success;
<a name="l01434"></a>01434 }
<a name="l01435"></a>01435 
<a name="l01436"></a>01436 Status
<a name="l01437"></a>01437 HIdx::dumpMemoryMap(<span class="keyword">const</span> CListHeader &amp;chd, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg, FILE *fd)
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439   fprintf(fd, <span class="stringliteral">&quot;%sFREE MEMORY MAP {\n&quot;</span>, msg);
<a name="l01440"></a>01440   Oid prev;
<a name="l01441"></a>01441   Oid koid = chd.clobj_free_first;
<a name="l01442"></a>01442   memset(&amp;prev, 0, <span class="keyword">sizeof</span>(prev));
<a name="l01443"></a>01443 
<a name="l01444"></a>01444   <span class="keywordtype">int</span> cnt = 0;
<a name="l01445"></a>01445   <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l01446"></a>01446     Status s;
<a name="l01447"></a>01447     CListObjHeader h;
<a name="l01448"></a>01448     s = readCListObjHeader(koid, h);
<a name="l01449"></a>01449     <span class="keywordflow">if</span> (s)
<a name="l01450"></a>01450       <span class="keywordflow">return</span> s;
<a name="l01451"></a>01451     fprintf(fd, <span class="stringliteral">&quot;\tObject %s -&gt; Free Whole: %d, Free Count: %d\n&quot;</span>,
<a name="l01452"></a>01452             getOidString(&amp;koid), h.free_whole, h.free_cnt);
<a name="l01453"></a>01453     assert(!memcmp(&amp;h.clobj_free_prev, &amp;prev, <span class="keyword">sizeof</span>(prev)));
<a name="l01454"></a>01454     prev = koid;
<a name="l01455"></a>01455     koid = h.clobj_free_next;
<a name="l01456"></a>01456     cnt++;
<a name="l01457"></a>01457   }
<a name="l01458"></a>01458   fprintf(fd, <span class="stringliteral">&quot;} -&gt; %d cells in FREE MAP\n\n&quot;</span>, cnt);
<a name="l01459"></a>01459 
<a name="l01460"></a>01460   cnt = 0;
<a name="l01461"></a>01461   memset(&amp;prev, 0, <span class="keyword">sizeof</span>(prev));
<a name="l01462"></a>01462   koid = chd.clobj_first;
<a name="l01463"></a>01463 
<a name="l01464"></a>01464   fprintf(fd, <span class="stringliteral">&quot;%sMEMORY MAP {\n&quot;</span>, msg);
<a name="l01465"></a>01465   fprintf(fd, <span class="stringliteral">&quot;\tFirst Free %s\n&quot;</span>, getOidString(&amp;chd.clobj_free_first));
<a name="l01466"></a>01466   <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l01467"></a>01467     Status s;
<a name="l01468"></a>01468     CListObjHeader h;
<a name="l01469"></a>01469     s = readCListObjHeader(koid, h);
<a name="l01470"></a>01470     <span class="keywordflow">if</span> (s)
<a name="l01471"></a>01471       <span class="keywordflow">return</span> s;
<a name="l01472"></a>01472     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
<a name="l01473"></a>01473     s = objectSizeGet(dbh, &amp;sz, DefaultLock, &amp;koid);
<a name="l01474"></a>01474     <span class="keywordflow">if</span> (s)
<a name="l01475"></a>01475       <span class="keywordflow">return</span> s;
<a name="l01476"></a>01476     <span class="keywordtype">int</span> cur = <span class="keyword">sizeof</span>(CListObjHeader);
<a name="l01477"></a>01477     fprintf(fd, <span class="stringliteral">&quot;\tObject %s {\n\t  First Free: %d\n\t  Free Whole: %d\n\t  &quot;</span>
<a name="l01478"></a>01478             <span class="stringliteral">&quot;Free Count: %d\n\t  Alloc Count: %d\n\t  Size: %d\n\t  &quot;</span>
<a name="l01479"></a>01479             <span class="stringliteral">&quot;Free Prev: %s\n\t  Free Next: %s\n&quot;</span>,
<a name="l01480"></a>01480             getOidString(&amp;koid), h.cell_free_first,
<a name="l01481"></a>01481             h.free_whole, h.free_cnt, h.alloc_cnt, sz,
<a name="l01482"></a>01482             getOidString(&amp;h.clobj_free_prev), getOidString(&amp;h.clobj_free_next));
<a name="l01483"></a>01483     assert(!memcmp(&amp;h.clobj_prev, &amp;prev, <span class="keyword">sizeof</span>(prev)));
<a name="l01484"></a>01484 
<a name="l01485"></a>01485     <span class="keywordtype">int</span> busy_cnt = 0;
<a name="l01486"></a>01486     <span class="keywordtype">int</span> free_cnt = 0;
<a name="l01487"></a>01487     <span class="keywordflow">while</span> (cur + <span class="keyword">sizeof</span>(CellHeader) &lt;= sz) {
<a name="l01488"></a>01488       CellHeader to;
<a name="l01489"></a>01489       s = readCellHeader(cur, koid, to);
<a name="l01490"></a>01490       <span class="keywordflow">if</span> (s)
<a name="l01491"></a>01491         <span class="keywordflow">return</span> s;
<a name="l01492"></a>01492       fprintf(fd, <span class="stringliteral">&quot;\t  #%d size %d %s&quot;</span>, cur,
<a name="l01493"></a>01493               to.size, (to.free ? <span class="stringliteral">&quot;free&quot;</span> : <span class="stringliteral">&quot;busy&quot;</span>));
<a name="l01494"></a>01494 
<a name="l01495"></a>01495       <span class="keywordflow">if</span> (to.cell_free_prev != NullOffset)
<a name="l01496"></a>01496         fprintf(fd, <span class="stringliteral">&quot; free_prev %d&quot;</span>, to.cell_free_prev);
<a name="l01497"></a>01497 
<a name="l01498"></a>01498       <span class="keywordflow">if</span> (to.cell_free_next != NullOffset)
<a name="l01499"></a>01499         fprintf(fd, <span class="stringliteral">&quot; free_next %d&quot;</span>, to.cell_free_next);
<a name="l01500"></a>01500 
<a name="l01501"></a>01501       fprintf(fd, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01502"></a>01502       <span class="keywordflow">if</span> (to.free) free_cnt++;
<a name="l01503"></a>01503       <span class="keywordflow">else</span> busy_cnt++;
<a name="l01504"></a>01504       cur += to.size + <span class="keyword">sizeof</span>(CellHeader);
<a name="l01505"></a>01505     }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     fprintf(fd, <span class="stringliteral">&quot;\t}\n&quot;</span>);
<a name="l01508"></a>01508     <span class="comment">// now checking</span>
<a name="l01509"></a>01509     assert(free_cnt == h.free_cnt);
<a name="l01510"></a>01510     assert(busy_cnt == h.alloc_cnt);
<a name="l01511"></a>01511     <span class="keywordtype">int</span> free_cur = h.cell_free_first;
<a name="l01512"></a>01512     <span class="keywordtype">int</span> free_prev = NullOffset;
<a name="l01513"></a>01513     <span class="keywordtype">int</span> free_size = 0;
<a name="l01514"></a>01514     <span class="keywordflow">while</span> (free_cur != NullOffset) {
<a name="l01515"></a>01515       CellHeader to;
<a name="l01516"></a>01516       s = readCellHeader(free_cur, koid, to);
<a name="l01517"></a>01517       <span class="keywordflow">if</span> (s)
<a name="l01518"></a>01518         <span class="keywordflow">return</span> s;
<a name="l01519"></a>01519       <span class="keywordflow">if</span> (!to.free || to.cell_free_prev != free_prev) {
<a name="l01520"></a>01520         fprintf(fd, <span class="stringliteral">&quot;#%d free, free_prev %d %d\n&quot;</span>, free_cur, to.cell_free_prev,
<a name="l01521"></a>01521                 free_prev);
<a name="l01522"></a>01522         assert(0);
<a name="l01523"></a>01523       }
<a name="l01524"></a>01524       assert(to.free);
<a name="l01525"></a>01525       assert(to.cell_free_prev == free_prev);
<a name="l01526"></a>01526       free_size += to.size;
<a name="l01527"></a>01527       free_prev = free_cur;
<a name="l01528"></a>01528       free_cur = to.cell_free_next;
<a name="l01529"></a>01529     }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531     assert(free_size == h.free_whole);
<a name="l01532"></a>01532     prev = koid;
<a name="l01533"></a>01533     koid = h.clobj_next;
<a name="l01534"></a>01534     cnt++;
<a name="l01535"></a>01535   }
<a name="l01536"></a>01536   fprintf(fd, <span class="stringliteral">&quot;} -&gt; %d cells in MAP\n&quot;</span>, cnt);
<a name="l01537"></a>01537 
<a name="l01538"></a>01538   <span class="keywordflow">return</span> Success;
<a name="l01539"></a>01539 }
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 Status
<a name="l01542"></a>01542 HIdx::makeObject(CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k, Oid &amp;koid, <span class="keywordtype">int</span> &amp;offset,
<a name="l01543"></a>01543                     CListObjHeader &amp;h, CellHeader &amp;o, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> objsize)
<a name="l01544"></a>01544 {
<a name="l01545"></a>01545 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l01546"></a>01546 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;making object\n&quot;</span>);
<a name="l01547"></a>01547 <span class="preprocessor">#endif</span>
<a name="l01548"></a>01548 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bsz = bsize; <span class="comment">// changed the 30/01/02</span>
<a name="l01549"></a>01549   objsize += <span class="keyword">sizeof</span>(CellHeader); <span class="comment">// added the 30/01/02</span>
<a name="l01550"></a>01550   <span class="keywordtype">int</span> utsize = (bsz &gt; objsize ? bsz : objsize);
<a name="l01551"></a>01551   <span class="comment">//int size = sizeof(CListObjHeader) + sizeof(CellHeader) + utsize;</span>
<a name="l01552"></a>01552   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = <span class="keyword">sizeof</span>(CListObjHeader) + utsize;
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 <span class="preprocessor">#ifdef OPTIM_LARGE_OBJECTS</span>
<a name="l01555"></a>01555 <span class="preprocessor"></span>
<a name="l01556"></a>01556   <span class="keywordtype">int</span> alloc_size = <span class="keyword">sizeof</span>(CListObjHeader) + <span class="keyword">sizeof</span>(CellHeader);
<a name="l01557"></a>01557 <span class="preprocessor">#ifdef HAS_ALLOC_BUFFER</span>
<a name="l01558"></a>01558 <span class="preprocessor"></span>  <span class="keywordtype">char</span> *d = makeobj_buffer.alloc(alloc_size);
<a name="l01559"></a>01559 <span class="preprocessor">#else</span>
<a name="l01560"></a>01560 <span class="preprocessor"></span>  <span class="keywordtype">char</span> *d = (<span class="keywordtype">char</span> *)m_malloc(alloc_size);
<a name="l01561"></a>01561 <span class="preprocessor">#endif</span>
<a name="l01562"></a>01562 <span class="preprocessor"></span>
<a name="l01563"></a>01563 <span class="preprocessor">#else</span>
<a name="l01564"></a>01564 <span class="preprocessor"></span>
<a name="l01565"></a>01565 <span class="preprocessor">#ifdef HAS_ALLOC_BUFFER</span>
<a name="l01566"></a>01566 <span class="preprocessor"></span>  <span class="keywordtype">char</span> *d = makeobj_buffer.alloc(size);
<a name="l01567"></a>01567 <span class="preprocessor">#else</span>
<a name="l01568"></a>01568 <span class="preprocessor"></span>  <span class="keywordtype">char</span> *d = (<span class="keywordtype">char</span> *)m_malloc(size);
<a name="l01569"></a>01569 <span class="preprocessor">#endif</span>
<a name="l01570"></a>01570 <span class="preprocessor"></span>
<a name="l01571"></a>01571 <span class="preprocessor">#endif</span>
<a name="l01572"></a>01572 <span class="preprocessor"></span>
<a name="l01573"></a>01573   offset = <span class="keyword">sizeof</span>(CListObjHeader);
<a name="l01574"></a>01574   h.size = size;
<a name="l01575"></a>01575   h.free_cnt = 1;
<a name="l01576"></a>01576   h.alloc_cnt = 0;
<a name="l01577"></a>01577   h.free_whole = utsize - <span class="keyword">sizeof</span>(CellHeader);
<a name="l01578"></a>01578   h.cell_free_first = <span class="keyword">sizeof</span>(CListObjHeader);
<a name="l01579"></a>01579   h.clobj_prev = chd.clobj_last;
<a name="l01580"></a>01580   mset(&amp;h.clobj_next, 0, <span class="keyword">sizeof</span>(h.clobj_next));
<a name="l01581"></a>01581   mset(&amp;h.clobj_free_prev, 0, <span class="keyword">sizeof</span>(h.clobj_free_prev));
<a name="l01582"></a>01582 
<a name="l01583"></a>01583   <span class="comment">// changed the 20/05/02</span>
<a name="l01584"></a>01584   <span class="comment">//mset(&amp;h.clobj_free_next, 0, sizeof(h.clobj_free_next));</span>
<a name="l01585"></a>01585   h.clobj_free_next = chd.clobj_free_first;
<a name="l01586"></a>01586 
<a name="l01587"></a>01587   o.free = 1;
<a name="l01588"></a>01588   o.size = utsize - <span class="keyword">sizeof</span>(CellHeader); <span class="comment">//  + sizeof(CellHeader); // 26/12/01: added &apos;+ sizeof(CellHeader)&apos;</span>
<a name="l01589"></a>01589   o.cell_free_next = NullOffset;
<a name="l01590"></a>01590   o.cell_free_prev = NullOffset;
<a name="l01591"></a>01591   CListObjHeader xh;
<a name="l01592"></a>01592   h2x_header(&amp;xh, &amp;h);
<a name="l01593"></a>01593   mcp(d, &amp;xh, <span class="keyword">sizeof</span>(CListObjHeader));
<a name="l01594"></a>01594   CellHeader xo;
<a name="l01595"></a>01595   h2x_overhead(&amp;xo, &amp;o);
<a name="l01596"></a>01596   mcp(d + <span class="keyword">sizeof</span>(CListObjHeader), &amp;xo, <span class="keyword">sizeof</span>(CellHeader));
<a name="l01597"></a>01597   
<a name="l01598"></a>01598 <span class="preprocessor">#ifdef OPTIM_LARGE_OBJECTS</span>
<a name="l01599"></a>01599 <span class="preprocessor"></span>  Status s = objectCreate(dbh, ObjectNone, size, hidx.dspid, &amp;koid);
<a name="l01600"></a>01600   <span class="keywordflow">if</span> (s) {free (d); <span class="keywordflow">return</span> s;}
<a name="l01601"></a>01601   s = objectWrite(dbh, 0, alloc_size, d, &amp;koid);
<a name="l01602"></a>01602 <span class="preprocessor">#else</span>
<a name="l01603"></a>01603 <span class="preprocessor"></span>  Status s = objectCreate(dbh, d, size, hidx.dspid, &amp;koid);
<a name="l01604"></a>01604 <span class="preprocessor">#endif</span>
<a name="l01605"></a>01605 <span class="preprocessor"></span>
<a name="l01606"></a>01606 <span class="preprocessor">#ifndef HAS_ALLOC_BUFFER</span>
<a name="l01607"></a>01607 <span class="preprocessor"></span>  free(d);
<a name="l01608"></a>01608 <span class="preprocessor">#endif</span>
<a name="l01609"></a>01609 <span class="preprocessor"></span>
<a name="l01610"></a>01610   <span class="keywordflow">if</span> (s)
<a name="l01611"></a>01611     <span class="keywordflow">return</span> s;
<a name="l01612"></a>01612 
<a name="l01613"></a>01613   <span class="keywordflow">if</span> (!chd.clobj_first.getNX())
<a name="l01614"></a>01614     chd.clobj_first = koid;
<a name="l01615"></a>01615   <span class="keywordflow">else</span> {
<a name="l01616"></a>01616     Oid xoid;
<a name="l01617"></a>01617     h2x_oid(&amp;xoid, &amp;koid);
<a name="l01618"></a>01618     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_next), <span class="keyword">sizeof</span>(Oid), &amp;xoid,
<a name="l01619"></a>01619                        &amp;chd.clobj_last);
<a name="l01620"></a>01620     <span class="keywordflow">if</span> (s)
<a name="l01621"></a>01621       <span class="keywordflow">return</span> s;
<a name="l01622"></a>01622   }
<a name="l01623"></a>01623 
<a name="l01624"></a>01624   chd.clobj_last = koid;
<a name="l01625"></a>01625   <span class="comment">// changed the 20/05/02</span>
<a name="l01626"></a>01626   <span class="keywordflow">return</span> insertObjectInFreeList(chd, chd_k, h, koid);
<a name="l01627"></a>01627 }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l01630"></a>01630 HIdx::inFreeList(<span class="keyword">const</span> CListObjHeader &amp;h, <span class="keyword">const</span> CListHeader &amp;chd, <span class="keyword">const</span> Oid &amp;koid)
<a name="l01631"></a>01631 {
<a name="l01632"></a>01632   <span class="keywordflow">return</span> h.clobj_free_prev.getNX() || h.clobj_free_next.getNX() || chd.clobj_free_first.getNX() == koid.getNX();
<a name="l01633"></a>01633 }
<a name="l01634"></a>01634 
<a name="l01635"></a>01635 Status
<a name="l01636"></a>01636 HIdx::insertObjectInFreeList(CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k, CListObjHeader &amp;h,
<a name="l01637"></a>01637                                 <span class="keyword">const</span> Oid &amp;koid)
<a name="l01638"></a>01638 {
<a name="l01639"></a>01639 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l01640"></a>01640 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;hidx: insertion of a new cell!\n&quot;</span>);
<a name="l01641"></a>01641 <span class="preprocessor">#endif</span>
<a name="l01642"></a>01642 <span class="preprocessor"></span>  Status s;
<a name="l01643"></a>01643   <span class="keywordflow">if</span> (chd.clobj_free_first.getNX()) {
<a name="l01644"></a>01644     Oid xoid;
<a name="l01645"></a>01645     h2x_oid(&amp;xoid, &amp;koid);
<a name="l01646"></a>01646     s = objectWrite(dbh, OFFSET(CListObjHeader, clobj_free_prev),
<a name="l01647"></a>01647                        <span class="keyword">sizeof</span>(Oid), &amp;xoid, &amp;chd.clobj_free_first);
<a name="l01648"></a>01648     <span class="keywordflow">if</span> (s)
<a name="l01649"></a>01649       <span class="keywordflow">return</span> s;
<a name="l01650"></a>01650   }
<a name="l01651"></a>01651 
<a name="l01652"></a>01652   h.clobj_free_next = chd.clobj_free_first;
<a name="l01653"></a>01653   chd.clobj_free_first = koid;
<a name="l01654"></a>01654 
<a name="l01655"></a>01655   <span class="keywordflow">return</span> writeCListHeader(chd_k, chd);
<a name="l01656"></a>01656 }
<a name="l01657"></a>01657 
<a name="l01658"></a>01658 Boolean
<a name="l01659"></a>01659 HIdx::candidateForExtension(<span class="keyword">const</span> CListObjHeader &amp;h)
<a name="l01660"></a>01660 {
<a name="l01661"></a>01661   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size_n = hidx.impl_hints[XCoef_Hints] * h.size;
<a name="l01662"></a>01662   <span class="keywordflow">return</span> (size_n &lt;= (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)hidx.impl_hints[SzMax_Hints] ? True : False);
<a name="l01663"></a>01663 }
<a name="l01664"></a>01664 
<a name="l01665"></a>01665 Status
<a name="l01666"></a>01666 HIdx::extendObject(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k, Oid &amp;koid,
<a name="l01667"></a>01667                       CListObjHeader &amp;h, <span class="keywordtype">int</span> &amp;offset, CellHeader &amp;o,
<a name="l01668"></a>01668                       Boolean &amp;extended)
<a name="l01669"></a>01669 {
<a name="l01670"></a>01670   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size_n = hidx.impl_hints[XCoef_Hints] * h.size;
<a name="l01671"></a>01671   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size_inc = size_n - h.size;
<a name="l01672"></a>01672 
<a name="l01673"></a>01673   printf(<span class="stringliteral">&quot;extendObject %s [%d &gt; %d &amp;&amp; %d &gt; %d] ?\n&quot;</span>, getOidString(&amp;koid),
<a name="l01674"></a>01674          size_n, hidx.impl_hints[SzMax_Hints],
<a name="l01675"></a>01675          size_inc + h.free_whole, size);
<a name="l01676"></a>01676 
<a name="l01677"></a>01677   <span class="keywordflow">if</span> (size_n &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)hidx.impl_hints[SzMax_Hints] &amp;&amp;
<a name="l01678"></a>01678       (!size || size_inc + h.free_whole &gt;= size)) {
<a name="l01679"></a>01679     extended = False;
<a name="l01680"></a>01680     <span class="keywordflow">return</span> Success;
<a name="l01681"></a>01681   }
<a name="l01682"></a>01682     
<a name="l01683"></a>01683   Status s;
<a name="l01684"></a>01684   memset(&amp;o, 0, <span class="keyword">sizeof</span>(CellHeader));
<a name="l01685"></a>01685   offset = h.cell_free_first;
<a name="l01686"></a>01686   <span class="keywordtype">int</span> lastoffset = NullOffset;
<a name="l01687"></a>01687   <span class="keywordflow">while</span> (offset != NullOffset) {
<a name="l01688"></a>01688     s = readCellHeader(offset, koid, o);
<a name="l01689"></a>01689     <span class="keywordflow">if</span> (s)
<a name="l01690"></a>01690       <span class="keywordflow">return</span> s;
<a name="l01691"></a>01691     lastoffset = offset;
<a name="l01692"></a>01692     offset = o.cell_free_next;
<a name="l01693"></a>01693   }
<a name="l01694"></a>01694 
<a name="l01695"></a>01695   Oid nkoid;
<a name="l01696"></a>01696   <span class="keywordflow">if</span> (o.free) {
<a name="l01697"></a>01697 <span class="preprocessor">#ifdef TRACK_MAP        </span>
<a name="l01698"></a>01698 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;object %s can be extended from %d to %d -&gt; extend overhead\n&quot;</span>,
<a name="l01699"></a>01699            getOidString(&amp;koid), h.size, size_n);
<a name="l01700"></a>01700 <span class="preprocessor">#endif</span>
<a name="l01701"></a>01701 <span class="preprocessor"></span>    o.size += size_inc;
<a name="l01702"></a>01702     offset = lastoffset;
<a name="l01703"></a>01703     s = writeCellHeader(offset, koid, o);
<a name="l01704"></a>01704     <span class="keywordflow">if</span> (s)
<a name="l01705"></a>01705       <span class="keywordflow">return</span> s;
<a name="l01706"></a>01706     extended = True;
<a name="l01707"></a>01707     h.free_whole += size_inc;
<a name="l01708"></a>01708     <span class="keywordtype">int</span> osize = h.size;
<a name="l01709"></a>01709     h.size = size_n;
<a name="l01710"></a>01710     s = writeCListObjHeader(koid, h);
<a name="l01711"></a>01711     <span class="keywordflow">if</span> (s)
<a name="l01712"></a>01712       <span class="keywordflow">return</span> s;
<a name="l01713"></a>01713     <span class="keywordflow">if</span> (isPhysicalOid(dbh, &amp;koid)) {
<a name="l01714"></a>01714       s = modifyObjectSize(osize, size_n, koid, nkoid);
<a name="l01715"></a>01715       <span class="keywordflow">if</span> (s)
<a name="l01716"></a>01716         <span class="keywordflow">return</span> s;
<a name="l01717"></a>01717       s = replaceObjectInList(chd, chd_k, h, koid, nkoid);
<a name="l01718"></a>01718       <span class="keywordflow">if</span> (s)
<a name="l01719"></a>01719         <span class="keywordflow">return</span> s;
<a name="l01720"></a>01720       koid = nkoid;
<a name="l01721"></a>01721       <span class="keywordflow">return</span> Success;
<a name="l01722"></a>01722     }
<a name="l01723"></a>01723     <span class="keywordflow">return</span> objectSizeModify(dbh, size_n, True, &amp;koid);
<a name="l01724"></a>01724   }
<a name="l01725"></a>01725 
<a name="l01726"></a>01726   <span class="keywordflow">if</span> (!size || size_inc &gt;= size) {
<a name="l01727"></a>01727     <span class="comment">// must done a new overhead AND must chain with last overhead !</span>
<a name="l01728"></a>01728 <span class="preprocessor">#ifdef TRACK_MAP        </span>
<a name="l01729"></a>01729 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;object %s can be extended from %d to %d (diff=%d) -&gt; new overhead\n&quot;</span>,
<a name="l01730"></a>01730            getOidString(&amp;koid), h.size, size_n, size_inc - size);
<a name="l01731"></a>01731 <span class="preprocessor">#endif</span>
<a name="l01732"></a>01732 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (isPhysicalOid(dbh, &amp;koid)) {
<a name="l01733"></a>01733       s = modifyObjectSize(h.size, size_n, koid, nkoid);
<a name="l01734"></a>01734       <span class="keywordflow">if</span> (s)
<a name="l01735"></a>01735         <span class="keywordflow">return</span> s;
<a name="l01736"></a>01736       s = replaceObjectInList(chd, chd_k, h, koid, nkoid);
<a name="l01737"></a>01737       koid = nkoid;
<a name="l01738"></a>01738     }
<a name="l01739"></a>01739     <span class="keywordflow">else</span>
<a name="l01740"></a>01740       s = objectSizeModify(dbh, size_n, True, &amp;koid);
<a name="l01741"></a>01741     <span class="keywordflow">if</span> (s)
<a name="l01742"></a>01742       <span class="keywordflow">return</span> s;
<a name="l01743"></a>01743     offset = h.size;
<a name="l01744"></a>01744     <span class="keywordflow">if</span> (lastoffset != NullOffset) {
<a name="l01745"></a>01745       o.cell_free_next = offset;
<a name="l01746"></a>01746       s = writeCellHeader(lastoffset, koid, o);
<a name="l01747"></a>01747       <span class="keywordflow">if</span> (s)
<a name="l01748"></a>01748         <span class="keywordflow">return</span> s;
<a name="l01749"></a>01749     }
<a name="l01750"></a>01750     <span class="keywordflow">else</span>
<a name="l01751"></a>01751       h.cell_free_first = offset;
<a name="l01752"></a>01752 
<a name="l01753"></a>01753     o.size = size_inc - <span class="keyword">sizeof</span>(CellHeader);
<a name="l01754"></a>01754     o.free = 1;
<a name="l01755"></a>01755     o.cell_free_prev = lastoffset;
<a name="l01756"></a>01756     o.cell_free_next = NullOffset;
<a name="l01757"></a>01757     extended = True;
<a name="l01758"></a>01758     h.free_cnt++;
<a name="l01759"></a>01759     h.free_whole += size_inc - <span class="keyword">sizeof</span>(CellHeader);
<a name="l01760"></a>01760     h.size = size_n;
<a name="l01761"></a>01761     <span class="keywordflow">if</span> (!inFreeList(h, chd, koid)) {
<a name="l01762"></a>01762       <span class="comment">//      printf(&quot;not in free list ?\n&quot;);</span>
<a name="l01763"></a>01763       s = insertObjectInFreeList(chd, chd_k, h, koid);
<a name="l01764"></a>01764       <span class="keywordflow">if</span> (s)
<a name="l01765"></a>01765         <span class="keywordflow">return</span> s;
<a name="l01766"></a>01766     }
<a name="l01767"></a>01767     s = writeCListObjHeader(koid, h);
<a name="l01768"></a>01768     <span class="keywordflow">if</span> (s)
<a name="l01769"></a>01769       <span class="keywordflow">return</span> s;
<a name="l01770"></a>01770     <span class="keywordflow">return</span> writeCellHeader(offset, koid, o);
<a name="l01771"></a>01771   }
<a name="l01772"></a>01772   <span class="comment">//printf(&quot;not extended\n&quot;);</span>
<a name="l01773"></a>01773   <span class="keywordflow">return</span> Success;
<a name="l01774"></a>01774 }
<a name="l01775"></a>01775 
<a name="l01776"></a>01776 <span class="preprocessor">#ifndef NO_EXTEND</span>
<a name="l01777"></a>01777 <span class="preprocessor"></span>Status
<a name="l01778"></a>01778 HIdx::getObjectToExtend(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k,
<a name="l01779"></a>01779                            Oid &amp;koid, CListObjHeader &amp;h, <span class="keywordtype">int</span> &amp;offset, CellHeader &amp;o,
<a name="l01780"></a>01780                            Boolean &amp;found)
<a name="l01781"></a>01781 {
<a name="l01782"></a>01782   ------ CODE NOT USED ----
<a name="l01783"></a>01783   found = False;
<a name="l01784"></a>01784   Status s;
<a name="l01785"></a>01785   koid = chd.first;
<a name="l01786"></a>01786 
<a name="l01787"></a>01787   <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l01788"></a>01788     s = readCListObjHeader(koid, h);
<a name="l01789"></a>01789     <span class="keywordflow">if</span> (s)
<a name="l01790"></a>01790       <span class="keywordflow">return</span> s;
<a name="l01791"></a>01791     <span class="comment">/*</span>
<a name="l01792"></a>01792 <span class="comment">    printf(&quot;KOID %s h.clobj_prev %s h.clobj_next %s\n&quot;, getOidString(&amp;koid),</span>
<a name="l01793"></a>01793 <span class="comment">           getOidString(&amp;h.clobj_prev),</span>
<a name="l01794"></a>01794 <span class="comment">           getOidString(&amp;h.clobj_next));</span>
<a name="l01795"></a>01795 <span class="comment">    */</span>
<a name="l01796"></a>01796     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size_n = hidx.impl_hints[XCoef_Hints] * h.size;
<a name="l01797"></a>01797     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size_inc = size_n - h.size;
<a name="l01798"></a>01798     <span class="keywordflow">if</span> (size_n &lt;= hidx.impl_hints[SzMax_Hints] &amp;&amp;
<a name="l01799"></a>01799         size_inc + h.free_whole &gt;= size) {
<a name="l01800"></a>01800       memset(&amp;o, 0, <span class="keyword">sizeof</span>(CellHeader));
<a name="l01801"></a>01801       offset = h.cell_free_first;
<a name="l01802"></a>01802       <span class="keywordtype">int</span> lastoffset = NullOffset;
<a name="l01803"></a>01803       <span class="keywordflow">while</span> (offset != NullOffset) {
<a name="l01804"></a>01804         s = readCellHeader(offset, koid, o);
<a name="l01805"></a>01805         <span class="keywordflow">if</span> (s)
<a name="l01806"></a>01806           <span class="keywordflow">return</span> s;
<a name="l01807"></a>01807         lastoffset = offset;
<a name="l01808"></a>01808         offset = o.cell_free_next;
<a name="l01809"></a>01809       }
<a name="l01810"></a>01810 
<a name="l01811"></a>01811       Oid nkoid;
<a name="l01812"></a>01812       <span class="keywordflow">if</span> (o.free) {
<a name="l01813"></a>01813 <span class="preprocessor">#ifdef TRACK_MAP        </span>
<a name="l01814"></a>01814 <span class="preprocessor"></span>        printf(<span class="stringliteral">&quot;object %s can be extended from %d to %d -&gt; extend overhead\n&quot;</span>,
<a name="l01815"></a>01815                getOidString(&amp;koid), h.size, size_n);
<a name="l01816"></a>01816 <span class="preprocessor">#endif</span>
<a name="l01817"></a>01817 <span class="preprocessor"></span>        o.size += size_inc;
<a name="l01818"></a>01818         offset = lastoffset;
<a name="l01819"></a>01819         s = writeCellHeader(offset, koid, o);
<a name="l01820"></a>01820         <span class="keywordflow">if</span> (s)
<a name="l01821"></a>01821           <span class="keywordflow">return</span> s;
<a name="l01822"></a>01822         found = True;
<a name="l01823"></a>01823         h.free_whole += size_inc;
<a name="l01824"></a>01824         <span class="keywordtype">int</span> osize = h.size;
<a name="l01825"></a>01825         h.size = size_n;
<a name="l01826"></a>01826         s = writeCListObjHeader(koid, h);
<a name="l01827"></a>01827         <span class="keywordflow">if</span> (s)
<a name="l01828"></a>01828           <span class="keywordflow">return</span> s;
<a name="l01829"></a>01829         <span class="keywordflow">if</span> (isPhysicalOid(dbh, &amp;koid)) {
<a name="l01830"></a>01830           s = modifyObjectSize(osize, size_n, koid, nkoid);
<a name="l01831"></a>01831           <span class="keywordflow">if</span> (s)
<a name="l01832"></a>01832             <span class="keywordflow">return</span> s;
<a name="l01833"></a>01833           s = replaceObjectInList(chd, chd_k, h, koid, nkoid);
<a name="l01834"></a>01834           <span class="keywordflow">if</span> (s)
<a name="l01835"></a>01835             <span class="keywordflow">return</span> s;
<a name="l01836"></a>01836           koid = nkoid;
<a name="l01837"></a>01837           <span class="keywordflow">return</span> Success;
<a name="l01838"></a>01838         }
<a name="l01839"></a>01839         <span class="keywordflow">return</span> objectSizeModify(dbh, size_n, True, &amp;koid);
<a name="l01840"></a>01840       }
<a name="l01841"></a>01841       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (size_inc &gt;= size) {
<a name="l01842"></a>01842         <span class="comment">// must done a new overhead AND must chain with last overhead !</span>
<a name="l01843"></a>01843 <span class="preprocessor">#ifdef TRACK_MAP        </span>
<a name="l01844"></a>01844 <span class="preprocessor"></span>        printf(<span class="stringliteral">&quot;object %s can be extended from %d to %d -&gt; new overhead\n&quot;</span>,
<a name="l01845"></a>01845                getOidString(&amp;koid), h.size, size_n);
<a name="l01846"></a>01846 <span class="preprocessor">#endif</span>
<a name="l01847"></a>01847 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (isPhysicalOid(dbh, &amp;koid)) {
<a name="l01848"></a>01848           s = modifyObjectSize(h.size, size_n, koid, nkoid);
<a name="l01849"></a>01849           <span class="keywordflow">if</span> (s)
<a name="l01850"></a>01850             <span class="keywordflow">return</span> s;
<a name="l01851"></a>01851           s = replaceObjectInList(chd, chd_k, h, koid, nkoid);
<a name="l01852"></a>01852           koid = nkoid;
<a name="l01853"></a>01853         }
<a name="l01854"></a>01854         <span class="keywordflow">else</span>
<a name="l01855"></a>01855           s = objectSizeModify(dbh, size_n, True, &amp;koid);
<a name="l01856"></a>01856         <span class="keywordflow">if</span> (s)
<a name="l01857"></a>01857           <span class="keywordflow">return</span> s;
<a name="l01858"></a>01858         offset = h.size;
<a name="l01859"></a>01859         <span class="keywordflow">if</span> (lastoffset != NullOffset) {
<a name="l01860"></a>01860   ------ CODE NOT USED ----
<a name="l01861"></a>01861           o.cell_free_next = offset;
<a name="l01862"></a>01862           s = writeCellHeader(lastoffset, koid, o);
<a name="l01863"></a>01863           <span class="keywordflow">if</span> (s)
<a name="l01864"></a>01864             <span class="keywordflow">return</span> s;
<a name="l01865"></a>01865         }
<a name="l01866"></a>01866         <span class="keywordflow">else</span>
<a name="l01867"></a>01867           h.cell_free_first = offset;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869         o.size = size_inc - <span class="keyword">sizeof</span>(CellHeader);
<a name="l01870"></a>01870         o.free = 1;
<a name="l01871"></a>01871         o.cell_free_prev = lastoffset;
<a name="l01872"></a>01872         o.cell_free_next = NullOffset;
<a name="l01873"></a>01873         found = True;
<a name="l01874"></a>01874         h.free_cnt++;
<a name="l01875"></a>01875         h.free_whole += size_inc - <span class="keyword">sizeof</span>(CellHeader);
<a name="l01876"></a>01876         h.size = size_n;
<a name="l01877"></a>01877         <span class="keywordflow">if</span> (!inFreeList(h, chd, koid)) {
<a name="l01878"></a>01878           s = insertObjectInFreeList(chd, chd_k, h, koid);
<a name="l01879"></a>01879           <span class="keywordflow">if</span> (s)
<a name="l01880"></a>01880             <span class="keywordflow">return</span> s;
<a name="l01881"></a>01881         }
<a name="l01882"></a>01882         s = writeCListObjHeader(koid, h);
<a name="l01883"></a>01883         <span class="keywordflow">if</span> (s)
<a name="l01884"></a>01884           <span class="keywordflow">return</span> s;
<a name="l01885"></a>01885         <span class="keywordflow">return</span> writeCellHeader(offset, koid, o);
<a name="l01886"></a>01886       }
<a name="l01887"></a>01887     }
<a name="l01888"></a>01888     koid = h.clobj_next;
<a name="l01889"></a>01889   }
<a name="l01890"></a>01890 
<a name="l01891"></a>01891 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l01892"></a>01892 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;no candidates for extension\n&quot;</span>);
<a name="l01893"></a>01893 <span class="preprocessor">#endif</span>
<a name="l01894"></a>01894 <span class="preprocessor"></span>  <span class="keywordflow">return</span> Success;
<a name="l01895"></a>01895 }
<a name="l01896"></a>01896 <span class="preprocessor">#endif</span>
<a name="l01897"></a>01897 <span class="preprocessor"></span>
<a name="l01898"></a>01898 <span class="keywordtype">int</span> hidx_gccnt;
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 Status
<a name="l01901"></a>01901 HIdx::getCell(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, CListHeader &amp;chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k,
<a name="l01902"></a>01902                  Oid &amp;koid, CListObjHeader &amp;h, <span class="keywordtype">int</span> &amp;offset, CellHeader &amp;o)
<a name="l01903"></a>01903 {
<a name="l01904"></a>01904   Status s;
<a name="l01905"></a>01905   koid = chd.clobj_free_first;
<a name="l01906"></a>01906   hidx_gccnt = 0;
<a name="l01907"></a>01907 <span class="preprocessor">#ifdef TRUSS1_GC</span>
<a name="l01908"></a>01908 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_whole = 0, min_whole = ~0, max_whole = 0;
<a name="l01909"></a>01909 <span class="preprocessor">#endif</span>
<a name="l01910"></a>01910 <span class="preprocessor"></span><span class="preprocessor">#ifdef TRUSS2_GC</span>
<a name="l01911"></a>01911 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;getcell size %d\n&quot;</span>, size);
<a name="l01912"></a>01912 <span class="preprocessor">#endif</span>
<a name="l01913"></a>01913 <span class="preprocessor"></span>
<a name="l01914"></a>01914   <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l01915"></a>01915     s = readCListObjHeader(koid, h);
<a name="l01916"></a>01916     <span class="keywordflow">if</span> (s)
<a name="l01917"></a>01917       <span class="keywordflow">return</span> s;
<a name="l01918"></a>01918 
<a name="l01919"></a>01919     Boolean extended;
<a name="l01920"></a>01920     <span class="keywordflow">if</span> (uextend) {
<a name="l01921"></a>01921       <span class="keywordflow">if</span> (h.free_whole &lt; size) {
<a name="l01922"></a>01922         s = extendObject(size, chd, chd_k, koid, h, offset, o, extended);
<a name="l01923"></a>01923         <span class="keywordflow">if</span> (s)
<a name="l01924"></a>01924           <span class="keywordflow">return</span> s;
<a name="l01925"></a>01925       }
<a name="l01926"></a>01926     }
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 <span class="preprocessor">#ifdef TRUSS1_GC</span>
<a name="l01929"></a>01929 <span class="preprocessor"></span>    total_whole += h.free_whole;
<a name="l01930"></a>01930     <span class="keywordflow">if</span> (h.free_whole &gt; max_whole)
<a name="l01931"></a>01931       max_whole = h.free_whole;
<a name="l01932"></a>01932     <span class="keywordflow">if</span> (h.free_whole &lt; min_whole)
<a name="l01933"></a>01933       min_whole = h.free_whole;
<a name="l01934"></a>01934 <span class="preprocessor">#endif</span>
<a name="l01935"></a>01935 <span class="preprocessor"></span><span class="preprocessor">#ifdef TRUSS2_GC</span>
<a name="l01936"></a>01936 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;getcell free_whole %d #%d\n&quot;</span>, h.free_whole, hidx_gccnt);
<a name="l01937"></a>01937 <span class="preprocessor">#endif</span>
<a name="l01938"></a>01938 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (h.free_whole &gt;= size) { <span class="comment">// optimisation added 29/01/02</span>
<a name="l01939"></a>01939       offset = h.cell_free_first;
<a name="l01940"></a>01940       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; offset != NullOffset; n++) {
<a name="l01941"></a>01941         <span class="keywordflow">if</span> (n &amp;&amp; offset == h.cell_free_first || n &gt; 100) {
<a name="l01942"></a>01942           <span class="comment">//printf(&quot;free_whole %u %d looping #%d\n&quot;, h.free_whole, size, n);</span>
<a name="l01943"></a>01943           <span class="keywordflow">break</span>;
<a name="l01944"></a>01944         }
<a name="l01945"></a>01945         s = readCellHeader(offset, koid, o);
<a name="l01946"></a>01946         <span class="keywordflow">if</span> (s)
<a name="l01947"></a>01947           <span class="keywordflow">return</span> s;
<a name="l01948"></a>01948         <span class="keywordflow">if</span> (o.free &amp;&amp; o.size &gt;= size) {
<a name="l01949"></a>01949           <span class="comment">//printf(&quot;object found free_next %d size %d\n&quot;, o.cell_free_next, o.size);</span>
<a name="l01950"></a>01950           <span class="keywordflow">return</span> Success;
<a name="l01951"></a>01951         }
<a name="l01952"></a>01952 
<a name="l01953"></a>01953         <span class="keywordflow">if</span> (uextend) {
<a name="l01954"></a>01954           s = extendObject(size, chd, chd_k, koid, h, offset, o, extended);
<a name="l01955"></a>01955           <span class="keywordflow">if</span> (s)
<a name="l01956"></a>01956             <span class="keywordflow">return</span> s;
<a name="l01957"></a>01957           <span class="keywordflow">if</span> (extended &amp;&amp; o.free &amp;&amp; o.size &gt;= size) {
<a name="l01958"></a>01958             <span class="comment">//printf(&quot;object extended and found\n&quot;);</span>
<a name="l01959"></a>01959             <span class="keywordflow">return</span> Success;
<a name="l01960"></a>01960           }
<a name="l01961"></a>01961         }
<a name="l01962"></a>01962 
<a name="l01963"></a>01963         <span class="comment">//COMPARE_OFFSET(offset, o.cell_free_next, &quot;looping&quot;);</span>
<a name="l01964"></a>01964         offset = o.cell_free_next;
<a name="l01965"></a>01965       }
<a name="l01966"></a>01966     }
<a name="l01967"></a>01967     koid = h.clobj_free_next;
<a name="l01968"></a>01968 <span class="preprocessor">#ifdef TRUSS1_GC</span>
<a name="l01969"></a>01969 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (hidx_gccnt == 10000) {
<a name="l01970"></a>01970       printf(<span class="stringliteral">&quot;hidx getcell size=%d, avg_whole=%f, min_whole=%d, &quot;</span>
<a name="l01971"></a>01971              <span class="stringliteral">&quot;max_whole=%d\n&quot;</span>,
<a name="l01972"></a>01972              size, (<span class="keywordtype">float</span>)total_whole/hidx_gccnt, min_whole, max_whole);
<a name="l01973"></a>01973       fflush(stdout);
<a name="l01974"></a>01974     }
<a name="l01975"></a>01975 <span class="preprocessor">#endif</span>
<a name="l01976"></a>01976 <span class="preprocessor"></span><span class="preprocessor">#ifdef OPT_FREELIST</span>
<a name="l01977"></a>01977 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (hidx.keysz != VarSize)
<a name="l01978"></a>01978       <span class="keywordflow">break</span>;
<a name="l01979"></a>01979     <span class="comment">// WARNING : 29/06/02 this test is to avoid too many search in free list</span>
<a name="l01980"></a>01980     <span class="comment">// but this can make holes in the free list !</span>
<a name="l01981"></a>01981     <span class="keywordflow">if</span> (hidx_gccnt &gt; 4) {
<a name="l01982"></a>01982       <span class="keywordflow">break</span>;
<a name="l01983"></a>01983     }
<a name="l01984"></a>01984 <span class="preprocessor">#endif</span>
<a name="l01985"></a>01985 <span class="preprocessor"></span>    hidx_gccnt++;
<a name="l01986"></a>01986   }
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 <span class="preprocessor">#ifndef NO_EXTEND</span>
<a name="l01989"></a>01989 <span class="preprocessor"></span>  Boolean found;
<a name="l01990"></a>01990   s = getObjectToExtend(size, chd, chd_k, koid, h, offset, o, found);
<a name="l01991"></a>01991   <span class="keywordflow">if</span> (s || found) <span class="keywordflow">return</span> s;
<a name="l01992"></a>01992 <span class="preprocessor">#endif</span>
<a name="l01993"></a>01993 <span class="preprocessor"></span>
<a name="l01994"></a>01994   <span class="comment">// not found</span>
<a name="l01995"></a>01995   <span class="keywordflow">return</span> makeObject(chd, chd_k, koid, offset, h, o, size);
<a name="l01996"></a>01996 }
<a name="l01997"></a>01997 
<a name="l01998"></a>01998 <span class="preprocessor">#ifdef CI_STORE</span>
<a name="l01999"></a>01999 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l02000"></a>02000 lowstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *key)
<a name="l02001"></a>02001 {
<a name="l02002"></a>02002   <span class="keywordtype">char</span> *q = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(key)+1];
<a name="l02003"></a>02003   <span class="keywordtype">char</span> c, *p;
<a name="l02004"></a>02004 
<a name="l02005"></a>02005   <span class="keywordflow">for</span> (p = q; c = *key++; p++) {
<a name="l02006"></a>02006     <span class="keywordflow">if</span> (c &gt;= <span class="charliteral">&apos;A&apos;</span> &amp;&amp; c &lt;= <span class="charliteral">&apos;Z&apos;</span>)
<a name="l02007"></a>02007       *p = c + <span class="charliteral">&apos;a&apos;</span> - <span class="charliteral">&apos;A&apos;</span>;
<a name="l02008"></a>02008     <span class="keywordflow">else</span>
<a name="l02009"></a>02009       *p = c;
<a name="l02010"></a>02010   }
<a name="l02011"></a>02011 
<a name="l02012"></a>02012   *p = 0;
<a name="l02013"></a>02013   <span class="keywordflow">return</span> q;
<a name="l02014"></a>02014 }
<a name="l02015"></a>02015 <span class="preprocessor">#endif</span>
<a name="l02016"></a>02016 <span class="preprocessor"></span>
<a name="l02017"></a>02017 <span class="keywordtype">void</span> stop_imm1() { }
<a name="l02018"></a>02018 
<a name="l02019"></a>02019 <span class="keyword">static</span> <span class="keywordtype">int</span> WRITE_HEADER;
<a name="l02020"></a>02020 
<a name="l02021"></a>02021 HIdx::HKey::HKey(HIdx *hidx, <span class="keyword">const</span> <span class="keywordtype">void</span> *_key, <span class="keywordtype">bool</span> copy) : hidx(hidx)
<a name="l02022"></a>02022 {
<a name="l02023"></a>02023   <span class="keywordflow">if</span> (copy) {
<a name="l02024"></a>02024     Boolean isstr = hidx-&gt;hidx.keytype == Idx::tString ? True : False;
<a name="l02025"></a>02025     key = copy_key(_key, hidx-&gt;hidx.keysz, isstr);
<a name="l02026"></a>02026     _garbage = <span class="keyword">true</span>;
<a name="l02027"></a>02027   }
<a name="l02028"></a>02028   <span class="keywordflow">else</span> {
<a name="l02029"></a>02029     key = _key;
<a name="l02030"></a>02030     _garbage = <span class="keyword">false</span>;
<a name="l02031"></a>02031   }
<a name="l02032"></a>02032 }
<a name="l02033"></a>02033 
<a name="l02034"></a>02034 HIdx::HKey::HKey(<span class="keyword">const</span> HIdx::HKey &amp;hkey)
<a name="l02035"></a>02035 {
<a name="l02036"></a>02036   _garbage = <span class="keyword">false</span>;
<a name="l02037"></a>02037   key = 0;
<a name="l02038"></a>02038   hidx = 0;
<a name="l02039"></a>02039   *<span class="keyword">this</span> = hkey;
<a name="l02040"></a>02040 }
<a name="l02041"></a>02041 
<a name="l02042"></a>02042 HIdx::HKey&amp; HIdx::HKey::operator=(<span class="keyword">const</span> HIdx::HKey &amp;hkey)
<a name="l02043"></a>02043 {
<a name="l02044"></a>02044   <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;hkey)
<a name="l02045"></a>02045     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02046"></a>02046 
<a name="l02047"></a>02047   garbage();
<a name="l02048"></a>02048 
<a name="l02049"></a>02049   _garbage = hkey._garbage;
<a name="l02050"></a>02050   hidx = hkey.hidx;
<a name="l02051"></a>02051 
<a name="l02052"></a>02052   <span class="keywordflow">if</span> (_garbage) {
<a name="l02053"></a>02053     Boolean isstr = hkey.hidx-&gt;hidx.keytype == Idx::tString ? True : False;
<a name="l02054"></a>02054     key = copy_key(hkey.key, hkey.hidx-&gt;hidx.keysz, isstr);
<a name="l02055"></a>02055   }
<a name="l02056"></a>02056   <span class="keywordflow">else</span> {
<a name="l02057"></a>02057     key = hkey.key;
<a name="l02058"></a>02058   }
<a name="l02059"></a>02059 
<a name="l02060"></a>02060   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02061"></a>02061 }
<a name="l02062"></a>02062 
<a name="l02063"></a><a class="code" href="classeyedbsm_1_1HIdx.html#aab1d52d08d7b3f4d3523654f6d984479">02063</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#aab1d52d08d7b3f4d3523654f6d984479" title="Not yet documented.">HIdx::insert_cache</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *xdata)
<a name="l02064"></a>02064 {
<a name="l02065"></a>02065   std::vector&lt;const void *&gt; xdata_v;
<a name="l02066"></a>02066   xdata_v.push_back(xdata);
<a name="l02067"></a>02067   <span class="keywordflow">return</span> <a class="code" href="classeyedbsm_1_1HIdx.html#aab1d52d08d7b3f4d3523654f6d984479" title="Not yet documented.">insert_cache</a>(key, xdata_v);
<a name="l02068"></a>02068 }
<a name="l02069"></a>02069 
<a name="l02070"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a77c174edecddbb35f5df1da4b282e44e">02070</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#aab1d52d08d7b3f4d3523654f6d984479" title="Not yet documented.">HIdx::insert_cache</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, std::vector&lt;const void *&gt; &amp;xdata_v)
<a name="l02071"></a>02071 {
<a name="l02072"></a>02072   <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l02073"></a>02073     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;Variable data size hash index: cannot use cache&quot;</span>);
<a name="l02074"></a>02074   }
<a name="l02075"></a>02075 
<a name="l02076"></a>02076   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xdata_v_cnt = xdata_v.size();
<a name="l02077"></a>02077   HKey hkey(<span class="keyword">this</span>, key, <span class="keyword">true</span>);
<a name="l02078"></a>02078   std::vector&lt;const void *&gt; &amp;v = cache_map[hkey];
<a name="l02079"></a>02079   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; xdata_v_cnt; n++) {
<a name="l02080"></a>02080     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[hidx.datasz];
<a name="l02081"></a>02081     memcpy(data, xdata_v[n], hidx.datasz);
<a name="l02082"></a>02082     v.push_back((<span class="keyword">const</span> <span class="keywordtype">void</span> *)data);
<a name="l02083"></a>02083   }
<a name="l02084"></a>02084   <span class="keywordflow">return</span> Success;
<a name="l02085"></a>02085 }
<a name="l02086"></a>02086 
<a name="l02087"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a54fef60f1dedcbf237513e413a5f0c4e">02087</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a54fef60f1dedcbf237513e413a5f0c4e" title="Not yet documented.">HIdx::flush_cache</a>(<span class="keywordtype">bool</span> insert_data)
<a name="l02088"></a>02088 {
<a name="l02089"></a>02089   std::map&lt;HKey, std::vector&lt;const void *&gt; &gt;::iterator begin = cache_map.begin();
<a name="l02090"></a>02090   std::map&lt;HKey, std::vector&lt;const void *&gt; &gt;::iterator end = cache_map.end();
<a name="l02091"></a>02091 
<a name="l02092"></a>02092   <span class="keywordflow">while</span> (begin != end) {
<a name="l02093"></a>02093     std::vector&lt;const void *&gt; &amp;v = (*begin).second;
<a name="l02094"></a>02094     <span class="keywordflow">if</span> (insert_data) {
<a name="l02095"></a>02095       Status s = <a class="code" href="classeyedbsm_1_1HIdx.html#a6e08c1ba728aa7c4e0a8421694412f7e" title="Not yet documented.">insert</a>((*begin).first.getKey(), v);
<a name="l02096"></a>02096       <span class="keywordflow">if</span> (s)
<a name="l02097"></a>02097         <span class="keywordflow">return</span> s;
<a name="l02098"></a>02098     }
<a name="l02099"></a>02099 
<a name="l02100"></a>02100     std::vector&lt;const void *&gt;::iterator b = v.begin();
<a name="l02101"></a>02101     std::vector&lt;const void *&gt;::iterator e = v.end();
<a name="l02102"></a>02102     <span class="keywordflow">while</span> (b != e) {
<a name="l02103"></a>02103       <span class="keyword">delete</span> [] (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(*b);
<a name="l02104"></a>02104       ++b;
<a name="l02105"></a>02105     }
<a name="l02106"></a>02106     v.clear();
<a name="l02107"></a>02107     ++begin;
<a name="l02108"></a>02108   }
<a name="l02109"></a>02109 
<a name="l02110"></a>02110   cache_map.clear();
<a name="l02111"></a>02111   <span class="keywordflow">return</span> Success;
<a name="l02112"></a>02112 }
<a name="l02113"></a>02113 
<a name="l02114"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a6e08c1ba728aa7c4e0a8421694412f7e">02114</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a6e08c1ba728aa7c4e0a8421694412f7e" title="Not yet documented.">HIdx::insert</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *xdata)
<a name="l02115"></a>02115 { 
<a name="l02116"></a>02116   <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l02117"></a>02117     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;Variable data size hash index: the data size must be given at insertion, use HIdx::insert(const void *key, const void *data, unsigned int datasz)&quot;</span>);
<a name="l02118"></a>02118   }
<a name="l02119"></a>02119 
<a name="l02120"></a>02120   <span class="keywordflow">return</span> insert_perform(key, xdata, 0);
<a name="l02121"></a>02121 }
<a name="l02122"></a>02122 
<a name="l02123"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a4ad69bd4437213ab9fef47858d50776c">02123</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a6e08c1ba728aa7c4e0a8421694412f7e" title="Not yet documented.">HIdx::insert</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz)
<a name="l02124"></a>02124 {
<a name="l02125"></a>02125   <span class="keywordflow">if</span> (!<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>() &amp;&amp; hidx.datasz != datasz) {
<a name="l02126"></a>02126     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;Fixed size hash index: the data size must be equals to %u&quot;</span>, hidx.datasz);
<a name="l02127"></a>02127   }
<a name="l02128"></a>02128 
<a name="l02129"></a>02129   <span class="keywordflow">return</span> insert_perform(key, data, datasz);
<a name="l02130"></a>02130 }
<a name="l02131"></a>02131 
<a name="l02132"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a5ec3f6469f85e161e977008c6b6ffeef">02132</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a6e08c1ba728aa7c4e0a8421694412f7e" title="Not yet documented.">HIdx::insert</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, std::vector&lt;const void *&gt; &amp;xdata_v)
<a name="l02133"></a>02133 { 
<a name="l02134"></a>02134   <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l02135"></a>02135     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;Variable data size hash index: the method HIdx::insert(const void *key, std::vector&lt;const void *&gt; &amp;data_v) is not supported&quot;</span>);
<a name="l02136"></a>02136   }
<a name="l02137"></a>02137 
<a name="l02138"></a>02138   <span class="keywordflow">return</span> insert_perform(key, xdata_v, 0);
<a name="l02139"></a>02139 }
<a name="l02140"></a>02140 
<a name="l02141"></a>02141 Status HIdx::insert_perform(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *xdata, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz)
<a name="l02142"></a>02142 {
<a name="l02143"></a>02143   std::vector&lt;const void *&gt; xdata_v;
<a name="l02144"></a>02144   xdata_v.push_back(xdata);
<a name="l02145"></a>02145   <span class="keywordflow">return</span> insert_perform(key, xdata_v, datasz);
<a name="l02146"></a>02146 }
<a name="l02147"></a>02147 
<a name="l02148"></a>02148 Status HIdx::insert_perform(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, std::vector&lt;const void *&gt; &amp;xdata_v, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xdatasz)
<a name="l02149"></a>02149 { 
<a name="l02150"></a>02150   Status s;
<a name="l02151"></a>02151 
<a name="l02152"></a>02152   <span class="keywordflow">if</span> (stat)
<a name="l02153"></a>02153     <span class="keywordflow">return</span> stat;
<a name="l02154"></a>02154 
<a name="l02155"></a>02155   <span class="keywordflow">if</span> (s = checkOpened())
<a name="l02156"></a>02156     <span class="keywordflow">return</span> s;
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 <span class="preprocessor">#ifdef CACHE_FOR_LOCK</span>
<a name="l02159"></a>02159 <span class="preprocessor"></span>  <span class="comment">// oplist.insertObjectLast(new INSLink(this, key));</span>
<a name="l02160"></a>02160   <span class="comment">// return Success;</span>
<a name="l02161"></a>02161 <span class="preprocessor">#endif</span>
<a name="l02162"></a>02162 <span class="preprocessor"></span>
<a name="l02163"></a>02163   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz = xdatasz;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x;
<a name="l02166"></a>02166   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;
<a name="l02167"></a>02167   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l02168"></a>02168   s = get_key(x, key, &amp;size);
<a name="l02169"></a>02169   <span class="keywordflow">if</span> (s)
<a name="l02170"></a>02170     <span class="keywordflow">return</span> s;
<a name="l02171"></a>02171 
<a name="l02172"></a>02172   IdxLock lockx(dbh, treeoid);
<a name="l02173"></a>02173   s = lockx.lock();
<a name="l02174"></a>02174   <span class="keywordflow">if</span> (s)
<a name="l02175"></a>02175     <span class="keywordflow">return</span> s;
<a name="l02176"></a>02176 
<a name="l02177"></a>02177   <span class="keywordtype">int</span> xdata_v_cnt = xdata_v.size();
<a name="l02178"></a>02178 
<a name="l02179"></a>02179   <span class="comment">/*</span>
<a name="l02180"></a>02180 <span class="comment">  CListHeader chd;</span>
<a name="l02181"></a>02181 <span class="comment">  s = readCListHeader(x, chd);</span>
<a name="l02182"></a>02182 <span class="comment">  if (s)</span>
<a name="l02183"></a>02183 <span class="comment">    return s;</span>
<a name="l02184"></a>02184 <span class="comment">  */</span>
<a name="l02185"></a>02185 
<a name="l02186"></a>02186 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02187"></a>02187 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;\nINSERT at #%d\n&quot;</span>, x);
<a name="l02188"></a>02188 <span class="preprocessor">#endif</span>
<a name="l02189"></a>02189 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *rdata = 0;
<a name="l02190"></a>02190   <span class="keyword">const</span> <span class="keywordtype">void</span> *xdata = 0;
<a name="l02191"></a>02191   <span class="keywordtype">bool</span> direct;
<a name="l02192"></a>02192   <span class="keywordflow">if</span> (datasz) {
<a name="l02193"></a>02193     assert(xdata_v_cnt == 1);
<a name="l02194"></a>02194     direct = <span class="keyword">true</span>;
<a name="l02195"></a>02195     <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l02196"></a>02196       size += datasz + DATASZ_SIZE;
<a name="l02197"></a>02197     }
<a name="l02198"></a>02198     <span class="keywordflow">else</span> {
<a name="l02199"></a>02199       size += datasz - hidx.datasz;
<a name="l02200"></a>02200     }
<a name="l02201"></a>02201   }
<a name="l02202"></a>02202   <span class="keywordflow">else</span> {
<a name="l02203"></a>02203     direct = <span class="keyword">false</span>;
<a name="l02204"></a>02204     datasz = hidx.datasz;
<a name="l02205"></a>02205   }
<a name="l02206"></a>02206 
<a name="l02207"></a>02207   <span class="keywordflow">if</span> (data_grouped_by_key &amp;&amp; !direct) {
<a name="l02208"></a>02208 <span class="preprocessor">#ifdef CHECK_CHAIN</span>
<a name="l02209"></a>02209 <span class="preprocessor"></span>    CListHeader chd2;
<a name="l02210"></a>02210     s = readCListHeader(x, chd2);
<a name="l02211"></a>02211     <span class="keywordflow">if</span> (s)
<a name="l02212"></a>02212       <span class="keywordflow">return</span> s;
<a name="l02213"></a>02213     
<a name="l02214"></a>02214     checkChain(&amp;chd2, <span class="stringliteral">&quot;before remove&quot;</span>);
<a name="l02215"></a>02215 <span class="preprocessor">#endif</span>
<a name="l02216"></a>02216 <span class="preprocessor"></span>    Boolean found = False;
<a name="l02217"></a>02217     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datacnt = 0;
<a name="l02218"></a>02218     s = remove_perform(key, 0, 0, &amp;found, &amp;rdata, &amp;datacnt, 0, xdata_v_cnt);
<a name="l02219"></a>02219     <span class="keywordflow">if</span> (s)
<a name="l02220"></a>02220       <span class="keywordflow">return</span> s;
<a name="l02221"></a>02221 
<a name="l02222"></a>02222 <span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l02223"></a>02223 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;remove_perform(found=%d)\n&quot;</span>, found);
<a name="l02224"></a>02224 <span class="preprocessor">#endif</span>
<a name="l02225"></a>02225 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!found) {
<a name="l02226"></a>02226       rdata = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[data_group_sz(xdata_v_cnt, <span class="keyword">this</span>)];
<a name="l02227"></a>02227     }
<a name="l02228"></a>02228 
<a name="l02229"></a>02229     <span class="comment">//  size += data_group_sz(datacnt, this);</span>
<a name="l02230"></a>02230     <span class="comment">//  size += data_group_sz(datacnt, this) + (xdata_v_cnt - 1) * hidx.datasz;</span>
<a name="l02231"></a>02231     size += data_group_sz(datacnt + xdata_v_cnt - 1, <span class="keyword">this</span>);
<a name="l02232"></a>02232 <span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l02233"></a>02233 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;insert(datacnt = %d)\n&quot;</span>, datacnt);
<a name="l02234"></a>02234 <span class="preprocessor">#endif</span>
<a name="l02235"></a>02235 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nn = 0; nn &lt; xdata_v_cnt; nn++) {
<a name="l02236"></a>02236       memcpy(rdata + data_group_sz(datacnt + nn, <span class="keyword">this</span>), xdata_v[nn], hidx.datasz);
<a name="l02237"></a>02237     }
<a name="l02238"></a>02238     datacnt += xdata_v_cnt;
<a name="l02239"></a>02239 <span class="preprocessor">#ifdef VARSZ_DATACNT</span>
<a name="l02240"></a>02240 <span class="preprocessor"></span>    s = h2x_datacnt_cpy(rdata, &amp;datacnt);
<a name="l02241"></a>02241     <span class="keywordflow">if</span> (s)
<a name="l02242"></a>02242       <span class="keywordflow">return</span> s;
<a name="l02243"></a>02243 <span class="preprocessor">#else</span>
<a name="l02244"></a>02244 <span class="preprocessor"></span>    h2x_32_cpy(rdata, &amp;datacnt);
<a name="l02245"></a>02245 <span class="preprocessor">#endif</span>
<a name="l02246"></a>02246 <span class="preprocessor"></span>    xdata = (<span class="keyword">const</span> <span class="keywordtype">void</span> *)rdata;
<a name="l02247"></a>02247     datasz = data_group_sz(datacnt, <span class="keyword">this</span>);
<a name="l02248"></a>02248     
<a name="l02249"></a>02249     <span class="comment">/*</span>
<a name="l02250"></a>02250 <span class="comment">      1. one must search for key</span>
<a name="l02251"></a>02251 <span class="comment">      2. if (found) {</span>
<a name="l02252"></a>02252 <span class="comment">      get the entry (ddata and dsize) : datacnt data(s)</span>
<a name="l02253"></a>02253 <span class="comment">      copy the entry : new unsigned char[dsize + datasz], memcpy(ndata, ddata, dsize)</span>
<a name="l02254"></a>02254 <span class="comment">      recompute the size : size += datasz</span>
<a name="l02255"></a>02255 <span class="comment">      remove the full entry by calling removeDataGroup</span>
<a name="l02256"></a>02256 <span class="comment">      [add W: ++datacnt data(s)+datai by calling insertDataGroup()]:</span>
<a name="l02257"></a>02257 <span class="comment">      memcpy(ndata + dsize, data, datasz)</span>
<a name="l02258"></a>02258 <span class="comment">      ++ndata.datacnt</span>
<a name="l02259"></a>02259 <span class="comment">      xdata = ndata</span>
<a name="l02260"></a>02260 <span class="comment">      =&gt; all in only one index scan</span>
<a name="l02261"></a>02261 <span class="comment">      }</span>
<a name="l02262"></a>02262 <span class="comment">      else {</span>
<a name="l02263"></a>02263 <span class="comment">      create the entry : ndata = new unsigned char[size + sizeof(datacnt)]</span>
<a name="l02264"></a>02264 <span class="comment">      recompute the size : size += sizeof(datacnt)</span>
<a name="l02265"></a>02265 <span class="comment">      ndata.datacnt = 1;</span>
<a name="l02266"></a>02266 <span class="comment">      memcpy(ndata + sizeof(datacnt), data, datasz)</span>
<a name="l02267"></a>02267 <span class="comment">      xdata = ndata</span>
<a name="l02268"></a>02268 <span class="comment">      }</span>
<a name="l02269"></a>02269 <span class="comment">      // at the end of the method: delete [] ndata</span>
<a name="l02270"></a>02270 <span class="comment">    */</span>
<a name="l02271"></a>02271   }
<a name="l02272"></a>02272   <span class="keywordflow">else</span> {
<a name="l02273"></a>02273     <span class="keywordflow">if</span> (xdata_v_cnt == 1) {
<a name="l02274"></a>02274       xdata = xdata_v[0];
<a name="l02275"></a>02275     }
<a name="l02276"></a>02276     <span class="keywordflow">else</span> {
<a name="l02277"></a>02277       assert(!xdatasz);
<a name="l02278"></a>02278       <span class="comment">// 18/09/07: this is wrong !!</span>
<a name="l02279"></a>02279       rdata = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[hidx.datasz * xdata_v_cnt];
<a name="l02280"></a>02280       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nn = 0; nn &lt; xdata_v_cnt; nn++) {
<a name="l02281"></a>02281         memcpy(rdata + nn * hidx.datasz, xdata_v[nn], hidx.datasz);
<a name="l02282"></a>02282       }
<a name="l02283"></a>02283       xdata = (<span class="keyword">const</span> <span class="keywordtype">void</span> *)rdata;
<a name="l02284"></a>02284     }
<a name="l02285"></a>02285   }
<a name="l02286"></a>02286 
<a name="l02287"></a>02287   CListHeader chd;
<a name="l02288"></a>02288   s = readCListHeader(x, chd);
<a name="l02289"></a>02289   <span class="keywordflow">if</span> (s)
<a name="l02290"></a>02290     <span class="keywordflow">return</span> s;
<a name="l02291"></a>02291 
<a name="l02292"></a>02292 <span class="preprocessor">#ifdef CHECK_CHAIN</span>
<a name="l02293"></a>02293 <span class="preprocessor"></span>  checkChain(&amp;chd, <span class="stringliteral">&quot;before getcell&quot;</span>);
<a name="l02294"></a>02294 <span class="preprocessor">#endif</span>
<a name="l02295"></a>02295 <span class="preprocessor"></span>
<a name="l02296"></a>02296   CellHeader o;
<a name="l02297"></a>02297   CListObjHeader h;
<a name="l02298"></a>02298   Oid koid;
<a name="l02299"></a>02299   <span class="keywordtype">int</span> offset = 0;
<a name="l02300"></a>02300   s = getCell(size, chd, x, koid, h, offset, o);
<a name="l02301"></a>02301   <span class="keywordflow">if</span> (s) {
<a name="l02302"></a>02302     <span class="keyword">delete</span> [] rdata;
<a name="l02303"></a>02303     <span class="keywordflow">return</span> s;
<a name="l02304"></a>02304   }
<a name="l02305"></a>02305 
<a name="l02306"></a>02306 <span class="preprocessor">#ifdef CHECK_CHAIN</span>
<a name="l02307"></a>02307 <span class="preprocessor"></span>  CListHeader chd2;
<a name="l02308"></a>02308   s = readCListHeader(x, chd2);
<a name="l02309"></a>02309   <span class="keywordflow">if</span> (s)
<a name="l02310"></a>02310     <span class="keywordflow">return</span> s;
<a name="l02311"></a>02311 
<a name="l02312"></a>02312   checkChain(&amp;chd2, <span class="stringliteral">&quot;after getcell&quot;</span>);
<a name="l02313"></a>02313 <span class="preprocessor">#endif</span>
<a name="l02314"></a>02314 <span class="preprocessor"></span>
<a name="l02315"></a>02315 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02316"></a>02316 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;GETTING CELL offset=%d, koid=%s\n&quot;</span>, offset,
<a name="l02317"></a>02317          getOidString(&amp;koid));
<a name="l02318"></a>02318 <span class="preprocessor">#endif</span>
<a name="l02319"></a>02319 <span class="preprocessor"></span>
<a name="l02320"></a>02320 <span class="preprocessor">#ifdef TRACK_MAP_2</span>
<a name="l02321"></a>02321 <span class="preprocessor"></span>  (void)dumpMemoryMap(chd, <span class="stringliteral">&quot;before inserting &quot;</span>);
<a name="l02322"></a>02322 <span class="preprocessor">#endif</span>
<a name="l02323"></a>02323 <span class="preprocessor"></span>  s = insert_realize(chd, x, key, size, xdata, koid, h, offset, o, datasz);
<a name="l02324"></a>02324 <span class="preprocessor">#ifdef TRACK_MAP_2</span>
<a name="l02325"></a>02325 <span class="preprocessor"></span>  (void)dumpMemoryMap(chd, <span class="stringliteral">&quot;after inserting &quot;</span>);
<a name="l02326"></a>02326 <span class="preprocessor">#endif</span>
<a name="l02327"></a>02327 <span class="preprocessor"></span>  <span class="keyword">delete</span> [] rdata;
<a name="l02328"></a>02328 
<a name="l02329"></a>02329 <span class="preprocessor">#ifdef CHECK_CHAIN</span>
<a name="l02330"></a>02330 <span class="preprocessor"></span>  s = readCListHeader(x, chd2);
<a name="l02331"></a>02331   <span class="keywordflow">if</span> (s)
<a name="l02332"></a>02332     <span class="keywordflow">return</span> s;
<a name="l02333"></a>02333     
<a name="l02334"></a>02334   checkChain(&amp;chd2, <span class="stringliteral">&quot;after insert_realize&quot;</span>);
<a name="l02335"></a>02335 <span class="preprocessor">#endif</span>
<a name="l02336"></a>02336 <span class="preprocessor"></span>  <span class="keywordflow">return</span> s;
<a name="l02337"></a>02337 }
<a name="l02338"></a>02338 
<a name="l02339"></a>02339 Status
<a name="l02340"></a>02340 HIdx::suppressCell(<span class="keywordtype">int</span> offset, CListObjHeader &amp;h, <span class="keyword">const</span> Oid &amp;koid)<span class="keyword"> const</span>
<a name="l02341"></a>02341 <span class="keyword"></span>{
<a name="l02342"></a>02342   Status s;
<a name="l02343"></a>02343   CellHeader o;
<a name="l02344"></a>02344   s = readCellHeader(offset, koid, o);
<a name="l02345"></a>02345   <span class="keywordflow">if</span> (s)
<a name="l02346"></a>02346     <span class="keywordflow">return</span> s;
<a name="l02347"></a>02347 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02348"></a>02348 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;suppressing cell at #%d size %d free_first is %d free_prev %d &quot;</span>
<a name="l02349"></a>02349          <span class="stringliteral">&quot;free_next %d\n&quot;</span>, offset, o.size, h.cell_free_first, o.cell_free_prev,
<a name="l02350"></a>02350          o.cell_free_next);
<a name="l02351"></a>02351 <span class="preprocessor">#endif</span>
<a name="l02352"></a>02352 <span class="preprocessor"></span>  CellHeader po, no;
<a name="l02353"></a>02353   <span class="keywordflow">if</span> (o.cell_free_prev != NullOffset) {
<a name="l02354"></a>02354     s = readCellHeader(o.cell_free_prev, koid, po);
<a name="l02355"></a>02355     <span class="keywordflow">if</span> (s)
<a name="l02356"></a>02356       <span class="keywordflow">return</span> s;
<a name="l02357"></a>02357     po.cell_free_next = o.cell_free_next;
<a name="l02358"></a>02358     s = writeCellHeader(o.cell_free_prev, koid, po);
<a name="l02359"></a>02359     <span class="keywordflow">if</span> (s)
<a name="l02360"></a>02360       <span class="keywordflow">return</span> s;
<a name="l02361"></a>02361   }
<a name="l02362"></a>02362   <span class="keywordflow">else</span>
<a name="l02363"></a>02363     h.cell_free_first = o.cell_free_next;
<a name="l02364"></a>02364 
<a name="l02365"></a>02365   <span class="keywordflow">if</span> (o.cell_free_next != NullOffset) {
<a name="l02366"></a>02366     s = readCellHeader(o.cell_free_next, koid, no);
<a name="l02367"></a>02367     <span class="keywordflow">if</span> (s)
<a name="l02368"></a>02368       <span class="keywordflow">return</span> s;
<a name="l02369"></a>02369     no.cell_free_prev = o.cell_free_prev;
<a name="l02370"></a>02370     s = writeCellHeader(o.cell_free_next, koid, no);
<a name="l02371"></a>02371     <span class="keywordflow">if</span> (s)
<a name="l02372"></a>02372       <span class="keywordflow">return</span> s;
<a name="l02373"></a>02373   }
<a name="l02374"></a>02374 
<a name="l02375"></a>02375 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02376"></a>02376 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;now free_first %d\n&quot;</span>, h.cell_free_first);
<a name="l02377"></a>02377 <span class="preprocessor">#endif</span>
<a name="l02378"></a>02378 <span class="preprocessor"></span>  h.free_cnt--;
<a name="l02379"></a>02379   h.free_whole -= o.size;
<a name="l02380"></a>02380   o.cell_free_next = NullOffset;
<a name="l02381"></a>02381   o.cell_free_prev = NullOffset;
<a name="l02382"></a>02382   o.free = 0;
<a name="l02383"></a>02383   <span class="keywordflow">return</span> writeCellHeader(offset, koid, o);
<a name="l02384"></a>02384 }
<a name="l02385"></a>02385 
<a name="l02386"></a>02386 Status
<a name="l02387"></a>02387 HIdx::insertCell(<span class="keywordtype">int</span> offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, CListObjHeader &amp;h,
<a name="l02388"></a>02388                     <span class="keyword">const</span> Oid &amp;koid)<span class="keyword"> const</span>
<a name="l02389"></a>02389 <span class="keyword"></span>{
<a name="l02390"></a>02390 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02391"></a>02391 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;inserting cell at #%d size %d [free_first %d]\n&quot;</span>, offset, size,
<a name="l02392"></a>02392          h.cell_free_first);
<a name="l02393"></a>02393 <span class="preprocessor">#endif</span>
<a name="l02394"></a>02394 <span class="preprocessor"></span>  CellHeader o;
<a name="l02395"></a>02395   o.size = size;
<a name="l02396"></a>02396   o.free = 1;
<a name="l02397"></a>02397   o.cell_free_next = h.cell_free_first;
<a name="l02398"></a>02398   o.cell_free_prev = NullOffset;
<a name="l02399"></a>02399 
<a name="l02400"></a>02400   <span class="keywordflow">if</span> (h.cell_free_first != NullOffset) {
<a name="l02401"></a>02401     CellHeader po;
<a name="l02402"></a>02402     Status s = readCellHeader(h.cell_free_first, koid, po);
<a name="l02403"></a>02403     <span class="keywordflow">if</span> (s)
<a name="l02404"></a>02404       <span class="keywordflow">return</span> s;
<a name="l02405"></a>02405 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02406"></a>02406 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;making prev link for #%d -&gt; #%d next #%d\n&quot;</span>, h.cell_free_first, offset, po.cell_free_next);
<a name="l02407"></a>02407 <span class="preprocessor">#endif</span>
<a name="l02408"></a>02408 <span class="preprocessor"></span>    assert(po.free);
<a name="l02409"></a>02409     po.cell_free_prev = offset;
<a name="l02410"></a>02410     <span class="keywordtype">bool</span> old_dont_check = dont_check;
<a name="l02411"></a>02411     dont_check = <span class="keyword">true</span>;
<a name="l02412"></a>02412     s = writeCellHeader(h.cell_free_first, koid, po);
<a name="l02413"></a>02413     dont_check = old_dont_check;
<a name="l02414"></a>02414     <span class="keywordflow">if</span> (s)
<a name="l02415"></a>02415       <span class="keywordflow">return</span> s;
<a name="l02416"></a>02416 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02417"></a>02417 <span class="preprocessor"></span>    s = readCellHeader(h.cell_free_first, koid, po);
<a name="l02418"></a>02418     <span class="keywordflow">if</span> (s)
<a name="l02419"></a>02419       <span class="keywordflow">return</span> s;
<a name="l02420"></a>02420     printf(<span class="stringliteral">&quot;PO.offset = %d\n&quot;</span>, po.cell_free_prev);
<a name="l02421"></a>02421 <span class="preprocessor">#endif</span>
<a name="l02422"></a>02422 <span class="preprocessor"></span>  }
<a name="l02423"></a>02423 
<a name="l02424"></a>02424   h.cell_free_first = offset;
<a name="l02425"></a>02425   h.free_cnt++;
<a name="l02426"></a>02426   h.free_whole += o.size;
<a name="l02427"></a>02427   <span class="keywordflow">return</span> writeCellHeader(offset, koid, o);
<a name="l02428"></a>02428 }
<a name="l02429"></a>02429 
<a name="l02430"></a>02430 <span class="comment">//#define SIMPLE_REMOVE</span>
<a name="l02431"></a>02431 <span class="preprocessor">#ifdef SIMPLE_REMOVE</span>
<a name="l02432"></a>02432 <span class="preprocessor"></span>  h.free_whole += o-&gt;size;
<a name="l02433"></a>02433   CellHeader co;
<a name="l02434"></a>02434   co.free = 1;
<a name="l02435"></a>02435   co.size = o-&gt;size;
<a name="l02436"></a>02436   co.next = h.cell_free_first;
<a name="l02437"></a>02437   <span class="keywordtype">int</span> offset = (eyedblib::int32)(curcell - start);
<a name="l02438"></a>02438   h.cell_free_first = offset;
<a name="l02439"></a>02439   h.free_cnt++;
<a name="l02440"></a>02440   h.alloc_cnt--;
<a name="l02441"></a>02441 <span class="preprocessor">#endif</span>
<a name="l02442"></a>02442 <span class="preprocessor"></span>
<a name="l02443"></a>02443 Status
<a name="l02444"></a>02444 HIdx::remove_realize(CListHeader *chd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k,
<a name="l02445"></a>02445                         <span class="keyword">const</span> <span class="keywordtype">char</span> *curcell, <span class="keyword">const</span> <span class="keywordtype">char</span> *prevcell,
<a name="l02446"></a>02446                         <span class="keyword">const</span> <span class="keywordtype">char</span> *start, <span class="keyword">const</span> CellHeader *o,
<a name="l02447"></a>02447                         <span class="keyword">const</span> Oid *koid)
<a name="l02448"></a>02448 {
<a name="l02449"></a>02449   Status s;
<a name="l02450"></a>02450   CListObjHeader h;
<a name="l02451"></a>02451 
<a name="l02452"></a>02452   mcp(&amp;h, start, <span class="keyword">sizeof</span>(CListObjHeader));
<a name="l02453"></a>02453   x2h_header(&amp;h);
<a name="l02454"></a>02454 
<a name="l02455"></a>02455   CellHeader no, po;
<a name="l02456"></a>02456   <span class="keyword">const</span> <span class="keywordtype">char</span> *nextcell = curcell + <span class="keyword">sizeof</span>(CellHeader) + o-&gt;size;
<a name="l02457"></a>02457   if ((eyedblib::int32)(nextcell - start) &lt; h.size) {
<a name="l02458"></a>02458     mcp(&amp;no, nextcell, <span class="keyword">sizeof</span>(CellHeader));
<a name="l02459"></a>02459     x2h_overhead(&amp;no);
<a name="l02460"></a>02460   }
<a name="l02461"></a>02461   <span class="keywordflow">else</span>
<a name="l02462"></a>02462     no.free = 0;
<a name="l02463"></a>02463 
<a name="l02464"></a>02464   <span class="keywordflow">if</span> (prevcell) {
<a name="l02465"></a>02465     mcp(&amp;po, prevcell, <span class="keyword">sizeof</span>(CellHeader));
<a name="l02466"></a>02466     x2h_overhead(&amp;po);
<a name="l02467"></a>02467   }
<a name="l02468"></a>02468   <span class="keywordflow">else</span>
<a name="l02469"></a>02469     po.free = 0;
<a name="l02470"></a>02470 
<a name="l02471"></a>02471 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02472"></a>02472 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;co = #%d, no = #%d, po = #%d\n&quot;</span>, curcell-start,
<a name="l02473"></a>02473          (curcell-start) + <span class="keyword">sizeof</span>(CellHeader) + o-&gt;size,
<a name="l02474"></a>02474          (prevcell ? prevcell-start : 0));
<a name="l02475"></a>02475   printf(<span class="stringliteral">&quot;fo = #%d&quot;</span>, h.cell_free_first);
<a name="l02476"></a>02476 <span class="preprocessor">#endif</span>
<a name="l02477"></a>02477 <span class="preprocessor"></span>  CellHeader fo;
<a name="l02478"></a>02478   <span class="keywordflow">if</span> (h.cell_free_first &gt;= 0) {
<a name="l02479"></a>02479     mcp(&amp;fo, h.cell_free_first + start, <span class="keyword">sizeof</span>(CellHeader));
<a name="l02480"></a>02480     x2h_overhead(&amp;fo);
<a name="l02481"></a>02481 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02482"></a>02482 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;, fo.free = %d, fo.size = %d, fo.next = %d&quot;</span>,
<a name="l02483"></a>02483            fo.free, fo.size, fo.cell_free_next);
<a name="l02484"></a>02484 <span class="preprocessor">#endif</span>
<a name="l02485"></a>02485 <span class="preprocessor"></span>  }
<a name="l02486"></a>02486 
<a name="l02487"></a>02487 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02488"></a>02488 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02489"></a>02489 <span class="preprocessor">#endif</span>
<a name="l02490"></a>02490 <span class="preprocessor"></span>
<a name="l02491"></a>02491   <span class="keywordflow">if</span> (no.free &amp;&amp; po.free) {
<a name="l02492"></a>02492     s = suppressCell(prevcell-start, h, *koid);
<a name="l02493"></a>02493     <span class="keywordflow">if</span> (s)
<a name="l02494"></a>02494       <span class="keywordflow">return</span> s;
<a name="l02495"></a>02495     s = suppressCell(nextcell-start, h, *koid);
<a name="l02496"></a>02496     <span class="keywordflow">if</span> (s)
<a name="l02497"></a>02497       <span class="keywordflow">return</span> s;
<a name="l02498"></a>02498     s = insertCell(prevcell-start,
<a name="l02499"></a>02499                    o-&gt;size + po.size + no.size + 2 * <span class="keyword">sizeof</span>(CellHeader),
<a name="l02500"></a>02500                    h, *koid);
<a name="l02501"></a>02501     <span class="keywordflow">if</span> (s)
<a name="l02502"></a>02502       <span class="keywordflow">return</span> s;
<a name="l02503"></a>02503 
<a name="l02504"></a>02504       <span class="comment">//h.free_whole += o-&gt;size + 2 * sizeof(CellHeader);</span>
<a name="l02505"></a>02505 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02506"></a>02506 <span class="preprocessor"></span>      printf(<span class="stringliteral">&quot;case no.free &amp;&amp; po.free\n&quot;</span>);
<a name="l02507"></a>02507 <span class="preprocessor">#endif</span>
<a name="l02508"></a>02508 <span class="preprocessor"></span>    }
<a name="l02509"></a>02509   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (no.free) {
<a name="l02510"></a>02510     s = suppressCell(nextcell-start, h, *koid);
<a name="l02511"></a>02511     <span class="keywordflow">if</span> (s)
<a name="l02512"></a>02512       <span class="keywordflow">return</span> s;
<a name="l02513"></a>02513       <span class="comment">// 24/04/07: BUG ?</span>
<a name="l02514"></a>02514     s = insertCell(curcell-start,
<a name="l02515"></a>02515                    o-&gt;size + no.size + <span class="keyword">sizeof</span>(CellHeader),
<a name="l02516"></a>02516                    h, *koid);
<a name="l02517"></a>02517     <span class="comment">//h.free_whole += o-&gt;size + sizeof(CellHeader);</span>
<a name="l02518"></a>02518 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02519"></a>02519 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;case no.free\n&quot;</span>);
<a name="l02520"></a>02520 <span class="preprocessor">#endif</span>
<a name="l02521"></a>02521 <span class="preprocessor"></span>    }
<a name="l02522"></a>02522   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (po.free) {
<a name="l02523"></a>02523     <span class="comment">// WARNING: 24/04/07 these 2 lines have been swapped !</span>
<a name="l02524"></a>02524     s = suppressCell(prevcell-start, h, *koid);
<a name="l02525"></a>02525     <span class="keywordflow">if</span> (s)
<a name="l02526"></a>02526       <span class="keywordflow">return</span> s;
<a name="l02527"></a>02527     s = insertCell(prevcell-start,
<a name="l02528"></a>02528                    o-&gt;size + po.size + <span class="keyword">sizeof</span>(CellHeader),
<a name="l02529"></a>02529                    h, *koid);
<a name="l02530"></a>02530       <span class="comment">//h.free_whole += o-&gt;size + sizeof(CellHeader);</span>
<a name="l02531"></a>02531 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02532"></a>02532 <span class="preprocessor"></span>      printf(<span class="stringliteral">&quot;case po.free\n&quot;</span>);
<a name="l02533"></a>02533 <span class="preprocessor">#endif</span>
<a name="l02534"></a>02534 <span class="preprocessor"></span>    }
<a name="l02535"></a>02535   <span class="keywordflow">else</span> {
<a name="l02536"></a>02536     s = insertCell(curcell-start, o-&gt;size, h, *koid);
<a name="l02537"></a>02537     <span class="keywordflow">if</span> (s)
<a name="l02538"></a>02538       <span class="keywordflow">return</span> s;
<a name="l02539"></a>02539       <span class="comment">//h.free_whole += o-&gt;size;</span>
<a name="l02540"></a>02540 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02541"></a>02541 <span class="preprocessor"></span>      printf(<span class="stringliteral">&quot;case *no* free\n&quot;</span>);
<a name="l02542"></a>02542 <span class="preprocessor">#endif</span>
<a name="l02543"></a>02543 <span class="preprocessor"></span>    }
<a name="l02544"></a>02544   
<a name="l02545"></a>02545   <span class="comment">// EV: 3/05/07: WHY ??</span>
<a name="l02546"></a>02546   h.alloc_cnt--;
<a name="l02547"></a>02547 
<a name="l02548"></a>02548   Boolean rmobj = False;
<a name="l02549"></a>02549   <span class="keywordflow">if</span> (!h.alloc_cnt) {
<a name="l02550"></a>02550     s = suppressObjectFromFreeList(*chd, chd_k, h, *koid);
<a name="l02551"></a>02551     <span class="keywordflow">if</span> (s)
<a name="l02552"></a>02552       <span class="keywordflow">return</span> s;
<a name="l02553"></a>02553     s = suppressObjectFromList(*chd, chd_k, h, *koid);
<a name="l02554"></a>02554     <span class="keywordflow">if</span> (s)
<a name="l02555"></a>02555       <span class="keywordflow">return</span> s;
<a name="l02556"></a>02556     rmobj = True;
<a name="l02557"></a>02557   }
<a name="l02558"></a>02558   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!inFreeList(h, *chd, *koid)) {
<a name="l02559"></a>02559     s = insertObjectInFreeList(*chd, chd_k, h, *koid);
<a name="l02560"></a>02560     <span class="keywordflow">if</span> (s)
<a name="l02561"></a>02561       <span class="keywordflow">return</span> s;
<a name="l02562"></a>02562   }
<a name="l02563"></a>02563 
<a name="l02564"></a>02564   <span class="comment">//printf(&quot;writing header %d: po.free %d, no.free %d %d %d %d\n&quot;, !rmobj, po.free, no.free, h.alloc_cnt, h.cell_free_first, h.free_cnt);</span>
<a name="l02565"></a>02565   <span class="keywordflow">if</span> (!rmobj) {
<a name="l02566"></a>02566     s = writeCListObjHeader(*koid, h);
<a name="l02567"></a>02567     <span class="keywordflow">if</span> (s)
<a name="l02568"></a>02568       <span class="keywordflow">return</span> s;
<a name="l02569"></a>02569   }
<a name="l02570"></a>02570 
<a name="l02571"></a>02571 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02572"></a>02572 <span class="preprocessor"></span>  CListObjHeader xh;
<a name="l02573"></a>02573   h2x_header(&amp;xh, &amp;h);
<a name="l02574"></a>02574   memcpy((<span class="keywordtype">void</span> *)start, &amp;xh, <span class="keyword">sizeof</span>(xh));
<a name="l02575"></a>02575 <span class="preprocessor">#endif</span>
<a name="l02576"></a>02576 <span class="preprocessor"></span>
<a name="l02577"></a>02577   <span class="keywordflow">return</span> count_manage(dbh, -1);
<a name="l02578"></a>02578 }
<a name="l02579"></a>02579 
<a name="l02580"></a>02580 <span class="preprocessor">#define get_off(X, THIS) \</span>
<a name="l02581"></a>02581 <span class="preprocessor"> ((THIS)-&gt;hidx.keysz != HIdx::VarSize ? (THIS)-&gt;hidx.keysz : strlen(X) + 1)</span>
<a name="l02582"></a>02582 <span class="preprocessor"></span>
<a name="l02583"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a39f00cfb064e87b7e7877eace7973023">02583</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a1cb5f582b0376c9bb697a680b8159cd7" title="Not yet documented.">HIdx::remove</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz, Boolean *found)
<a name="l02584"></a>02584 {
<a name="l02585"></a>02585   <span class="keywordflow">if</span> (!<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>() &amp;&amp; hidx.datasz != datasz) {
<a name="l02586"></a>02586     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;Fixed size hash index: the data size must be equals to %u&quot;</span>, hidx.datasz);
<a name="l02587"></a>02587   }
<a name="l02588"></a>02588 
<a name="l02589"></a>02589   <span class="keywordflow">return</span> remove_perform(key, data, datasz, found, 0, 0, 0, 0);
<a name="l02590"></a>02590 }
<a name="l02591"></a>02591 
<a name="l02592"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a1cb5f582b0376c9bb697a680b8159cd7">02592</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a1cb5f582b0376c9bb697a680b8159cd7" title="Not yet documented.">HIdx::remove</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *xdata, Boolean *found)
<a name="l02593"></a>02593 {
<a name="l02594"></a>02594   <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l02595"></a>02595     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;Variable data size hash index: the data size must be given at removing, use HIdx::remove(const void *key, const void *data, unsigned int datasz, Boolean *found)&quot;</span>);
<a name="l02596"></a>02596   }
<a name="l02597"></a>02597 
<a name="l02598"></a>02598   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *rdata = 0;
<a name="l02599"></a>02599 
<a name="l02600"></a>02600   <span class="keywordflow">if</span> (data_grouped_by_key) {
<a name="l02601"></a>02601     Boolean xfound = False;
<a name="l02602"></a>02602     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datacnt = 0;
<a name="l02603"></a>02603     <span class="keywordtype">int</span> found_idx = -1;
<a name="l02604"></a>02604     Status s = remove_perform(key, xdata, 0, &amp;xfound, &amp;rdata, &amp;datacnt, &amp;found_idx, 0);
<a name="l02605"></a>02605     <span class="keywordflow">if</span> (s)
<a name="l02606"></a>02606       <span class="keywordflow">return</span> s;
<a name="l02607"></a>02607 
<a name="l02608"></a>02608     <span class="keywordflow">if</span> (found)
<a name="l02609"></a>02609       *found = xfound;
<a name="l02610"></a>02610 
<a name="l02611"></a>02611     <span class="keywordflow">if</span> (!xfound)
<a name="l02612"></a>02612       <span class="keywordflow">return</span> Success;
<a name="l02613"></a>02613 
<a name="l02614"></a>02614 <span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l02615"></a>02615 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;found_idx %d\n&quot;</span>, found_idx);
<a name="l02616"></a>02616 <span class="preprocessor">#endif</span>
<a name="l02617"></a>02617 <span class="preprocessor"></span>    assert(found_idx &gt;= 0);
<a name="l02618"></a>02618     <span class="keywordflow">if</span> (--datacnt) {
<a name="l02619"></a>02619       memmove(rdata + data_group_sz(found_idx, <span class="keyword">this</span>),
<a name="l02620"></a>02620               rdata + data_group_sz(found_idx + 1, <span class="keyword">this</span>),
<a name="l02621"></a>02621               (datacnt - found_idx) * hidx.datasz);
<a name="l02622"></a>02622 <span class="preprocessor">#ifdef VARSZ_DATACNT</span>
<a name="l02623"></a>02623 <span class="preprocessor"></span>      s = h2x_datacnt_cpy(rdata, &amp;datacnt);
<a name="l02624"></a>02624       <span class="keywordflow">if</span> (s)
<a name="l02625"></a>02625         <span class="keywordflow">return</span> s;
<a name="l02626"></a>02626 <span class="preprocessor">#else</span>
<a name="l02627"></a>02627 <span class="preprocessor"></span>      h2x_32_cpy(rdata, &amp;datacnt);
<a name="l02628"></a>02628 <span class="preprocessor">#endif</span>
<a name="l02629"></a>02629 <span class="preprocessor"></span><span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l02630"></a>02630 <span class="preprocessor"></span>      printf(<span class="stringliteral">&quot;insert_perforn(%d)\n&quot;</span>, data_group_sz(datacnt, <span class="keyword">this</span>));
<a name="l02631"></a>02631 <span class="preprocessor">#endif</span>
<a name="l02632"></a>02632 <span class="preprocessor"></span>      s = insert_perform(key, rdata, data_group_sz(datacnt, <span class="keyword">this</span>));
<a name="l02633"></a>02633     }
<a name="l02634"></a>02634     <span class="keyword">delete</span> [] rdata;
<a name="l02635"></a>02635     <span class="keywordflow">return</span> s;
<a name="l02636"></a>02636   }
<a name="l02637"></a>02637   <span class="keywordflow">else</span> {
<a name="l02638"></a>02638     <span class="keywordflow">return</span> remove_perform(key, xdata, 0, found, 0, 0, 0, 0);
<a name="l02639"></a>02639   }
<a name="l02640"></a>02640 }
<a name="l02641"></a>02641 
<a name="l02642"></a>02642 Status
<a name="l02643"></a>02643 HIdx::remove_perform(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *xdata, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datasz, Boolean *found, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> **prdata, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pdatacnt, <span class="keywordtype">int</span> *found_idx, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> incr_alloc)
<a name="l02644"></a>02644 {
<a name="l02645"></a>02645   Status s;
<a name="l02646"></a>02646   
<a name="l02647"></a>02647   <span class="keywordflow">if</span> (stat)
<a name="l02648"></a>02648     <span class="keywordflow">return</span> stat;
<a name="l02649"></a>02649 
<a name="l02650"></a>02650   <span class="keywordflow">if</span> (s = checkOpened())
<a name="l02651"></a>02651     <span class="keywordflow">return</span> s;
<a name="l02652"></a>02652 
<a name="l02653"></a>02653   <span class="keywordflow">if</span> (!datasz) {
<a name="l02654"></a>02654     datasz = hidx.datasz;
<a name="l02655"></a>02655   }
<a name="l02656"></a>02656 
<a name="l02657"></a>02657 <span class="preprocessor">#ifdef CACHE_FOR_LOCK</span>
<a name="l02658"></a>02658 <span class="preprocessor"></span>  <span class="comment">// remove(const void *key, const void *xdata, found?)</span>
<a name="l02659"></a>02659   <span class="comment">// oplist.insertObjectLast(new RMVLink(this, key, xdata, ?found));</span>
<a name="l02660"></a>02660   <span class="comment">// return Success;</span>
<a name="l02661"></a>02661 
<a name="l02662"></a>02662   <span class="comment">// TRES IMPORTANT : il faut changer la stratgie relative au found, par</span>
<a name="l02663"></a>02663   <span class="comment">// exemple :</span>
<a name="l02664"></a>02664   <span class="comment">// remove(const void *key, const void *xdata,</span>
<a name="l02665"></a>02665   <span class="comment">//        Status (*if_not_found)(void *arg) = 0, void *arg = 0)</span>
<a name="l02666"></a>02666   <span class="comment">// oplist.insertObjectLast(new RMVLink(this, key, xdata, if_not_found, arg));</span>
<a name="l02667"></a>02667   <span class="comment">// return Success;</span>
<a name="l02668"></a>02668   <span class="comment">// Mais ce systme risque (1) d&apos;tre contraignant pour l&apos;utilisateur</span>
<a name="l02669"></a>02669   <span class="comment">// de cette mthode, (2) de poser un pb de memory leak si arg est un</span>
<a name="l02670"></a>02670   <span class="comment">// pointeur d&apos;une spcialement alloue pour if_not_found : il faudrait alors</span>
<a name="l02671"></a>02671   <span class="comment">// une autre fonction releaarg(void *) ou bien :</span>
<a name="l02672"></a>02672   <span class="comment">// struct IfNotFound {</span>
<a name="l02673"></a>02673   <span class="comment">//   private : void *arg;</span>
<a name="l02674"></a>02674   <span class="comment">//   public: Status ifnot();</span>
<a name="l02675"></a>02675   <span class="comment">//   public: Status release();</span>
<a name="l02676"></a>02676   <span class="comment">// }; et remove(...., IfNotFound *if_not_found) en dernier argument !</span>
<a name="l02677"></a>02677   <span class="comment">// autre solution : on supprime l&apos;argument pour found et le client</span>
<a name="l02678"></a>02678   <span class="comment">// devra faire Idx::search avant s&apos;il veut savoir si la key/data existe</span>
<a name="l02679"></a>02679   <span class="comment">// ou non</span>
<a name="l02680"></a>02680   <span class="comment">//  noter que cela est utilis uniquement dans : attr.cc et idbkern.cc</span>
<a name="l02681"></a>02681 <span class="preprocessor">#endif</span>
<a name="l02682"></a>02682 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (found)
<a name="l02683"></a>02683     *found = False;
<a name="l02684"></a>02684 
<a name="l02685"></a>02685   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x;
<a name="l02686"></a>02686   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l02687"></a>02687   s = get_key(x, key);
<a name="l02688"></a>02688   <span class="keywordflow">if</span> (s)
<a name="l02689"></a>02689     <span class="keywordflow">return</span> s;
<a name="l02690"></a>02690 
<a name="l02691"></a>02691 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02692"></a>02692 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;\nREMOVE at #%d\n&quot;</span>, x);
<a name="l02693"></a>02693 <span class="preprocessor">#endif</span>
<a name="l02694"></a>02694 <span class="preprocessor"></span>  IdxLock lockx(dbh, treeoid);
<a name="l02695"></a>02695   s = lockx.lock();
<a name="l02696"></a>02696   <span class="keywordflow">if</span> (s)
<a name="l02697"></a>02697     <span class="keywordflow">return</span> s;
<a name="l02698"></a>02698 
<a name="l02699"></a>02699   CListHeader chd;
<a name="l02700"></a>02700   s = readCListHeader(x, chd);
<a name="l02701"></a>02701   <span class="keywordflow">if</span> (s)
<a name="l02702"></a>02702     <span class="keywordflow">return</span> s;
<a name="l02703"></a>02703 
<a name="l02704"></a>02704 <span class="preprocessor">#ifdef IDX_DBG</span>
<a name="l02705"></a>02705 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (STRTYPE(<span class="keyword">this</span>)) {
<a name="l02706"></a>02706       printf(<span class="stringliteral">&quot;hidx: removing &apos;%s&apos; &apos;%s&apos;\n&quot;</span>, key, getOidString((<span class="keyword">const</span> Oid *)xdata));
<a name="l02707"></a>02707     }
<a name="l02708"></a>02708 <span class="preprocessor">#endif</span>
<a name="l02709"></a>02709 <span class="preprocessor"></span>  Oid koid = chd.clobj_first;
<a name="l02710"></a>02710   <span class="keywordflow">while</span> (koid.getNX() &gt; 0) {
<a name="l02711"></a>02711     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;
<a name="l02712"></a>02712       s = objectSizeGet(dbh, &amp;size, DefaultLock, &amp;koid);
<a name="l02713"></a>02713       <span class="keywordflow">if</span> (s)
<a name="l02714"></a>02714         statusPrint(s, <span class="stringliteral">&quot;HIdx::remove() treeoid %s&quot;</span>, getOidString(&amp;treeoid));
<a name="l02715"></a>02715 
<a name="l02716"></a>02716       <span class="keywordflow">if</span> (s)
<a name="l02717"></a>02717         <span class="keywordflow">return</span> s;
<a name="l02718"></a>02718 
<a name="l02719"></a>02719       <span class="keywordtype">char</span> *start = (<span class="keywordtype">char</span> *)m_malloc(size);
<a name="l02720"></a>02720       s = objectRead(dbh, 0, size, start, DefaultLock, 0, 0, &amp;koid);
<a name="l02721"></a>02721       
<a name="l02722"></a>02722       <span class="keywordflow">if</span> (s) {
<a name="l02723"></a>02723           free(start);
<a name="l02724"></a>02724           <span class="keywordflow">return</span> s;
<a name="l02725"></a>02725         }
<a name="l02726"></a>02726       
<a name="l02727"></a>02727       <span class="keywordtype">char</span> *curcell, *end = start + size, *prevcell = 0;
<a name="l02728"></a>02728       <span class="keywordflow">for</span> (curcell = start + <span class="keyword">sizeof</span>(CListObjHeader); curcell &lt; end; ) {
<a name="l02729"></a>02729           CellHeader o;
<a name="l02730"></a>02730           mcp(&amp;o, curcell, <span class="keyword">sizeof</span>(CellHeader));
<a name="l02731"></a>02731           x2h_overhead(&amp;o);
<a name="l02732"></a>02732           curcell += <span class="keyword">sizeof</span>(CellHeader);
<a name="l02733"></a>02733           
<a name="l02734"></a>02734           <span class="keywordflow">if</span> (!o.free &amp;&amp; !cmp(key, curcell, OP2_SWAP)) {
<a name="l02735"></a>02735             <span class="keywordtype">int</span> r = 1;
<a name="l02736"></a>02736             <span class="keywordflow">if</span> (prdata) {
<a name="l02737"></a>02737               assert(data_grouped_by_key);
<a name="l02738"></a>02738               assert(pdatacnt);
<a name="l02739"></a>02739 <span class="preprocessor">#ifdef VARSZ_DATACNT</span>
<a name="l02740"></a>02740 <span class="preprocessor"></span>              s = x2h_datacnt_cpy(pdatacnt, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(curcell + get_off(curcell, <span class="keyword">this</span>)));
<a name="l02741"></a>02741               <span class="keywordflow">if</span> (s)
<a name="l02742"></a>02742                 <span class="keywordflow">return</span> s;
<a name="l02743"></a>02743 <span class="preprocessor">#else</span>
<a name="l02744"></a>02744 <span class="preprocessor"></span>              x2h_32_cpy(pdatacnt, curcell + get_off(curcell, <span class="keyword">this</span>));
<a name="l02745"></a>02745 <span class="preprocessor">#endif</span>
<a name="l02746"></a>02746 <span class="preprocessor"></span><span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l02747"></a>02747 <span class="preprocessor"></span>              printf(<span class="stringliteral">&quot;DATACNT %d\n&quot;</span>, *pdatacnt);
<a name="l02748"></a>02748 <span class="preprocessor">#endif</span>
<a name="l02749"></a>02749 <span class="preprocessor"></span>              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;
<a name="l02750"></a>02750               <span class="keywordflow">if</span> (xdata) {
<a name="l02751"></a>02751                 assert(found_idx);
<a name="l02752"></a>02752                 *found_idx = -1;
<a name="l02753"></a>02753                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; *pdatacnt; n++) {
<a name="l02754"></a>02754                   r = memcmp(xdata, curcell + get_off(curcell, <span class="keyword">this</span>) + data_group_sz(n, <span class="keyword">this</span>), datasz);
<a name="l02755"></a>02755                   <span class="keywordflow">if</span> (!r) {
<a name="l02756"></a>02756                     *found_idx = n;
<a name="l02757"></a>02757                     <span class="keywordflow">break</span>;
<a name="l02758"></a>02758                   }
<a name="l02759"></a>02759                 }
<a name="l02760"></a>02760                 assert(!incr_alloc);
<a name="l02761"></a>02761                 size = data_group_sz(*pdatacnt, <span class="keyword">this</span>);
<a name="l02762"></a>02762               }
<a name="l02763"></a>02763               <span class="keywordflow">else</span> {
<a name="l02764"></a>02764                 size = data_group_sz((*pdatacnt)+incr_alloc, <span class="keyword">this</span>);
<a name="l02765"></a>02765                 r = 0;
<a name="l02766"></a>02766               }
<a name="l02767"></a>02767 
<a name="l02768"></a>02768               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsize = data_group_sz(*pdatacnt, <span class="keyword">this</span>);
<a name="l02769"></a>02769               *prdata = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[size];
<a name="l02770"></a>02770               memcpy(*prdata, curcell + get_off(curcell, <span class="keyword">this</span>), cpsize);
<a name="l02771"></a>02771             }
<a name="l02772"></a>02772             <span class="keywordflow">else</span> {
<a name="l02773"></a>02773 <span class="preprocessor">#ifdef BUG_DATA_STORE2</span>
<a name="l02774"></a>02774 <span class="preprocessor"></span>              <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>()) {
<a name="l02775"></a>02775                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xdatasz;
<a name="l02776"></a>02776                 memcpy(&amp;xdatasz, curcell + get_off(curcell, <span class="keyword">this</span>), DATASZ_SIZE);
<a name="l02777"></a>02777                 <span class="keywordtype">unsigned</span> ndatasz = x2h_u32(xdatasz);
<a name="l02778"></a>02778                 <span class="keywordflow">if</span> (ndatasz != datasz) {
<a name="l02779"></a>02779                   r = -1;
<a name="l02780"></a>02780                 }
<a name="l02781"></a>02781                 <span class="keywordflow">else</span> {
<a name="l02782"></a>02782                   r = memcmp(xdata, curcell + get_off(curcell, <span class="keyword">this</span>) + DATASZ_SIZE, datasz);
<a name="l02783"></a>02783                 }
<a name="l02784"></a>02784               }
<a name="l02785"></a>02785               <span class="keywordflow">else</span> {
<a name="l02786"></a>02786                 r = memcmp(xdata, curcell + get_off(curcell, <span class="keyword">this</span>), datasz);
<a name="l02787"></a>02787               }
<a name="l02788"></a>02788 <span class="preprocessor">#else</span>
<a name="l02789"></a>02789 <span class="preprocessor"></span>              assert(0);
<a name="l02790"></a>02790               r = memcmp(xdata, curcell + o.size - datasz, datasz);
<a name="l02791"></a>02791 <span class="preprocessor">#endif</span>
<a name="l02792"></a>02792 <span class="preprocessor"></span>            }
<a name="l02793"></a>02793             <span class="keywordflow">if</span> (!r) {
<a name="l02794"></a>02794 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02795"></a>02795 <span class="preprocessor"></span>              CListObjHeader h;
<a name="l02796"></a>02796               memcpy(&amp;h, start, <span class="keyword">sizeof</span>(h));
<a name="l02797"></a>02797               x2h_header(&amp;h);
<a name="l02798"></a>02798               dumpMemoryMap(chd, <span class="stringliteral">&quot;before remove_realize &quot;</span>);
<a name="l02799"></a>02799 <span class="preprocessor">#endif</span>
<a name="l02800"></a>02800 <span class="preprocessor"></span>              s = remove_realize(&amp;chd, x, curcell - <span class="keyword">sizeof</span>(CellHeader),
<a name="l02801"></a>02801                                  prevcell, start, &amp;o, &amp;koid);
<a name="l02802"></a>02802 <span class="preprocessor">#ifdef TRACK_MAP</span>
<a name="l02803"></a>02803 <span class="preprocessor"></span>              memcpy(&amp;h, start, <span class="keyword">sizeof</span>(h));
<a name="l02804"></a>02804               x2h_header(&amp;h);
<a name="l02805"></a>02805               dumpMemoryMap(chd, <span class="stringliteral">&quot;after remove_realize &quot;</span>);
<a name="l02806"></a>02806 <span class="preprocessor">#endif</span>
<a name="l02807"></a>02807 <span class="preprocessor"></span>
<a name="l02808"></a>02808               <span class="keywordflow">if</span> (!s &amp;&amp; found) {
<a name="l02809"></a>02809                 *found = True;
<a name="l02810"></a>02810               }
<a name="l02811"></a>02811               free(start);
<a name="l02812"></a>02812               <span class="keywordflow">return</span> s;
<a name="l02813"></a>02813             }
<a name="l02814"></a>02814           }
<a name="l02815"></a>02815           
<a name="l02816"></a>02816           prevcell = curcell - <span class="keyword">sizeof</span>(CellHeader);
<a name="l02817"></a>02817           curcell += o.size;
<a name="l02818"></a>02818         }
<a name="l02819"></a>02819 
<a name="l02820"></a>02820       CListObjHeader h;
<a name="l02821"></a>02821       mcp(&amp;h, start, <span class="keyword">sizeof</span>(CListObjHeader));
<a name="l02822"></a>02822       x2h_header(&amp;h);
<a name="l02823"></a>02823       <span class="comment">//koid = h.clobj_free_next;</span>
<a name="l02824"></a>02824       koid = h.clobj_next;
<a name="l02825"></a>02825       free(start);
<a name="l02826"></a>02826     }
<a name="l02827"></a>02827 
<a name="l02828"></a>02828   <span class="keywordflow">return</span> Success;
<a name="l02829"></a>02829 }
<a name="l02830"></a>02830 
<a name="l02831"></a>02831 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l02832"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a4a1776668092d49a37a337cc92523e0f">02832</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a4a1776668092d49a37a337cc92523e0f" title="Not yet documented.">HIdx::getCount</a>()<span class="keyword"> const</span>
<a name="l02833"></a>02833 <span class="keyword"></span>{
<a name="l02834"></a>02834   <span class="keywordflow">return</span> hidx.object_count;
<a name="l02835"></a>02835 }
<a name="l02836"></a>02836 
<a name="l02837"></a>02837 <span class="keywordtype">short</span>
<a name="l02838"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a56f76f7a34686d98c6a216a32bef7549">02838</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a56f76f7a34686d98c6a216a32bef7549" title="Not yet documented.">HIdx::getDefaultDspid</a>()<span class="keyword"> const</span>
<a name="l02839"></a>02839 <span class="keyword"></span>{
<a name="l02840"></a>02840   <span class="keywordflow">return</span> hidx.dspid;
<a name="l02841"></a>02841 
<a name="l02842"></a>02842 }
<a name="l02843"></a>02843 
<a name="l02844"></a>02844 <span class="keywordtype">void</span>
<a name="l02845"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a63fe975871302cba2e5428ad47b65b1f">02845</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a63fe975871302cba2e5428ad47b65b1f" title="Not yet documented.">HIdx::setDefaultDspid</a>(<span class="keywordtype">short</span> dspid)
<a name="l02846"></a>02846 {
<a name="l02847"></a>02847   hidx.dspid = dspid;
<a name="l02848"></a>02848   dspid = h2x_16(dspid);
<a name="l02849"></a>02849   objectWrite(dbh, 4*<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>),
<a name="l02850"></a>02850                  &amp;dspid, &amp;treeoid);
<a name="l02851"></a>02851 }
<a name="l02852"></a>02852 
<a name="l02853"></a>02853 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02854"></a>02854 add(Oid *&amp;oids, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;cnt, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;alloc_cnt,
<a name="l02855"></a>02855     <span class="keyword">const</span> Oid &amp;oid)
<a name="l02856"></a>02856 {
<a name="l02857"></a>02857   <span class="keywordflow">if</span> (cnt &gt;= alloc_cnt) {
<a name="l02858"></a>02858     alloc_cnt = cnt + 32;
<a name="l02859"></a>02859     oids = (Oid *)m_realloc(oids, alloc_cnt * <span class="keyword">sizeof</span>(Oid));
<a name="l02860"></a>02860   }
<a name="l02861"></a>02861 
<a name="l02862"></a>02862   oids[cnt++] = oid;
<a name="l02863"></a>02863 }
<a name="l02864"></a>02864 
<a name="l02865"></a>02865 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l02866"></a>02866 implHintsStr(<span class="keywordtype">int</span> hints)
<a name="l02867"></a>02867 {
<a name="l02868"></a>02868   <span class="keywordflow">if</span> (hints == HIdx::IniSize_Hints)
<a name="l02869"></a>02869     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Initial Size&quot;</span>;
<a name="l02870"></a>02870 
<a name="l02871"></a>02871   <span class="keywordflow">if</span> (hints == HIdx::IniObjCnt_Hints)
<a name="l02872"></a>02872     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Initial Object Count&quot;</span>;
<a name="l02873"></a>02873 
<a name="l02874"></a>02874   <span class="keywordflow">if</span> (hints == HIdx::XCoef_Hints)
<a name="l02875"></a>02875     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Extends Coeficient&quot;</span>;
<a name="l02876"></a>02876 
<a name="l02877"></a>02877   <span class="keywordflow">if</span> (hints == HIdx::SzMax_Hints)
<a name="l02878"></a>02878     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Maximal Hash Object Size&quot;</span>;
<a name="l02879"></a>02879 
<a name="l02880"></a>02880   <span class="keywordflow">if</span> (hints == HIdx::DataGroupedByKey_Hints)
<a name="l02881"></a>02881     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Data Grouped by Key&quot;</span>;
<a name="l02882"></a>02882 
<a name="l02883"></a>02883   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;unimplemented&gt;&quot;</span>;
<a name="l02884"></a>02884 }
<a name="l02885"></a>02885 
<a name="l02886"></a>02886 std::string
<a name="l02887"></a>02887 HIdx::_Idx::toString()<span class="keyword"> const</span>
<a name="l02888"></a>02888 <span class="keyword"></span>{
<a name="l02889"></a>02889   std::string s;
<a name="l02890"></a>02890   s = std::string(<span class="stringliteral">&quot;Key Count: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)key_count);
<a name="l02891"></a>02891   s += std::string(<span class="stringliteral">&quot;Magnitude Order: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)mag_order);
<a name="l02892"></a>02892   s += std::string(<span class="stringliteral">&quot;Object Count: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)object_count);
<a name="l02893"></a>02893   s += std::string(<span class="stringliteral">&quot;Dataspace ID: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)(dspid == DefaultDspid ? -1 : dspid));
<a name="l02894"></a>02894   s += std::string(<span class="stringliteral">&quot;Key Type: &quot;</span>) + typeString((Idx::Type)keytype);
<a name="l02895"></a>02895   s += std::string(<span class="stringliteral">&quot;Key Size: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)keysz);
<a name="l02896"></a>02896   s += std::string(<span class="stringliteral">&quot;Data Size: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)datasz);
<a name="l02897"></a>02897   s += std::string(<span class="stringliteral">&quot;Data Offset: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)offset);
<a name="l02898"></a>02898   s += <span class="stringliteral">&quot;Implementation Hint:\n&quot;</span>;
<a name="l02899"></a>02899   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; HIdxImplHintsCount; i++)
<a name="l02900"></a>02900     s += std::string(<span class="stringliteral">&quot;  &quot;</span>) + implHintsStr(i) + <span class="stringliteral">&quot;: &quot;</span> + str_convert((<span class="keywordtype">long</span>)impl_hints[i]);
<a name="l02901"></a>02901   <span class="keywordflow">return</span> s;
<a name="l02902"></a>02902 }
<a name="l02903"></a>02903 
<a name="l02904"></a>02904 <span class="keywordtype">void</span>
<a name="l02905"></a>02905 HIdx::_Idx::trace(FILE *fd)<span class="keyword"> const</span>
<a name="l02906"></a>02906 <span class="keyword"></span>{
<a name="l02907"></a>02907   fprintf(fd, <span class="stringliteral">&quot;Key Count: %d\n&quot;</span>, key_count);
<a name="l02908"></a>02908   fprintf(fd, <span class="stringliteral">&quot;Magnitude Order: %d\n&quot;</span>, mag_order);
<a name="l02909"></a>02909   fprintf(fd, <span class="stringliteral">&quot;Object Count: %d\n&quot;</span>, object_count);
<a name="l02910"></a>02910   fprintf(fd, <span class="stringliteral">&quot;Dataspace ID: %d\n&quot;</span>, (dspid == DefaultDspid ? -1 : dspid));
<a name="l02911"></a>02911   fprintf(fd, <span class="stringliteral">&quot;Key Type: %s\n&quot;</span>, typeString((Idx::Type)keytype));
<a name="l02912"></a>02912   fprintf(fd, <span class="stringliteral">&quot;Key Size: %d\n&quot;</span>, keysz);
<a name="l02913"></a>02913   fprintf(fd, <span class="stringliteral">&quot;Data Size: %d\n&quot;</span>, datasz);
<a name="l02914"></a>02914   fprintf(fd, <span class="stringliteral">&quot;Data Offset: %d\n&quot;</span>, offset);
<a name="l02915"></a>02915   fprintf(fd, <span class="stringliteral">&quot;Implementation Hint:\n&quot;</span>);
<a name="l02916"></a>02916   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; HIdxImplHintsCount; i++)
<a name="l02917"></a>02917     fprintf(fd, <span class="stringliteral">&quot;  %s: %d\n&quot;</span>, implHintsStr(i), impl_hints[i]);
<a name="l02918"></a>02918 }
<a name="l02919"></a>02919 
<a name="l02920"></a>02920 Status
<a name="l02921"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a7327abf781c4a5612579f21edc34b830">02921</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a7327abf781c4a5612579f21edc34b830" title="Not yet documented.">HIdx::getObjects</a>(Oid *&amp;oids, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;cnt)<span class="keyword"> const</span>
<a name="l02922"></a>02922 <span class="keyword"></span>{
<a name="l02923"></a>02923   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> alloc_cnt = 0;
<a name="l02924"></a>02924   cnt = 0;
<a name="l02925"></a>02925   oids = 0;
<a name="l02926"></a>02926   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l02927"></a>02927 
<a name="l02928"></a>02928   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; hidx.key_count; i++) {
<a name="l02929"></a>02929     HIdx::CListHeader chd;
<a name="l02930"></a>02930     Status s = readCListHeader(i, chd);
<a name="l02931"></a>02931     <span class="keywordflow">if</span> (s)
<a name="l02932"></a>02932       <span class="keywordflow">return</span> s;
<a name="l02933"></a>02933 
<a name="l02934"></a>02934     Oid koid = chd.clobj_first;
<a name="l02935"></a>02935     <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l02936"></a>02936       add(oids, cnt, alloc_cnt, koid);
<a name="l02937"></a>02937       HIdx::CListObjHeader h;
<a name="l02938"></a>02938       s = objectRead(dbh, 0, <span class="keyword">sizeof</span>(HIdx::CListObjHeader), &amp;h,
<a name="l02939"></a>02939                         DefaultLock, 0, 0, &amp;koid);
<a name="l02940"></a>02940       <span class="keywordflow">if</span> (s)
<a name="l02941"></a>02941         <span class="keywordflow">return</span> s;
<a name="l02942"></a>02942       x2h_header(&amp;h);
<a name="l02943"></a>02943       koid = h.clobj_next;
<a name="l02944"></a>02944     }
<a name="l02945"></a>02945   }
<a name="l02946"></a>02946 
<a name="l02947"></a>02947   <span class="keywordflow">return</span> Success;
<a name="l02948"></a>02948 }
<a name="l02949"></a>02949 
<a name="l02950"></a>02950 <span class="keyword">static</span> <span class="keywordtype">void</span> adapt(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *&amp;clist_data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;clist_data_size,
<a name="l02951"></a>02951                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;clist_data_alloc_size,
<a name="l02952"></a>02952                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size)
<a name="l02953"></a>02953 {
<a name="l02954"></a>02954   <span class="keywordflow">if</span> (clist_data_size + size &gt; clist_data_alloc_size) {
<a name="l02955"></a>02955     <span class="comment">//    clist_data_alloc_size = clist_data_size + size + 2048;</span>
<a name="l02956"></a>02956     clist_data_alloc_size = (clist_data_size + size) * 2;
<a name="l02957"></a>02957     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *n_clist_data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[clist_data_alloc_size];
<a name="l02958"></a>02958     memcpy(n_clist_data, clist_data, clist_data_size);
<a name="l02959"></a>02959     <span class="keyword">delete</span> [] clist_data;
<a name="l02960"></a>02960     clist_data = n_clist_data;
<a name="l02961"></a>02961   }
<a name="l02962"></a>02962 }
<a name="l02963"></a>02963 
<a name="l02964"></a>02964 Status
<a name="l02965"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a53a17768b3c1414673efff597c0c18d3">02965</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a53a17768b3c1414673efff597c0c18d3" title="Not yet documented.">HIdx::collapse</a>()
<a name="l02966"></a>02966 {
<a name="l02967"></a>02967   <span class="keywordflow">return</span> collapse_realize(hidx.dspid, 0);
<a name="l02968"></a>02968 }
<a name="l02969"></a>02969 
<a name="l02970"></a>02970 <span class="comment">//#define COLLAPSE_TRACE</span>
<a name="l02971"></a>02971 
<a name="l02972"></a>02972 Status
<a name="l02973"></a>02973 HIdx::collapse_realize(<span class="keywordtype">short</span> dspid, <a class="code" href="classeyedbsm_1_1HIdx.html" title="Not yet documented.">HIdx</a> *idx_n)
<a name="l02974"></a>02974 {
<a name="l02975"></a>02975   IdxLock lockx(dbh, treeoid);
<a name="l02976"></a>02976   Status s = lockx.lock();
<a name="l02977"></a>02977   <span class="keywordflow">if</span> (s)
<a name="l02978"></a>02978     <span class="keywordflow">return</span> s;
<a name="l02979"></a>02979 
<a name="l02980"></a>02980   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clist_data_alloc_size = 0;
<a name="l02981"></a>02981   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *clist_data = 0;
<a name="l02982"></a>02982   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clistobj_data_alloc_size = 0;
<a name="l02983"></a>02983   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *clistobj_data = 0;
<a name="l02984"></a>02984 
<a name="l02985"></a>02985   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chd_k = 0; chd_k &lt; hidx.key_count; chd_k++) {
<a name="l02986"></a>02986     HIdx::CListHeader chd;
<a name="l02987"></a>02987     s = readCListHeader(chd_k, chd);
<a name="l02988"></a>02988     <span class="keywordflow">if</span> (s)
<a name="l02989"></a>02989       <span class="keywordflow">return</span> s;
<a name="l02990"></a>02990 
<a name="l02991"></a>02991     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clistobj_cnt = 0;
<a name="l02992"></a>02992     Oid koid = chd.clobj_first;
<a name="l02993"></a>02993     std::vector&lt;Oid&gt; oid_v;
<a name="l02994"></a>02994     <span class="keywordflow">if</span> (koid.getNX()) {
<a name="l02995"></a>02995 <span class="preprocessor">#ifdef COLLAPSE_TRACE</span>
<a name="l02996"></a>02996 <span class="preprocessor"></span>      printf(<span class="stringliteral">&quot;Key #%d {\n&quot;</span>, chd_k);
<a name="l02997"></a>02997 <span class="preprocessor">#endif</span>
<a name="l02998"></a>02998 <span class="preprocessor"></span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_busy_cell_cnt = 0;
<a name="l02999"></a>02999       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_busy_size = 0;
<a name="l03000"></a>03000       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_free_size = 0;
<a name="l03001"></a>03001       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clist_data_size = 0;
<a name="l03002"></a>03002       adapt(clist_data, clist_data_size, clist_data_alloc_size, <span class="keyword">sizeof</span>(CListObjHeader));
<a name="l03003"></a>03003       clist_data_size = <span class="keyword">sizeof</span>(CListObjHeader);
<a name="l03004"></a>03004 
<a name="l03005"></a>03005       <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l03006"></a>03006         oid_v.push_back(koid);
<a name="l03007"></a>03007         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> busy_size = 0;
<a name="l03008"></a>03008         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> free_size = 0;
<a name="l03009"></a>03009         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> busy_cell_cnt = 0;
<a name="l03010"></a>03010         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
<a name="l03011"></a>03011         s = objectSizeGet(dbh, &amp;sz, DefaultLock, &amp;koid);
<a name="l03012"></a>03012         <span class="keywordflow">if</span> (s)
<a name="l03013"></a>03013           <span class="keywordflow">return</span> s;
<a name="l03014"></a>03014 
<a name="l03015"></a>03015         <span class="keywordflow">if</span> (sz &gt; clistobj_data_alloc_size) {
<a name="l03016"></a>03016           clistobj_data_alloc_size = sz;
<a name="l03017"></a>03017           clistobj_data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[clistobj_data_alloc_size];
<a name="l03018"></a>03018         }
<a name="l03019"></a>03019 
<a name="l03020"></a>03020         CListObjHeader h;
<a name="l03021"></a>03021         s = objectRead(dbh, 0, 0, clistobj_data, DefaultLock, 0, 0, &amp;koid);
<a name="l03022"></a>03022         <span class="keywordflow">if</span> (s)
<a name="l03023"></a>03023           <span class="keywordflow">return</span> s;
<a name="l03024"></a>03024         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *d, *edata = clistobj_data + sz;
<a name="l03025"></a>03025         <span class="keywordflow">for</span> (d = clistobj_data + <span class="keyword">sizeof</span>(CListObjHeader); d &lt; edata; ) {
<a name="l03026"></a>03026           CellHeader o;
<a name="l03027"></a>03027           mcp(&amp;o, d, <span class="keyword">sizeof</span>(CellHeader));
<a name="l03028"></a>03028           x2h_overhead(&amp;o);
<a name="l03029"></a>03029           <span class="keywordflow">if</span> (!o.free) {
<a name="l03030"></a>03030             total_busy_size += o.size;
<a name="l03031"></a>03031             busy_size += o.size;
<a name="l03032"></a>03032             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpsize = o.size + <span class="keyword">sizeof</span>(CellHeader);
<a name="l03033"></a>03033             adapt(clist_data, clist_data_size, clist_data_alloc_size, cpsize);
<a name="l03034"></a>03034             memcpy(clist_data + clist_data_size, d, cpsize);
<a name="l03035"></a>03035             clist_data_size += cpsize;
<a name="l03036"></a>03036             busy_cell_cnt++;
<a name="l03037"></a>03037             total_busy_cell_cnt++;
<a name="l03038"></a>03038           }
<a name="l03039"></a>03039           <span class="keywordflow">else</span> {
<a name="l03040"></a>03040             total_free_size += o.size;
<a name="l03041"></a>03041             free_size += o.size;
<a name="l03042"></a>03042           }
<a name="l03043"></a>03043 
<a name="l03044"></a>03044           d += <span class="keyword">sizeof</span>(CellHeader);
<a name="l03045"></a>03045           d += o.size;
<a name="l03046"></a>03046         }
<a name="l03047"></a>03047 
<a name="l03048"></a>03048 <span class="preprocessor">#ifdef COLLAPSE_TRACE</span>
<a name="l03049"></a>03049 <span class="preprocessor"></span>        printf(<span class="stringliteral">&quot;  KOID %s [%d b] {\n&quot;</span>, getOidString(&amp;koid), sz);
<a name="l03050"></a>03050         printf(<span class="stringliteral">&quot;    busy_cell_cnt: %d\n&quot;</span>, busy_cell_cnt);
<a name="l03051"></a>03051         printf(<span class="stringliteral">&quot;    busy_size: %u b\n&quot;</span>, busy_size);
<a name="l03052"></a>03052         printf(<span class="stringliteral">&quot;    free_size: %u b\n&quot;</span>, free_size);
<a name="l03053"></a>03053         printf(<span class="stringliteral">&quot;  }\n&quot;</span>);
<a name="l03054"></a>03054 <span class="preprocessor">#endif</span>
<a name="l03055"></a>03055 <span class="preprocessor"></span>        memcpy(&amp;h, clistobj_data, <span class="keyword">sizeof</span>(h));
<a name="l03056"></a>03056         x2h_header(&amp;h);
<a name="l03057"></a>03057         koid = h.clobj_next;
<a name="l03058"></a>03058         clistobj_cnt++;
<a name="l03059"></a>03059       }
<a name="l03060"></a>03060       
<a name="l03061"></a>03061       <span class="keywordflow">if</span> (idx_n || (clistobj_cnt &gt; 1 &amp;&amp; total_free_size != 0)) {
<a name="l03062"></a>03062         CListObjHeader h;
<a name="l03063"></a>03063         memset(&amp;h, 0, <span class="keyword">sizeof</span>(h));
<a name="l03064"></a>03064         h.free_cnt = 0;
<a name="l03065"></a>03065         <span class="comment">// JE PENSE QUE CELA EST FAUX: alloc_cnt indique le nombre de cells</span>
<a name="l03066"></a>03066         <span class="comment">// et pas le nombre de hashobject</span>
<a name="l03067"></a>03067         <span class="comment">// h.alloc_cnt = busy_cell_cnt; ???</span>
<a name="l03068"></a>03068         <span class="comment">//h.alloc_cnt = 1;</span>
<a name="l03069"></a>03069         h.alloc_cnt = total_busy_cell_cnt;
<a name="l03070"></a>03070         h.free_whole = 0;
<a name="l03071"></a>03071         h.cell_free_first = NullOffset;
<a name="l03072"></a>03072         CListObjHeader xh;
<a name="l03073"></a>03073         h2x_header(&amp;xh, &amp;h);
<a name="l03074"></a>03074         memcpy(clist_data, &amp;xh, <span class="keyword">sizeof</span>(xh));
<a name="l03075"></a>03075         
<a name="l03076"></a>03076         memset(&amp;chd, 0, <span class="keyword">sizeof</span>(chd));
<a name="l03077"></a>03077         s = objectCreate(dbh, clist_data, clist_data_size, dspid,
<a name="l03078"></a>03078                          &amp;chd.clobj_first);
<a name="l03079"></a>03079         <span class="keywordflow">if</span> (s)
<a name="l03080"></a>03080           <span class="keywordflow">return</span> s;
<a name="l03081"></a>03081         
<a name="l03082"></a>03082         <span class="comment">// Corrected: 4/03/08</span>
<a name="l03083"></a>03083         <span class="comment">//chd.clobj_last = chd.clobj_last;</span>
<a name="l03084"></a>03084         chd.clobj_last = chd.clobj_first;
<a name="l03085"></a>03085         
<a name="l03086"></a>03086         <span class="keywordflow">if</span> (idx_n) {
<a name="l03087"></a>03087           s = idx_n-&gt;writeCListHeader(chd_k, chd);
<a name="l03088"></a>03088         }
<a name="l03089"></a>03089         <span class="keywordflow">else</span> {
<a name="l03090"></a>03090           s = writeCListHeader(chd_k, chd);
<a name="l03091"></a>03091         }
<a name="l03092"></a>03092 
<a name="l03093"></a>03093         <span class="keywordflow">if</span> (s)
<a name="l03094"></a>03094           <span class="keywordflow">return</span> s;
<a name="l03095"></a>03095 
<a name="l03096"></a>03096 <span class="preprocessor">#ifdef COLLAPSE_TRACE</span>
<a name="l03097"></a>03097 <span class="preprocessor"></span>        printf(<span class="stringliteral">&quot;  collapse oids: %s\n&quot;</span>, getOidString(&amp;chd.clobj_first));
<a name="l03098"></a>03098 <span class="preprocessor">#endif</span>
<a name="l03099"></a>03099 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!idx_n) {
<a name="l03100"></a>03100           std::vector&lt;Oid&gt;::iterator begin = oid_v.begin();
<a name="l03101"></a>03101           std::vector&lt;Oid&gt;::iterator end = oid_v.end();
<a name="l03102"></a>03102           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> del_obj_cnt = 0;
<a name="l03103"></a>03103           <span class="keywordflow">while</span> (begin != end) {
<a name="l03104"></a>03104             s = objectDelete(dbh, &amp;(*begin));
<a name="l03105"></a>03105             <span class="keywordflow">if</span> (s)
<a name="l03106"></a>03106               <span class="keywordflow">return</span> s;
<a name="l03107"></a>03107             ++begin;
<a name="l03108"></a>03108             del_obj_cnt++;
<a name="l03109"></a>03109           }
<a name="l03110"></a>03110 <span class="preprocessor">#ifdef COLLAPSE_TRACE</span>
<a name="l03111"></a>03111 <span class="preprocessor"></span>          printf(<span class="stringliteral">&quot;  deleted obj: %d\n&quot;</span>, del_obj_cnt);
<a name="l03112"></a>03112 <span class="preprocessor">#endif</span>
<a name="l03113"></a>03113 <span class="preprocessor"></span>        }
<a name="l03114"></a>03114       }
<a name="l03115"></a>03115 <span class="preprocessor">#ifdef COLLAPSE_TRACE</span>
<a name="l03116"></a>03116 <span class="preprocessor"></span>      <span class="keywordflow">else</span>
<a name="l03117"></a>03117         printf(<span class="stringliteral">&quot;  NO COLLAPSE\n&quot;</span>);
<a name="l03118"></a>03118 <span class="preprocessor">#endif</span>
<a name="l03119"></a>03119 <span class="preprocessor"></span>
<a name="l03120"></a>03120       <span class="comment">// must delete all koid</span>
<a name="l03121"></a>03121 <span class="preprocessor">#ifdef COLLAPSE_TRACE</span>
<a name="l03122"></a>03122 <span class="preprocessor"></span>      printf(<span class="stringliteral">&quot;  clistobj_cnt: %u\n&quot;</span>, clistobj_cnt);
<a name="l03123"></a>03123       printf(<span class="stringliteral">&quot;  total_busy_cell_cnt: %u\n&quot;</span>, total_busy_cell_cnt);
<a name="l03124"></a>03124       printf(<span class="stringliteral">&quot;  total_busy_size: %u b\n&quot;</span>, total_busy_size);
<a name="l03125"></a>03125       printf(<span class="stringliteral">&quot;  total_free_size: %u b\n&quot;</span>, total_free_size);
<a name="l03126"></a>03126       printf(<span class="stringliteral">&quot;  clist_data_size: %u\n&quot;</span>, clist_data_size);
<a name="l03127"></a>03127       printf(<span class="stringliteral">&quot;  clist_data_alloc_size: %u\n&quot;</span>, clist_data_alloc_size);
<a name="l03128"></a>03128       printf(<span class="stringliteral">&quot;}\n&quot;</span>);
<a name="l03129"></a>03129 <span class="preprocessor">#endif</span>
<a name="l03130"></a>03130 <span class="preprocessor"></span>    }
<a name="l03131"></a>03131   }
<a name="l03132"></a>03132 
<a name="l03133"></a>03133   <span class="keywordflow">if</span> (idx_n) {
<a name="l03134"></a>03134     idx_n-&gt;hidx.object_count = hidx.object_count;
<a name="l03135"></a>03135     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = h2x_u32(idx_n-&gt;hidx.object_count);
<a name="l03136"></a>03136     s = objectWrite(dbh, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>),
<a name="l03137"></a>03137                     <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), &amp;count, &amp;idx_n-&gt;treeoid);
<a name="l03138"></a>03138     <span class="keywordflow">if</span> (s)
<a name="l03139"></a>03139       <span class="keywordflow">return</span> s;
<a name="l03140"></a>03140   }
<a name="l03141"></a>03141 
<a name="l03142"></a>03142   <span class="keyword">delete</span> [] clistobj_data;
<a name="l03143"></a>03143   <span class="keyword">delete</span> [] clist_data;
<a name="l03144"></a>03144   <span class="keywordflow">return</span> Success;
<a name="l03145"></a>03145 }
<a name="l03146"></a>03146 
<a name="l03147"></a>03147 <span class="keywordtype">int</span>
<a name="l03148"></a>03148 HIdx::cmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *d, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bswap)<span class="keyword"> const</span>
<a name="l03149"></a>03149 <span class="keyword"></span>{
<a name="l03150"></a>03150   <span class="keywordflow">return</span> compare(key, d, &amp;keytype, bswap);
<a name="l03151"></a>03151 }
<a name="l03152"></a>03152 
<a name="l03153"></a><a class="code" href="classeyedbsm_1_1HIdx.html#ade18c6b5a84d3011de444b5e217a6c31">03153</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#ade18c6b5a84d3011de444b5e217a6c31" title="Not yet documented.">HIdx::searchAny</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, Boolean *found, <span class="keywordtype">void</span> *xdata)
<a name="l03154"></a>03154 {
<a name="l03155"></a>03155   <span class="keywordflow">if</span> (<a class="code" href="classeyedbsm_1_1HIdx.html#af12d3e210afcd58ad73aa93908890a15" title="Not yet documented.">isDataVarSize</a>() &amp;&amp; xdata) {
<a name="l03156"></a>03156     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;Variable data size hash index: cannot use the HIdx::searchAny(const void *key, Boolean *found, void *data) method when data is not null&quot;</span>);
<a name="l03157"></a>03157   }
<a name="l03158"></a>03158 
<a name="l03159"></a>03159   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> found_cnt;
<a name="l03160"></a>03160   Status s = search_realize(key, &amp;found_cnt, True, xdata);
<a name="l03161"></a>03161   <span class="keywordflow">if</span> (s) {
<a name="l03162"></a>03162     <span class="keywordflow">return</span> s;
<a name="l03163"></a>03163   }
<a name="l03164"></a>03164   *found = (found_cnt != 0) ? eyedbsm::True : eyedbsm::False;
<a name="l03165"></a>03165   <span class="keywordflow">return</span> Success;
<a name="l03166"></a>03166 }
<a name="l03167"></a>03167 
<a name="l03168"></a><a class="code" href="classeyedbsm_1_1HIdx.html#aa1fce6266491b6cbd6b4905201d6b30d">03168</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#aa1fce6266491b6cbd6b4905201d6b30d" title="Not yet documented.">HIdx::search</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *found_cnt)
<a name="l03169"></a>03169 {
<a name="l03170"></a>03170   <span class="keywordflow">return</span> search_realize(key, found_cnt, False, 0);
<a name="l03171"></a>03171 }
<a name="l03172"></a>03172 
<a name="l03173"></a>03173 Status HIdx::search_realize(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *found_cnt, Boolean found_any, <span class="keywordtype">void</span> *xdata)
<a name="l03174"></a>03174 {
<a name="l03175"></a>03175   Status s;
<a name="l03176"></a>03176   
<a name="l03177"></a>03177   <span class="keywordflow">if</span> (stat)
<a name="l03178"></a>03178     <span class="keywordflow">return</span> stat;
<a name="l03179"></a>03179 
<a name="l03180"></a>03180   <span class="keywordflow">if</span> (s = checkOpened())
<a name="l03181"></a>03181     <span class="keywordflow">return</span> s;
<a name="l03182"></a>03182 
<a name="l03183"></a>03183   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x;
<a name="l03184"></a>03184 
<a name="l03185"></a>03185   *found_cnt = 0;
<a name="l03186"></a>03186 
<a name="l03187"></a>03187   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l03188"></a>03188   s = get_key(x, key);
<a name="l03189"></a>03189   <span class="keywordflow">if</span> (s)
<a name="l03190"></a>03190     <span class="keywordflow">return</span> s;
<a name="l03191"></a>03191 
<a name="l03192"></a>03192   CListHeader chd;
<a name="l03193"></a>03193   s = readCListHeader(x, chd);
<a name="l03194"></a>03194   <span class="keywordflow">if</span> (s)
<a name="l03195"></a>03195     <span class="keywordflow">return</span> s;
<a name="l03196"></a>03196 
<a name="l03197"></a>03197   <span class="comment">// EV: 23/04/07 it seems tchd this method search key, and can find it several time:</span>
<a name="l03198"></a>03198   <span class="comment">// but the returned xdata will contained the last data and the count</span>
<a name="l03199"></a>03199   <span class="comment">// will not be returned (only found == true)</span>
<a name="l03200"></a>03200   <span class="comment">// =&gt; we changed this method by (at least) changing Boolean found to unsigned int found_cnt</span>
<a name="l03201"></a>03201   <span class="comment">// or we add a break in case of *found == true as shown below:</span>
<a name="l03202"></a>03202   <span class="comment">// idea:</span>
<a name="l03203"></a>03203   <span class="comment">// 1. add the break, and rename the methode searchAny</span>
<a name="l03204"></a>03204   <span class="comment">// 2. add a methode ::search(const void *key, unsigned int *found_cnt)</span>
<a name="l03205"></a>03205   Oid koid = chd.clobj_first;
<a name="l03206"></a>03206   <span class="keywordflow">while</span> (koid.getNX() &gt; 0) {
<a name="l03207"></a>03207     <span class="keywordflow">if</span> (backend_interrupt)
<a name="l03208"></a>03208       <span class="keywordflow">return</span> statusMake(BACKEND_INTERRUPTED, <span class="stringliteral">&quot;&quot;</span>);
<a name="l03209"></a>03209     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;
<a name="l03210"></a>03210     Status s = objectSizeGet(dbh, &amp;size, DefaultLock, &amp;koid);
<a name="l03211"></a>03211     <span class="keywordflow">if</span> (s)
<a name="l03212"></a>03212       <span class="keywordflow">return</span> s;
<a name="l03213"></a>03213     <span class="keywordtype">char</span> *data = (<span class="keywordtype">char</span> *)m_malloc(size);
<a name="l03214"></a>03214     s = objectRead(dbh, 0, size, data, DefaultLock, 0, 0, &amp;koid);
<a name="l03215"></a>03215       
<a name="l03216"></a>03216     <span class="keywordflow">if</span> (s) {
<a name="l03217"></a>03217       free(data);
<a name="l03218"></a>03218       <span class="keywordflow">return</span> s;
<a name="l03219"></a>03219     }
<a name="l03220"></a>03220       
<a name="l03221"></a>03221     <span class="keywordtype">char</span> *d, *edata = data + size;
<a name="l03222"></a>03222     <span class="keywordflow">for</span> (d = data + <span class="keyword">sizeof</span>(CListObjHeader); d &lt; edata; ) {
<a name="l03223"></a>03223       CellHeader o;
<a name="l03224"></a>03224       mcp(&amp;o, d, <span class="keyword">sizeof</span>(CellHeader));
<a name="l03225"></a>03225       x2h_overhead(&amp;o);
<a name="l03226"></a>03226       d += <span class="keyword">sizeof</span>(CellHeader);
<a name="l03227"></a>03227 
<a name="l03228"></a>03228       <span class="keywordflow">if</span> (!o.free &amp;&amp; !cmp(key, d, OP2_SWAP)) {
<a name="l03229"></a>03229         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset;
<a name="l03230"></a>03230         <span class="keywordflow">if</span> (data_grouped_by_key) {
<a name="l03231"></a>03231           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datacnt;
<a name="l03232"></a>03232 <span class="preprocessor">#ifdef VARSZ_DATACNT</span>
<a name="l03233"></a>03233 <span class="preprocessor"></span>          s = x2h_datacnt_cpy(&amp;datacnt, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(d + get_off(d, <span class="keyword">this</span>)));
<a name="l03234"></a>03234           <span class="keywordflow">if</span> (s)
<a name="l03235"></a>03235             <span class="keywordflow">return</span> s;
<a name="l03236"></a>03236 <span class="preprocessor">#else</span>
<a name="l03237"></a>03237 <span class="preprocessor"></span>          x2h_32_cpy(&amp;datacnt, d + get_off(d, <span class="keyword">this</span>));
<a name="l03238"></a>03238 <span class="preprocessor">#endif</span>
<a name="l03239"></a>03239 <span class="preprocessor"></span>          *found_cnt += datacnt;
<a name="l03240"></a>03240           offset = data_grouped_sizeof;
<a name="l03241"></a>03241 <span class="preprocessor">#if 0</span>
<a name="l03242"></a>03242 <span class="preprocessor"></span>          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; datacnt; n++) {
<a name="l03243"></a>03243             <span class="keywordflow">if</span> (hidx.datasz == <span class="keyword">sizeof</span>(Oid)) { <span class="comment">// perharps an Oid</span>
<a name="l03244"></a>03244               Oid oo;
<a name="l03245"></a>03245               memcpy(&amp;oo, d + get_off(d, <span class="keyword">this</span>) + data_group_sz(n, <span class="keyword">this</span>), hidx.datasz);
<a name="l03246"></a>03246               printf(<span class="stringliteral">&quot;Data oid[%d]: %s\n&quot;</span>, n, getOidString(&amp;oo));
<a name="l03247"></a>03247             }
<a name="l03248"></a>03248           }
<a name="l03249"></a>03249 <span class="preprocessor">#endif</span>
<a name="l03250"></a>03250 <span class="preprocessor"></span>        }
<a name="l03251"></a>03251         <span class="keywordflow">else</span> {
<a name="l03252"></a>03252           offset = 0;
<a name="l03253"></a>03253           (*found_cnt)++;
<a name="l03254"></a>03254         }
<a name="l03255"></a>03255 
<a name="l03256"></a>03256         <span class="keywordflow">if</span> (xdata) {
<a name="l03257"></a>03257           <span class="comment">// NOTE: in case of data_grouped_by_key, only one data is copied</span>
<a name="l03258"></a>03258 <span class="preprocessor">#ifdef BUG_DATA_STORE2</span>
<a name="l03259"></a>03259 <span class="preprocessor"></span>          memcpy(xdata, d + get_off(d, <span class="keyword">this</span>) + offset, hidx.datasz);
<a name="l03260"></a>03260 <span class="preprocessor">#else</span>
<a name="l03261"></a>03261 <span class="preprocessor"></span>          memcpy(xdata, d + o.size - hidx.datasz, hidx.datasz);
<a name="l03262"></a>03262 <span class="preprocessor">#endif</span>
<a name="l03263"></a>03263 <span class="preprocessor"></span>        }
<a name="l03264"></a>03264 
<a name="l03265"></a>03265         <span class="keywordflow">if</span> (found_any)
<a name="l03266"></a>03266           <span class="keywordflow">break</span>;
<a name="l03267"></a>03267       }
<a name="l03268"></a>03268           
<a name="l03269"></a>03269       d += o.size;
<a name="l03270"></a>03270     }
<a name="l03271"></a>03271       
<a name="l03272"></a>03272     CListObjHeader h;
<a name="l03273"></a>03273     mcp(&amp;h, data, <span class="keyword">sizeof</span>(CListObjHeader));
<a name="l03274"></a>03274     x2h_header(&amp;h);
<a name="l03275"></a>03275     <span class="comment">//koid = h.clobj_free_next;</span>
<a name="l03276"></a>03276     koid = h.clobj_next;
<a name="l03277"></a>03277     free(data);
<a name="l03278"></a>03278 
<a name="l03279"></a>03279     <span class="comment">// break added in case of *found == true</span>
<a name="l03280"></a>03280     <span class="keywordflow">if</span> (*found_cnt &amp;&amp; found_any) {
<a name="l03281"></a>03281       <span class="keywordflow">break</span>;
<a name="l03282"></a>03282     }
<a name="l03283"></a>03283   }
<a name="l03284"></a>03284 
<a name="l03285"></a>03285   <span class="keywordflow">return</span> Success;
<a name="l03286"></a>03286 }
<a name="l03287"></a>03287 
<a name="l03288"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a5d0f946b0e687d888e0da37a25dcca3b">03288</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a5d0f946b0e687d888e0da37a25dcca3b" title="Not yet documented.">HIdx::destroy</a>()
<a name="l03289"></a>03289 {
<a name="l03290"></a>03290   Status s = destroy_r();
<a name="l03291"></a>03291   <span class="keywordflow">if</span> (s)
<a name="l03292"></a>03292     <span class="keywordflow">return</span> s;
<a name="l03293"></a>03293   <span class="keywordflow">return</span> objectDelete(dbh, &amp;treeoid);
<a name="l03294"></a>03294 }
<a name="l03295"></a>03295 
<a name="l03296"></a>03296 Status HIdx::destroy_r()
<a name="l03297"></a>03297 {
<a name="l03298"></a>03298   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; hidx.key_count; n++) {
<a name="l03299"></a>03299     CListHeader chd;
<a name="l03300"></a>03300     Status s = readCListHeader(n, chd);
<a name="l03301"></a>03301     <span class="keywordflow">if</span> (s)
<a name="l03302"></a>03302       <span class="keywordflow">return</span> s;
<a name="l03303"></a>03303 
<a name="l03304"></a>03304     Oid koid = chd.clobj_first;
<a name="l03305"></a>03305 
<a name="l03306"></a>03306     <span class="keywordflow">while</span> (koid.getNX()) {
<a name="l03307"></a>03307       CListObjHeader h;
<a name="l03308"></a>03308       Status s = readCListObjHeader(koid, h);
<a name="l03309"></a>03309       <span class="keywordflow">if</span> (s)
<a name="l03310"></a>03310         <span class="keywordflow">return</span> s;
<a name="l03311"></a>03311 
<a name="l03312"></a>03312       s = objectDelete(dbh, &amp;koid);
<a name="l03313"></a>03313       <span class="keywordflow">if</span> (s)
<a name="l03314"></a>03314         <span class="keywordflow">return</span> s;
<a name="l03315"></a>03315 
<a name="l03316"></a>03316       koid = h.clobj_next;
<a name="l03317"></a>03317     }
<a name="l03318"></a>03318   }
<a name="l03319"></a>03319 
<a name="l03320"></a>03320   <span class="keywordflow">return</span> Success;
<a name="l03321"></a>03321 }
<a name="l03322"></a>03322 
<a name="l03323"></a>03323 Status
<a name="l03324"></a>03324 HIdx::headPrint(FILE *fd, <span class="keywordtype">int</span> n, Oid *koid, <span class="keywordtype">int</span> &amp;count)<span class="keyword"> const</span>
<a name="l03325"></a>03325 <span class="keyword"></span>{
<a name="l03326"></a>03326   CListObjHeader h;
<a name="l03327"></a>03327   Status s = objectRead(dbh, 0, <span class="keyword">sizeof</span>(CListObjHeader), &amp;h, DefaultLock, 0,
<a name="l03328"></a>03328                               0, koid);
<a name="l03329"></a>03329 
<a name="l03330"></a>03330   <span class="keywordflow">if</span> (s)
<a name="l03331"></a>03331     <span class="keywordflow">return</span> s;
<a name="l03332"></a>03332   x2h_header(&amp;h);
<a name="l03333"></a>03333 
<a name="l03334"></a>03334   count = h.alloc_cnt;
<a name="l03335"></a>03335   fprintf(fd, <span class="stringliteral">&quot;\tsubcell[%d] %s {\n&quot;</span>, n, getOidString(koid));
<a name="l03336"></a>03336   fprintf(fd, <span class="stringliteral">&quot;\t\tsize       = %d;\n&quot;</span>, h.size);
<a name="l03337"></a>03337   fprintf(fd, <span class="stringliteral">&quot;\t\tnfree      = %d;\n&quot;</span>, h.free_cnt);
<a name="l03338"></a>03338   fprintf(fd, <span class="stringliteral">&quot;\t\tnalloc     = %d;\n&quot;</span>, h.alloc_cnt);
<a name="l03339"></a>03339   fprintf(fd, <span class="stringliteral">&quot;\t\tfree_whole = %d;\n&quot;</span>, h.free_whole);
<a name="l03340"></a>03340   fprintf(fd, <span class="stringliteral">&quot;\t\tfirstfree  = %d;\n&quot;</span>, h.cell_free_first);
<a name="l03341"></a>03341   fprintf(fd, <span class="stringliteral">&quot;\t\tprev       = %s;\n&quot;</span>, getOidString(&amp;h.clobj_prev));
<a name="l03342"></a>03342   fprintf(fd, <span class="stringliteral">&quot;\t\tnext       = %s;\n&quot;</span>, getOidString(&amp;h.clobj_next));
<a name="l03343"></a>03343   fprintf(fd, <span class="stringliteral">&quot;\t\tfree_prev  = %s;\n&quot;</span>, getOidString(&amp;h.clobj_free_prev));
<a name="l03344"></a>03344   fprintf(fd, <span class="stringliteral">&quot;\t\tfree_next  = %s;\n&quot;</span>, getOidString(&amp;h.clobj_free_next));
<a name="l03345"></a>03345   fprintf(fd, <span class="stringliteral">&quot;\t};\n&quot;</span>);
<a name="l03346"></a>03346   *koid = h.clobj_next;
<a name="l03347"></a>03347 
<a name="l03348"></a>03348   <span class="keywordflow">return</span> Success;
<a name="l03349"></a>03349 }
<a name="l03350"></a>03350 
<a name="l03351"></a>03351 Status
<a name="l03352"></a>03352 HIdx::getHashObjectBusySize(<span class="keyword">const</span> Oid *koid, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;osize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size)<span class="keyword"> const</span>
<a name="l03353"></a>03353 <span class="keyword"></span>{
<a name="l03354"></a>03354   <span class="keywordflow">if</span> (!STRTYPE(<span class="keyword">this</span>) &amp;&amp; !data_grouped_by_key) {
<a name="l03355"></a>03355     CListObjHeader h;
<a name="l03356"></a>03356     Status s = objectRead(dbh, 0, <span class="keyword">sizeof</span>(CListObjHeader), &amp;h, DefaultLock, 0,
<a name="l03357"></a>03357                                 0, koid);
<a name="l03358"></a>03358     
<a name="l03359"></a>03359     <span class="keywordflow">if</span> (s)
<a name="l03360"></a>03360       <span class="keywordflow">return</span> s;
<a name="l03361"></a>03361     x2h_header(&amp;h);
<a name="l03362"></a>03362   
<a name="l03363"></a>03363     osize = h.alloc_cnt * (<span class="keyword">sizeof</span>(CellHeader) + hidx.keysz + hidx.datasz) + <span class="keyword">sizeof</span>(CListObjHeader);
<a name="l03364"></a>03364     count = h.alloc_cnt;
<a name="l03365"></a>03365     <span class="keywordflow">return</span> Success;
<a name="l03366"></a>03366   }
<a name="l03367"></a>03367 
<a name="l03368"></a>03368   Status s;
<a name="l03369"></a>03369   <span class="keywordflow">if</span> (!size) {
<a name="l03370"></a>03370     s = objectSizeGet(dbh, &amp;size, DefaultLock, koid);
<a name="l03371"></a>03371     <span class="keywordflow">if</span> (s)
<a name="l03372"></a>03372       <span class="keywordflow">return</span> s;
<a name="l03373"></a>03373   }
<a name="l03374"></a>03374 
<a name="l03375"></a>03375   osize = <span class="keyword">sizeof</span>(CListObjHeader);
<a name="l03376"></a>03376 
<a name="l03377"></a>03377   <span class="keywordtype">char</span> *data;
<a name="l03378"></a>03378   <span class="keywordflow">if</span> (nocopy) {
<a name="l03379"></a>03379     s = objectReadNoCopy(dbh, 0, size, &amp;data, DefaultLock, 0, 0, koid);
<a name="l03380"></a>03380   }
<a name="l03381"></a>03381   <span class="keywordflow">else</span> {
<a name="l03382"></a>03382     data = (<span class="keywordtype">char</span> *)m_malloc(size);
<a name="l03383"></a>03383     s = objectRead(dbh, 0, size, data, DefaultLock, 0, 0, koid);
<a name="l03384"></a>03384   }
<a name="l03385"></a>03385 
<a name="l03386"></a>03386   <span class="keywordflow">if</span> (s) {<span class="keywordflow">if</span> (!nocopy) free(data); <span class="keywordflow">return</span> s;}
<a name="l03387"></a>03387 
<a name="l03388"></a>03388   count = 0;
<a name="l03389"></a>03389   <span class="keywordtype">int</span> cur = <span class="keyword">sizeof</span>(CListObjHeader);
<a name="l03390"></a>03390   <span class="keywordflow">while</span> (cur + <span class="keyword">sizeof</span>(CellHeader) &lt;= size) {
<a name="l03391"></a>03391     CellHeader to;
<a name="l03392"></a>03392     s = readCellHeader(cur, *koid, to);
<a name="l03393"></a>03393     <span class="keywordflow">if</span> (s) {<span class="keywordflow">if</span> (!nocopy) free(data); <span class="keywordflow">return</span> s;}
<a name="l03394"></a>03394     cur += <span class="keyword">sizeof</span>(CellHeader);
<a name="l03395"></a>03395     <span class="keywordflow">if</span> (!to.free) {
<a name="l03396"></a>03396       <span class="comment">//      osize += sizeof(CellHeader) + strlen(data+cur)+1 + hidx.datasz;</span>
<a name="l03397"></a>03397       osize += <span class="keyword">sizeof</span>(CellHeader) + to.size;
<a name="l03398"></a>03398       if (data_grouped_by_key) {
<a name="l03399"></a>03399         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> datacnt;
<a name="l03400"></a>03400 <span class="preprocessor">#ifdef VARSZ_DATACNT</span>
<a name="l03401"></a>03401 <span class="preprocessor"></span>        s = x2h_datacnt_cpy(&amp;datacnt, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(data + cur + get_off(data + cur, <span class="keyword">this</span>)));
<a name="l03402"></a>03402         <span class="keywordflow">if</span> (s)
<a name="l03403"></a>03403           <span class="keywordflow">return</span> s;
<a name="l03404"></a>03404 <span class="preprocessor">#else</span>
<a name="l03405"></a>03405 <span class="preprocessor"></span>        x2h_32_cpy(&amp;datacnt, data + cur + get_off(data + cur, <span class="keyword">this</span>));
<a name="l03406"></a>03406 <span class="preprocessor">#endif</span>
<a name="l03407"></a>03407 <span class="preprocessor"></span>        count += datacnt;
<a name="l03408"></a>03408       }
<a name="l03409"></a>03409       <span class="keywordflow">else</span>
<a name="l03410"></a>03410         count++;
<a name="l03411"></a>03411     }
<a name="l03412"></a>03412     <span class="comment">//    printf(&quot;SIZES &apos;%s&apos; %d %d %d free=%d\n&quot;, data+cur, to.size + sizeof(CellHeader), sizeof(CellHeader) + strlen(data+cur)+1, hidx.datasz, to.free);</span>
<a name="l03413"></a>03413     cur += to.size;
<a name="l03414"></a>03414   }
<a name="l03415"></a>03415 
<a name="l03416"></a>03416   <span class="keywordflow">if</span> (!nocopy)
<a name="l03417"></a>03417     free(data);
<a name="l03418"></a>03418   <span class="keywordflow">return</span> Success;
<a name="l03419"></a>03419 }
<a name="l03420"></a>03420 
<a name="l03421"></a>03421 Status
<a name="l03422"></a>03422 HIdx::getEntryCount(Oid *koid, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;count)<span class="keyword"> const</span>
<a name="l03423"></a>03423 <span class="keyword"></span>{
<a name="l03424"></a>03424   <span class="keywordflow">if</span> (koid-&gt;getNX() == 0) {
<a name="l03425"></a>03425     count = 0;
<a name="l03426"></a>03426     <span class="keywordflow">return</span> Success;
<a name="l03427"></a>03427   }
<a name="l03428"></a>03428 
<a name="l03429"></a>03429   CListObjHeader h;
<a name="l03430"></a>03430   Status s = objectRead(dbh, 0, <span class="keyword">sizeof</span>(CListObjHeader), &amp;h, DefaultLock, 0,
<a name="l03431"></a>03431                               0, koid);
<a name="l03432"></a>03432 
<a name="l03433"></a>03433   <span class="keywordflow">if</span> (s)
<a name="l03434"></a>03434     <span class="keywordflow">return</span> s;
<a name="l03435"></a>03435   x2h_header(&amp;h);
<a name="l03436"></a>03436 
<a name="l03437"></a>03437   count = h.alloc_cnt;
<a name="l03438"></a>03438   *koid = h.clobj_next;
<a name="l03439"></a>03439 
<a name="l03440"></a>03440   <span class="keywordflow">return</span> Success;
<a name="l03441"></a>03441 }
<a name="l03442"></a>03442 
<a name="l03443"></a>03443 <span class="comment">//#define ALL_STATS</span>
<a name="l03444"></a>03444 
<a name="l03445"></a>03445 Status
<a name="l03446"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a51a26d76a66894c0106c4fab416faeb8">03446</a> HIdx::dumpMemoryMap(FILE *fd)
<a name="l03447"></a>03447 {
<a name="l03448"></a>03448   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; hidx.key_count; n++) {
<a name="l03449"></a>03449     CListHeader chd;
<a name="l03450"></a>03450     Status s = readCListHeader(n, chd);
<a name="l03451"></a>03451     <span class="keywordflow">if</span> (s)
<a name="l03452"></a>03452       <span class="keywordflow">return</span> s;
<a name="l03453"></a>03453     Oid koid = chd.clobj_first;
<a name="l03454"></a>03454     <span class="keywordflow">if</span> (!koid.getNX()) <span class="keywordflow">continue</span>;
<a name="l03455"></a>03455     <span class="keywordflow">if</span> (s)
<a name="l03456"></a>03456       <span class="keywordflow">return</span> s;
<a name="l03457"></a>03457     s = dumpMemoryMap(chd, (std::string(<span class="stringliteral">&quot;Entry #&quot;</span>) + str_convert((<span class="keywordtype">long</span>)n) + <span class="stringliteral">&quot; &quot;</span>).c_str(),
<a name="l03458"></a>03458                       fd);
<a name="l03459"></a>03459     <span class="keywordflow">if</span> (s)
<a name="l03460"></a>03460       <span class="keywordflow">return</span> s;
<a name="l03461"></a>03461   }
<a name="l03462"></a>03462 
<a name="l03463"></a>03463   <span class="keywordflow">return</span> Success;
<a name="l03464"></a>03464 }
<a name="l03465"></a>03465 
<a name="l03466"></a><a class="code" href="classeyedbsm_1_1HIdx.html#afd6d4edf2eb4c3bcf8dfcb66606f988b">03466</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#afd6d4edf2eb4c3bcf8dfcb66606f988b" title="Not yet documented.">HIdx::printStat</a>(FILE *fd)<span class="keyword"> const</span>
<a name="l03467"></a>03467 <span class="keyword"></span>{
<a name="l03468"></a>03468   <span class="comment">//const Oid *koid;</span>
<a name="l03469"></a>03469   <span class="keywordtype">int</span> n, total;
<a name="l03470"></a>03470 
<a name="l03471"></a>03471   <span class="keywordflow">if</span> (!fd)
<a name="l03472"></a>03472     fd = stdout;
<a name="l03473"></a>03473 
<a name="l03474"></a>03474 <span class="preprocessor">#ifdef ALL_STATS</span>
<a name="l03475"></a>03475 <span class="preprocessor"></span>  fprintf(fd, <span class="stringliteral">&quot;index bsize = 0x%x\n&quot;</span>, hidx.impl_hints[IniSize_Hints]);
<a name="l03476"></a>03476 <span class="preprocessor">#endif</span>
<a name="l03477"></a>03477 <span class="preprocessor"></span>  fprintf(fd, <span class="stringliteral">&quot;\tkey_count = %d\n&quot;</span>, hidx.key_count);
<a name="l03478"></a>03478   fflush(fd);
<a name="l03479"></a>03479 
<a name="l03480"></a>03480   total = 0;
<a name="l03481"></a>03481 
<a name="l03482"></a>03482   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; hidx.key_count; n++) {
<a name="l03483"></a>03483     CListHeader chd;
<a name="l03484"></a>03484     Status s = readCListHeader(n, chd);
<a name="l03485"></a>03485     <span class="keywordflow">if</span> (s)
<a name="l03486"></a>03486       <span class="keywordflow">return</span> s;
<a name="l03487"></a>03487 
<a name="l03488"></a>03488 <span class="preprocessor">#ifdef ALL_STATS</span>
<a name="l03489"></a>03489 <span class="preprocessor"></span>    fprintf(fd, <span class="stringliteral">&quot;cell[%d] = {\n&quot;</span>, n);
<a name="l03490"></a>03490     fprintf(fd, <span class="stringliteral">&quot;\tfirst      = %s;\n&quot;</span>, getOidString(&amp;chd.clobj_first));
<a name="l03491"></a>03491     fprintf(fd, <span class="stringliteral">&quot;\tlast       = %s;\n&quot;</span>, getOidString(&amp;chd.clobj_last));
<a name="l03492"></a>03492     fprintf(fd, <span class="stringliteral">&quot;\tfree_first = %s;\n&quot;</span>, getOidString(&amp;chd.clobj_free_first));
<a name="l03493"></a>03493 <span class="preprocessor">#endif</span>
<a name="l03494"></a>03494 <span class="preprocessor"></span>
<a name="l03495"></a>03495     Oid toid;
<a name="l03496"></a>03496     toid = chd.clobj_first;
<a name="l03497"></a>03497     <span class="keywordtype">int</span> cell_count = 0;
<a name="l03498"></a>03498 
<a name="l03499"></a>03499     <span class="keywordflow">while</span> (toid.getNX() &gt; 0) {
<a name="l03500"></a>03500       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count;
<a name="l03501"></a>03501       <span class="keywordflow">if</span> (backend_interrupt) {
<a name="l03502"></a>03502         <span class="comment">/*</span>
<a name="l03503"></a>03503 <span class="comment">        fprintf(fd, &quot;Interrupted!\n&quot;);</span>
<a name="l03504"></a>03504 <span class="comment">        fprintf(fd, &quot;\tpartial total count = %d\n&quot;, total);</span>
<a name="l03505"></a>03505 <span class="comment">        fflush(fd);</span>
<a name="l03506"></a>03506 <span class="comment">        */</span>
<a name="l03507"></a>03507         <span class="keywordflow">return</span> statusMake(BACKEND_INTERRUPTED, <span class="stringliteral">&quot;&quot;</span>);
<a name="l03508"></a>03508       }
<a name="l03509"></a>03509 
<a name="l03510"></a>03510       s = getEntryCount(&amp;toid, count);
<a name="l03511"></a>03511       <span class="keywordflow">if</span> (s) {
<a name="l03512"></a>03512         statusPrint(s, <span class="stringliteral">&quot;&quot;</span>);
<a name="l03513"></a>03513         fflush(fd);
<a name="l03514"></a>03514         <span class="keywordflow">return</span> s;
<a name="l03515"></a>03515       }
<a name="l03516"></a>03516       cell_count += count;
<a name="l03517"></a>03517     }
<a name="l03518"></a>03518 <span class="preprocessor">#ifdef ALL_STATS</span>
<a name="l03519"></a>03519 <span class="preprocessor"></span><span class="preprocessor">#ifndef PRINT_DETAILS</span>
<a name="l03520"></a>03520 <span class="preprocessor"></span>    fprintf(fd, <span class="stringliteral">&quot;\tcount      = %d;\n&quot;</span>, cell_count);
<a name="l03521"></a>03521 <span class="preprocessor">#endif</span>
<a name="l03522"></a>03522 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l03523"></a>03523 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (cell_count) {
<a name="l03524"></a>03524       fprintf(fd, <span class="stringliteral">&quot;\tcell[%d] -&gt; %d\n&quot;</span>, n, cell_count);
<a name="l03525"></a>03525       fflush(fd);
<a name="l03526"></a>03526     }
<a name="l03527"></a>03527 <span class="preprocessor">#endif</span>
<a name="l03528"></a>03528 <span class="preprocessor"></span>    total += cell_count;
<a name="l03529"></a>03529 <span class="preprocessor">#ifdef ALL_STATS</span>
<a name="l03530"></a>03530 <span class="preprocessor"></span>    fprintf(fd, <span class="stringliteral">&quot;};\n\n&quot;</span>);
<a name="l03531"></a>03531 <span class="preprocessor">#endif</span>
<a name="l03532"></a>03532 <span class="preprocessor"></span>  }
<a name="l03533"></a>03533 
<a name="l03534"></a>03534   fprintf(fd, <span class="stringliteral">&quot;\ttotal count = %d [%d]\n&quot;</span>, total, <a class="code" href="classeyedbsm_1_1HIdx.html#a4a1776668092d49a37a337cc92523e0f" title="Not yet documented.">getCount</a>());
<a name="l03535"></a>03535   fflush(fd);
<a name="l03536"></a>03536   <span class="keywordflow">return</span> Success;
<a name="l03537"></a>03537 }
<a name="l03538"></a>03538 
<a name="l03539"></a>03539 <span class="preprocessor">#define ONE_LIST</span>
<a name="l03540"></a>03540 <span class="preprocessor"></span>
<a name="l03541"></a>03541 <span class="keyword">struct </span>Link {
<a name="l03542"></a>03542 
<a name="l03543"></a>03543   Link(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz) {
<a name="l03544"></a>03544     data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[sz];
<a name="l03545"></a>03545     next = 0;
<a name="l03546"></a>03546   }
<a name="l03547"></a>03547 
<a name="l03548"></a>03548   ~Link() {
<a name="l03549"></a>03549     <span class="keyword">delete</span> [] data;
<a name="l03550"></a>03550   }
<a name="l03551"></a>03551 
<a name="l03552"></a>03552   Idx::Key key;
<a name="l03553"></a>03553   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data;
<a name="l03554"></a>03554   Link *next;
<a name="l03555"></a>03555 
<a name="l03556"></a>03556 <span class="keyword">private</span>:
<a name="l03557"></a>03557   <span class="comment">// forbidden</span>
<a name="l03558"></a>03558   Link(<span class="keyword">const</span> Link &amp;);
<a name="l03559"></a>03559   Link &amp;operator=(<span class="keyword">const</span> Link &amp;);
<a name="l03560"></a>03560 };
<a name="l03561"></a>03561 
<a name="l03562"></a>03562 <span class="keyword">class </span>HIdxCursor::LinkList {
<a name="l03563"></a>03563 
<a name="l03564"></a>03564 <span class="keyword">public</span>:
<a name="l03565"></a>03565   LinkList() {first = last = 0; cnt = 0;}
<a name="l03566"></a>03566 
<a name="l03567"></a>03567   <span class="keywordtype">void</span> insert(Link *l) {
<a name="l03568"></a>03568     eyedblib::MutexLocker _(mt);
<a name="l03569"></a>03569     <span class="keywordflow">if</span> (last)
<a name="l03570"></a>03570       last-&gt;next = l;
<a name="l03571"></a>03571     <span class="keywordflow">if</span> (!first)
<a name="l03572"></a>03572       first = l;
<a name="l03573"></a>03573     last = l;
<a name="l03574"></a>03574     cnt++;
<a name="l03575"></a>03575   }
<a name="l03576"></a>03576 
<a name="l03577"></a>03577   Link *peek() {
<a name="l03578"></a>03578     eyedblib::MutexLocker _(mt);
<a name="l03579"></a>03579     <span class="keywordflow">if</span> (first) {
<a name="l03580"></a>03580       Link *l = first;
<a name="l03581"></a>03581       first = first-&gt;next;
<a name="l03582"></a>03582       <span class="keywordflow">if</span> (!first) last = 0;
<a name="l03583"></a>03583       cnt--;
<a name="l03584"></a>03584       <span class="keywordflow">return</span> l;
<a name="l03585"></a>03585     }
<a name="l03586"></a>03586     <span class="keywordflow">return</span> 0;
<a name="l03587"></a>03587   }
<a name="l03588"></a>03588 
<a name="l03589"></a>03589   <span class="keywordtype">int</span> getCount()<span class="keyword"> const </span>{
<a name="l03590"></a>03590     eyedblib::MutexLocker _(mt);
<a name="l03591"></a>03591     <span class="keywordflow">return</span> cnt;
<a name="l03592"></a>03592   }
<a name="l03593"></a>03593 
<a name="l03594"></a>03594   ~LinkList() {
<a name="l03595"></a>03595     eyedblib::MutexLocker _(mt);
<a name="l03596"></a>03596     Link *l = first;
<a name="l03597"></a>03597     <span class="keywordflow">while</span> (l) {
<a name="l03598"></a>03598       Link *next = l-&gt;next;
<a name="l03599"></a>03599       <span class="keyword">delete</span> l;
<a name="l03600"></a>03600       l = next;
<a name="l03601"></a>03601     }
<a name="l03602"></a>03602   }
<a name="l03603"></a>03603 
<a name="l03604"></a>03604 <span class="keyword">private</span>:
<a name="l03605"></a>03605   <span class="keyword">mutable</span> eyedblib::Mutex mt;
<a name="l03606"></a>03606   Link *first, *last;
<a name="l03607"></a>03607   <span class="keywordtype">int</span> cnt;
<a name="l03608"></a>03608 };
<a name="l03609"></a>03609 
<a name="l03610"></a>03610 <span class="keyword">extern</span> eyedblib::ThreadPool *getThreadPool();
<a name="l03611"></a>03611 
<a name="l03612"></a>03612 <span class="preprocessor">#define MIN_OBJCNT_FOR_PARALLEL 10</span>
<a name="l03613"></a>03613 <span class="preprocessor"></span><span class="comment">//#define MIN_KEYCNT_FOR_PARALLEL 10</span>
<a name="l03614"></a>03614 
<a name="l03615"></a>03615 <span class="keyword">static</span> eyedblib::ThreadPerformerArg
<a name="l03616"></a>03616 cursor_perform_wrapper(eyedblib::ThreadPerformerArg xarg)
<a name="l03617"></a>03617 {
<a name="l03618"></a>03618   HIdxCursor *cur = (HIdxCursor *)xarg.data;
<a name="l03619"></a>03619   for (;;) {
<a name="l03620"></a>03620     Boolean found;
<a name="l03621"></a>03621     Status s = cur-&gt;next(&amp;found);
<a name="l03622"></a>03622     <span class="keywordflow">if</span> (s)
<a name="l03623"></a>03623       <span class="keywordflow">return</span> eyedblib::ThreadPerformerArg((<span class="keywordtype">void</span> *)s);
<a name="l03624"></a>03624     <span class="keywordflow">if</span> (!found)
<a name="l03625"></a>03625       <span class="keywordflow">return</span> 0;
<a name="l03626"></a>03626   }
<a name="l03627"></a>03627   <span class="keywordflow">return</span> 0;
<a name="l03628"></a>03628 }
<a name="l03629"></a>03629 
<a name="l03630"></a>03630 <span class="keyword">static</span> <span class="keywordtype">int</span> user_cmp_mod;
<a name="l03631"></a>03631 
<a name="l03632"></a>03632 <span class="keyword">static</span> Boolean 
<a name="l03633"></a>03633 user_cmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *)
<a name="l03634"></a>03634 {
<a name="l03635"></a>03635   <span class="keyword">static</span> eyedblib::Mutex mt;
<a name="l03636"></a>03636   <span class="comment">//  eyedblib::MutexLocker _(mt);</span>
<a name="l03637"></a>03637   <span class="keyword">static</span> <span class="keywordtype">int</span> cnt;
<a name="l03638"></a>03638   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; 50; n++) ;
<a name="l03639"></a>03639   <span class="keywordflow">if</span> (!(cnt++ % user_cmp_mod)) <span class="keywordflow">return</span> True;
<a name="l03640"></a>03640   <span class="keywordflow">return</span> False;
<a name="l03641"></a>03641 }
<a name="l03642"></a>03642 
<a name="l03643"></a>03643 Boolean
<a name="l03644"></a>03644 HIdxCursor::parallelInit(<span class="keywordtype">int</span> thread_cnt)
<a name="l03645"></a>03645 {
<a name="l03646"></a>03646   <span class="comment">/*</span>
<a name="l03647"></a>03647 <span class="comment">  if ((skey &amp;&amp; ekey) || !user_cmp ||</span>
<a name="l03648"></a>03648 <span class="comment">      idx-&gt;hidx.object_count &lt;= MIN_OBJCNT_FOR_PARALLEL)</span>
<a name="l03649"></a>03649 <span class="comment">    return False;</span>
<a name="l03650"></a>03650 <span class="comment">  */</span>
<a name="l03651"></a>03651 
<a name="l03652"></a>03652   <span class="keywordflow">if</span> (thread_cnt &lt; 2 || idx-&gt;hidx.object_count &lt;= MIN_OBJCNT_FOR_PARALLEL ||
<a name="l03653"></a>03653       (skey &amp;&amp; ekey &amp;&amp; !idx-&gt;cmp(skey, ekey, OPS_NOSWAP))) <span class="comment">/*(skey &amp;&amp; ekey) || */</span> <span class="comment">// WARNING : 24/02/03 !!</span>
<a name="l03654"></a>03654     <span class="keywordflow">return</span> False;
<a name="l03655"></a>03655 
<a name="l03656"></a>03656   thrpool = getThreadPool();
<a name="l03657"></a>03657   <span class="keywordflow">if</span> (!thrpool)
<a name="l03658"></a>03658     <span class="keywordflow">return</span> False;
<a name="l03659"></a>03659 
<a name="l03660"></a>03660   perf_cnt = thrpool-&gt;getThreadCount();
<a name="l03661"></a>03661 
<a name="l03662"></a>03662   <span class="keywordflow">if</span> (perf_cnt &gt; thread_cnt)
<a name="l03663"></a>03663     perf_cnt = thread_cnt;
<a name="l03664"></a>03664 
<a name="l03665"></a>03665   <span class="keywordflow">if</span> (perf_cnt &lt; 1)
<a name="l03666"></a>03666     <span class="keywordflow">return</span> False;
<a name="l03667"></a>03667 
<a name="l03668"></a>03668   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> itv = idx-&gt;hidx.key_count / perf_cnt;
<a name="l03669"></a>03669 
<a name="l03670"></a>03670   <span class="keywordflow">if</span> (itv &lt; 1)
<a name="l03671"></a>03671     <span class="keywordflow">return</span> False;
<a name="l03672"></a>03672 
<a name="l03673"></a>03673   <span class="comment">/*</span>
<a name="l03674"></a>03674 <span class="comment">  printf(&quot;Hash Cursor %s candidate for parallelization: perf_cnt=%d, itv=%d, &quot;</span>
<a name="l03675"></a>03675 <span class="comment">         &quot;max_threads=%d\n&quot;,</span>
<a name="l03676"></a>03676 <span class="comment">         getOidString(&amp;idx-&gt;treeoid),</span>
<a name="l03677"></a>03677 <span class="comment">         perf_cnt, itv,  thrpool-&gt;getThreadCount());</span>
<a name="l03678"></a>03678 <span class="comment">  */</span>
<a name="l03679"></a>03679 
<a name="l03680"></a>03680   master = True;
<a name="l03681"></a>03681 <span class="preprocessor">#ifdef MULTI_LIST</span>
<a name="l03682"></a>03682 <span class="preprocessor"></span>  lists = <span class="keyword">new</span> LinkList*[perf_cnt];
<a name="l03683"></a>03683   list = 0;
<a name="l03684"></a>03684 <span class="preprocessor">#else</span>
<a name="l03685"></a>03685 <span class="preprocessor"></span>  list = <span class="keyword">new</span> LinkList();
<a name="l03686"></a>03686   lists = 0;
<a name="l03687"></a>03687 <span class="preprocessor">#endif</span>
<a name="l03688"></a>03688 <span class="preprocessor"></span>  perf_curs = <span class="keyword">new</span> HIdxCursor*[perf_cnt];
<a name="l03689"></a>03689 
<a name="l03690"></a>03690   <span class="comment">/*</span>
<a name="l03691"></a>03691 <span class="comment">  const char *s = getenv(&quot;ESM_STD_USER_CMP&quot;);</span>
<a name="l03692"></a>03692 <span class="comment">  if (s) {</span>
<a name="l03693"></a>03693 <span class="comment">    user_cmp = user_cmp;</span>
<a name="l03694"></a>03694 <span class="comment">    user_cmp_mod = atoi(s);</span>
<a name="l03695"></a>03695 <span class="comment">  }</span>
<a name="l03696"></a>03696 <span class="comment">  */</span>
<a name="l03697"></a>03697 
<a name="l03698"></a>03698   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; perf_cnt; n++) {
<a name="l03699"></a>03699 <span class="preprocessor">#ifdef MULTI_LIST</span>
<a name="l03700"></a>03700 <span class="preprocessor"></span>    lists[n] = <span class="keyword">new</span> LinkList();
<a name="l03701"></a>03701     perf_curs[n] = <span class="keyword">new</span> HIdxCursor
<a name="l03702"></a>03702       (idx,
<a name="l03703"></a>03703        n*itv,
<a name="l03704"></a>03704        (n == perf_cnt-1 ? idx-&gt;hidx.key_count : (n+1)*itv),
<a name="l03705"></a>03705        skey, ekey,
<a name="l03706"></a>03706        sexcl, eexcl,
<a name="l03707"></a>03707        user_cmp, cmp_arg,
<a name="l03708"></a>03708        lists[n]);
<a name="l03709"></a>03709 <span class="preprocessor">#else</span>
<a name="l03710"></a>03710 <span class="preprocessor"></span>    perf_curs[n] = <span class="keyword">new</span> HIdxCursor
<a name="l03711"></a>03711       (idx,
<a name="l03712"></a>03712        n*itv,
<a name="l03713"></a>03713        (n == perf_cnt-1 ? idx-&gt;hidx.key_count : (n+1)*itv),
<a name="l03714"></a>03714        skey, ekey,
<a name="l03715"></a>03715        sexcl, eexcl,
<a name="l03716"></a>03716        user_cmp, cmp_arg,
<a name="l03717"></a>03717        list);
<a name="l03718"></a>03718 <span class="preprocessor">#endif</span>
<a name="l03719"></a>03719 <span class="preprocessor"></span>  }
<a name="l03720"></a>03720 
<a name="l03721"></a>03721   <span class="comment">/*</span>
<a name="l03722"></a>03722 <span class="comment">  s = getenv(&quot;ESM_MAX_PERF_CNT&quot;);</span>
<a name="l03723"></a>03723 <span class="comment">  if (s) {</span>
<a name="l03724"></a>03724 <span class="comment">    unsigned int cnt = atoi(getenv(&quot;ESM_MAX_PERF_CNT&quot;));</span>
<a name="l03725"></a>03725 <span class="comment">    if (perf_cnt &gt; cnt) {</span>
<a name="l03726"></a>03726 <span class="comment">      perf_cnt = cnt;</span>
<a name="l03727"></a>03727 <span class="comment">      printf(&quot;limited perf_cnt to %d\n&quot;, perf_cnt);</span>
<a name="l03728"></a>03728 <span class="comment">    }</span>
<a name="l03729"></a>03729 <span class="comment">  }</span>
<a name="l03730"></a>03730 <span class="comment">  */</span>
<a name="l03731"></a>03731 
<a name="l03732"></a>03732   thrpool-&gt;reset();
<a name="l03733"></a>03733   perfs = <span class="keyword">new</span> eyedblib::ThreadPerformer*[perf_cnt];
<a name="l03734"></a>03734 
<a name="l03735"></a>03735   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; perf_cnt; n++) {
<a name="l03736"></a>03736     perfs[n] = thrpool-&gt;start(cursor_perform_wrapper, perf_curs[n]);
<a name="l03737"></a>03737   }
<a name="l03738"></a>03738 
<a name="l03739"></a>03739 <span class="preprocessor">#ifdef NEW_WAIT</span>
<a name="l03740"></a>03740 <span class="preprocessor"></span>  perf_end_cnt = 0;
<a name="l03741"></a>03741 <span class="preprocessor">#endif</span>
<a name="l03742"></a>03742 <span class="preprocessor"></span>  <span class="keywordflow">return</span> True;
<a name="l03743"></a>03743 }
<a name="l03744"></a>03744 
<a name="l03745"></a>03745 <span class="keywordtype">void</span> HIdxCursor::init(DbHandle *dbh)
<a name="l03746"></a>03746 {
<a name="l03747"></a>03747   state = True;
<a name="l03748"></a>03748   master = False;
<a name="l03749"></a>03749   slave = False;
<a name="l03750"></a>03750 
<a name="l03751"></a>03751   sdata = 0;
<a name="l03752"></a>03752   memset(&amp;koid, 0, <span class="keyword">sizeof</span>(koid));
<a name="l03753"></a>03753   skey = ekey = 0;
<a name="l03754"></a>03754   sdata = 0;
<a name="l03755"></a>03755 
<a name="l03756"></a>03756   perf_cnt = 0;
<a name="l03757"></a>03757   perf_curs = 0;
<a name="l03758"></a>03758   perfs = 0;
<a name="l03759"></a>03759 <span class="preprocessor">#ifdef FORCE_COPY</span>
<a name="l03760"></a>03760 <span class="preprocessor"></span>  nocopy = False;
<a name="l03761"></a>03761 <span class="preprocessor">#else</span>
<a name="l03762"></a>03762 <span class="preprocessor"></span>  nocopy = isWholeMapped(dbh);
<a name="l03763"></a>03763 <span class="preprocessor">#endif</span>
<a name="l03764"></a>03764 <span class="preprocessor"></span>  data_tofree = False;
<a name="l03765"></a>03765 
<a name="l03766"></a>03766   datacnt = 0;
<a name="l03767"></a>03767   idata = 0;
<a name="l03768"></a>03768   jumpsize = 0;
<a name="l03769"></a>03769 }
<a name="l03770"></a>03770 
<a name="l03771"></a>03771 HIdxCursor::HIdxCursor(<span class="keyword">const</span> HIdx *_idx,
<a name="l03772"></a>03772                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _k_cur,
<a name="l03773"></a>03773                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _k_end,
<a name="l03774"></a>03774                              <span class="keyword">const</span> <span class="keywordtype">void</span> *_skey, <span class="keyword">const</span> <span class="keywordtype">void</span> *_ekey,
<a name="l03775"></a>03775                              Boolean _sexcl, Boolean _eexcl,
<a name="l03776"></a>03776                              Boolean (*_user_cmp)(<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *),
<a name="l03777"></a>03777                              <span class="keywordtype">void</span> *_cmp_arg,
<a name="l03778"></a>03778                              LinkList *_list) :
<a name="l03779"></a>03779   idx(_idx),
<a name="l03780"></a>03780   user_cmp(_user_cmp), cmp_arg(_cmp_arg),
<a name="l03781"></a>03781   k_cur(_k_cur), k_end(_k_end), list(_list),
<a name="l03782"></a>03782   sexcl(_sexcl), eexcl(_eexcl)
<a name="l03783"></a>03783 {
<a name="l03784"></a>03784   init(idx-&gt;dbh);
<a name="l03785"></a>03785   <span class="keywordflow">if</span> (idx-&gt;isDataVarSize()) {
<a name="l03786"></a>03786     <span class="comment">// cannot have data variable size and parallel mode</span>
<a name="l03787"></a>03787     state = False;
<a name="l03788"></a>03788     <span class="keywordflow">return</span>;
<a name="l03789"></a>03789   }
<a name="l03790"></a>03790   slave = True;
<a name="l03791"></a>03791   equal = False;
<a name="l03792"></a>03792   Boolean isstr = (STRTYPE(idx) ? True : False);
<a name="l03793"></a>03793   skey = HIdx::copy_key(_skey, idx-&gt;hidx.keysz, isstr, &amp;state);
<a name="l03794"></a>03794   ekey = HIdx::copy_key((_ekey == defaultSKey) ? _skey : _ekey, idx-&gt;hidx.keysz, isstr, &amp;state);
<a name="l03795"></a>03795   <span class="comment">//printf(&quot;k_cur %d -&gt; %d : %d\n&quot;, k_cur, k_end, idx-&gt;hidx.key_count);</span>
<a name="l03796"></a>03796 }
<a name="l03797"></a>03797 
<a name="l03798"></a>03798 HIdxCursor::HIdxCursor(<span class="keyword">const</span> HIdx *_idx,
<a name="l03799"></a>03799                              <span class="keyword">const</span> <span class="keywordtype">void</span> *_skey, <span class="keyword">const</span> <span class="keywordtype">void</span> *_ekey,
<a name="l03800"></a>03800                              Boolean _sexcl, Boolean _eexcl,
<a name="l03801"></a>03801                              Boolean (*_user_cmp)(<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *),
<a name="l03802"></a>03802                              <span class="keywordtype">void</span> *_cmp_arg,
<a name="l03803"></a>03803                              <span class="keywordtype">int</span> thread_cnt) :
<a name="l03804"></a>03804   idx(_idx), sexcl(_sexcl),
<a name="l03805"></a>03805   eexcl(_eexcl),
<a name="l03806"></a>03806   user_cmp(_user_cmp),
<a name="l03807"></a>03807   cmp_arg(_cmp_arg)
<a name="l03808"></a>03808 {
<a name="l03809"></a>03809   assert(!idx-&gt;status());
<a name="l03810"></a>03810   assert(idx-&gt;isOpened());
<a name="l03811"></a>03811 
<a name="l03812"></a>03812   init(idx-&gt;dbh);
<a name="l03813"></a>03813   list = 0;
<a name="l03814"></a>03814   lists = 0;
<a name="l03815"></a>03815 
<a name="l03816"></a>03816   Status s;
<a name="l03817"></a>03817   Boolean isstr = (STRTYPE(idx) ? True : False);
<a name="l03818"></a>03818   skey = HIdx::copy_key(_skey, idx-&gt;hidx.keysz, isstr, &amp;state);
<a name="l03819"></a>03819   ekey = HIdx::copy_key((_ekey == defaultSKey) ? _skey : _ekey, idx-&gt;hidx.keysz, isstr, &amp;state);
<a name="l03820"></a>03820 
<a name="l03821"></a>03821   <span class="keywordflow">if</span> (!state)
<a name="l03822"></a>03822     <span class="keywordflow">return</span>;
<a name="l03823"></a>03823 
<a name="l03824"></a>03824   <span class="keywordflow">if</span> (parallelInit(thread_cnt))
<a name="l03825"></a>03825     <span class="keywordflow">return</span>;
<a name="l03826"></a>03826 
<a name="l03827"></a>03827   <span class="keywordflow">if</span> (skey &amp;&amp; ekey &amp;&amp; !idx-&gt;cmp(skey, ekey, OPS_NOSWAP)) {
<a name="l03828"></a>03828     equal = True;
<a name="l03829"></a>03829     s = idx-&gt;get_key(k_cur, skey);
<a name="l03830"></a>03830     <span class="keywordflow">if</span> (s) state = False;
<a name="l03831"></a>03831   }
<a name="l03832"></a>03832   <span class="keywordflow">else</span> {
<a name="l03833"></a>03833     k_cur = 0;
<a name="l03834"></a>03834     equal = False;
<a name="l03835"></a>03835   }
<a name="l03836"></a>03836     
<a name="l03837"></a>03837   k_end = idx-&gt;hidx.key_count;
<a name="l03838"></a>03838 }
<a name="l03839"></a>03839 
<a name="l03840"></a>03840 <span class="preprocessor">#define NO_COPY</span>
<a name="l03841"></a>03841 <span class="preprocessor"></span>
<a name="l03842"></a>03842 Status
<a name="l03843"></a>03843 HIdxCursor::read(Boolean &amp;eox)
<a name="l03844"></a>03844 {
<a name="l03845"></a>03845   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 0;
<a name="l03846"></a>03846   Status s;
<a name="l03847"></a>03847   <span class="keywordtype">int</span> n;
<a name="l03848"></a>03848 
<a name="l03849"></a>03849   HIdx::CListObjHeader h;
<a name="l03850"></a>03850 
<a name="l03851"></a>03851   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(idx-&gt;version);
<a name="l03852"></a>03852   <span class="comment">//  printf(&quot;enter HIdxCursor::read()\n&quot;);</span>
<a name="l03853"></a>03853   <span class="keywordflow">for</span> (n = 0; ; n++) {
<a name="l03854"></a>03854     <span class="comment">/*</span>
<a name="l03855"></a>03855 <span class="comment">    printf(&quot;@%d koid = %s k_cur=%d, k_end=%d\n&quot;, pthread_self(),</span>
<a name="l03856"></a>03856 <span class="comment">           getOidString(&amp;koid), k_cur, k_end);</span>
<a name="l03857"></a>03857 <span class="comment">    */</span>
<a name="l03858"></a>03858     <span class="keywordflow">if</span> (backend_interrupt)
<a name="l03859"></a>03859       <span class="keywordflow">return</span> statusMake(BACKEND_INTERRUPTED, <span class="stringliteral">&quot;&quot;</span>);
<a name="l03860"></a>03860 
<a name="l03861"></a>03861     <span class="keywordflow">if</span> (koid.getNX() == 0) {
<a name="l03862"></a>03862       <span class="keywordflow">if</span> (k_cur &gt;= k_end) {
<a name="l03863"></a>03863         eox = True;
<a name="l03864"></a>03864         <span class="keywordflow">return</span> Success;
<a name="l03865"></a>03865       }
<a name="l03866"></a>03866 
<a name="l03867"></a>03867       HIdx::CListHeader chd;
<a name="l03868"></a>03868       s = idx-&gt;readCListHeader(k_cur, chd);
<a name="l03869"></a>03869       <span class="keywordflow">if</span> (s)
<a name="l03870"></a>03870         <span class="keywordflow">return</span> s;
<a name="l03871"></a>03871       koid = chd.clobj_first;
<a name="l03872"></a>03872 
<a name="l03873"></a>03873       <span class="keywordflow">if</span> (equal) {
<a name="l03874"></a>03874         <span class="keywordflow">if</span> (koid.getNX() == 0) {
<a name="l03875"></a>03875           eox = True;
<a name="l03876"></a>03876           <span class="keywordflow">return</span> Success;
<a name="l03877"></a>03877         }
<a name="l03878"></a>03878       }
<a name="l03879"></a>03879       <span class="keywordflow">else</span>
<a name="l03880"></a>03880         k_cur++;
<a name="l03881"></a>03881       
<a name="l03882"></a>03882       <span class="keywordflow">if</span> (koid.getNX() == 0)
<a name="l03883"></a>03883         <span class="keywordflow">continue</span>;
<a name="l03884"></a>03884     }     
<a name="l03885"></a>03885 
<a name="l03886"></a>03886     s = objectRead(idx-&gt;dbh, 0, <span class="keyword">sizeof</span>(HIdx::CListObjHeader), &amp;h,
<a name="l03887"></a>03887                    DefaultLock, 0, &amp;size, &amp;koid);
<a name="l03888"></a>03888     <span class="keywordflow">if</span> (s)
<a name="l03889"></a>03889       <span class="keywordflow">return</span> s;
<a name="l03890"></a>03890     x2h_header(&amp;h);
<a name="l03891"></a>03891     
<a name="l03892"></a>03892     <span class="keywordflow">if</span> (h.alloc_cnt)
<a name="l03893"></a>03893       <span class="keywordflow">break</span>;
<a name="l03894"></a>03894 
<a name="l03895"></a>03895     koid = h.clobj_next;
<a name="l03896"></a>03896     
<a name="l03897"></a>03897     <span class="keywordflow">if</span> (equal &amp;&amp; koid.getNX() == 0) {
<a name="l03898"></a>03898       eox = True;
<a name="l03899"></a>03899       <span class="keywordflow">return</span> Success;
<a name="l03900"></a>03900     }
<a name="l03901"></a>03901   }      
<a name="l03902"></a>03902 
<a name="l03903"></a>03903   eox = False;
<a name="l03904"></a>03904 
<a name="l03905"></a>03905   Boolean nocopy_failed = False;
<a name="l03906"></a>03906 
<a name="l03907"></a>03907   <span class="keywordflow">if</span> (data_tofree)
<a name="l03908"></a>03908     free(sdata);
<a name="l03909"></a>03909 
<a name="l03910"></a>03910   <span class="keywordflow">if</span> (nocopy) {
<a name="l03911"></a>03911     s =  objectReadNoCopy(idx-&gt;dbh, 0, size, &amp;sdata, DefaultLock, 0, 0,
<a name="l03912"></a>03912                              &amp;koid);
<a name="l03913"></a>03913     <span class="keywordflow">if</span> (!s) {
<a name="l03914"></a>03914       edata = sdata + size;
<a name="l03915"></a>03915       cur = sdata + <span class="keyword">sizeof</span>(HIdx::CListObjHeader);
<a name="l03916"></a>03916       data_tofree = False;
<a name="l03917"></a>03917     }
<a name="l03918"></a>03918     <span class="keywordflow">else</span> {
<a name="l03919"></a>03919       <span class="comment">//printf(&quot;nocopy failed for %s\n&quot;, getOidString(&amp;koid));</span>
<a name="l03920"></a>03920       nocopy_failed = True;
<a name="l03921"></a>03921     }
<a name="l03922"></a>03922   }
<a name="l03923"></a>03923 
<a name="l03924"></a>03924   <span class="keywordflow">if</span> (!nocopy || nocopy_failed) {
<a name="l03925"></a>03925     sdata = (<span class="keywordtype">char</span> *)m_malloc(size);
<a name="l03926"></a>03926     data_tofree = True;
<a name="l03927"></a>03927     edata = sdata + size;
<a name="l03928"></a>03928     cur = sdata + <span class="keyword">sizeof</span>(HIdx::CListObjHeader);
<a name="l03929"></a>03929     
<a name="l03930"></a>03930     s =  objectRead(idx-&gt;dbh, 0, size, sdata, DefaultLock, 0, 0, &amp;koid);
<a name="l03931"></a>03931   }
<a name="l03932"></a>03932 
<a name="l03933"></a>03933   koid = h.clobj_next;
<a name="l03934"></a>03934 
<a name="l03935"></a>03935   <span class="keywordflow">return</span> s;
<a name="l03936"></a>03936 }
<a name="l03937"></a>03937 
<a name="l03938"></a>03938 <span class="keywordtype">void</span> *HIdx::copy_key(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keysz, Boolean isstr, Boolean *state)
<a name="l03939"></a>03939 {
<a name="l03940"></a>03940   <span class="keywordflow">if</span> (state)
<a name="l03941"></a>03941     *state = True;
<a name="l03942"></a>03942 
<a name="l03943"></a>03943   <span class="keywordflow">if</span> (!key)
<a name="l03944"></a>03944     <span class="keywordflow">return</span> 0;
<a name="l03945"></a>03945 
<a name="l03946"></a>03946   <span class="keywordflow">if</span> (keysz == HIdx::VarSize)
<a name="l03947"></a>03947     <span class="keywordflow">return</span> strdup((<span class="keywordtype">char</span> *)key);
<a name="l03948"></a>03948 
<a name="l03949"></a>03949   <span class="keywordtype">char</span> *k = (<span class="keywordtype">char</span> *)m_malloc(keysz);
<a name="l03950"></a>03950   assert(k);
<a name="l03951"></a>03951 
<a name="l03952"></a>03952   <span class="keywordflow">if</span> (isstr) {
<a name="l03953"></a>03953     <span class="keywordtype">int</span> len = strlen((<span class="keywordtype">char</span> *)key)+1;
<a name="l03954"></a>03954 
<a name="l03955"></a>03955     <span class="keywordflow">if</span> (len &gt; keysz) { <span class="comment">// was if (len &gt;= keysz)</span>
<a name="l03956"></a>03956       <span class="keywordflow">if</span> (state)
<a name="l03957"></a>03957         *state = False;
<a name="l03958"></a>03958     }
<a name="l03959"></a>03959     <span class="keywordflow">else</span> {
<a name="l03960"></a>03960       memcpy(k, key, len);
<a name="l03961"></a>03961       memset(k+len, 0, keysz-len);
<a name="l03962"></a>03962     }
<a name="l03963"></a>03963   }
<a name="l03964"></a>03964   <span class="keywordflow">else</span>
<a name="l03965"></a>03965     memcpy(k, key, keysz);
<a name="l03966"></a>03966 
<a name="l03967"></a>03967   <span class="keywordflow">return</span> k;
<a name="l03968"></a>03968 }
<a name="l03969"></a>03969 
<a name="l03970"></a>03970 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l03971"></a>03971 HIdxCursor::cmp_realize(<span class="keyword">const</span> <span class="keywordtype">void</span> *xkey, <span class="keyword">const</span> <span class="keywordtype">void</span> *ykey,
<a name="l03972"></a>03972                            Boolean excl, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bswap)<span class="keyword"> const</span>
<a name="l03973"></a>03973 <span class="keyword"></span>{
<a name="l03974"></a>03974   <span class="keywordtype">int</span> c = idx-&gt;cmp(xkey, ykey, bswap);
<a name="l03975"></a>03975 
<a name="l03976"></a>03976   <span class="keywordflow">if</span> (c == 0) {
<a name="l03977"></a>03977     <span class="keywordflow">if</span> (excl)
<a name="l03978"></a>03978       <span class="keywordflow">return</span> 1;
<a name="l03979"></a>03979     <span class="keywordflow">return</span> 0;
<a name="l03980"></a>03980   }
<a name="l03981"></a>03981   
<a name="l03982"></a>03982   <span class="keywordflow">return</span> (c &gt; 0);
<a name="l03983"></a>03983 }
<a name="l03984"></a>03984 
<a name="l03985"></a>03985 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l03986"></a>03986 HIdxCursor::cmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *key)<span class="keyword"> const</span>
<a name="l03987"></a>03987 <span class="keyword"></span>{
<a name="l03988"></a>03988   <span class="keywordflow">if</span> (equal)
<a name="l03989"></a>03989     <span class="keywordflow">return</span> idx-&gt;cmp(skey, key, OP2_SWAP);
<a name="l03990"></a>03990 
<a name="l03991"></a>03991   <span class="keywordflow">if</span> (!skey &amp;&amp; !ekey)
<a name="l03992"></a>03992     <span class="keywordflow">return</span> 0;
<a name="l03993"></a>03993 
<a name="l03994"></a>03994   <span class="keywordflow">if</span> (skey &amp;&amp; ekey)
<a name="l03995"></a>03995     <span class="keywordflow">return</span> cmp_realize(skey, key, sexcl, OP2_SWAP) ||
<a name="l03996"></a>03996       cmp_realize(key, ekey, eexcl, OP1_SWAP);
<a name="l03997"></a>03997 
<a name="l03998"></a>03998   <span class="keywordflow">if</span> (skey)
<a name="l03999"></a>03999     <span class="keywordflow">return</span> cmp_realize(skey, key, sexcl, OP2_SWAP);
<a name="l04000"></a>04000 
<a name="l04001"></a>04001   <span class="keywordflow">if</span> (ekey)
<a name="l04002"></a>04002     <span class="keywordflow">return</span> cmp_realize(key, ekey, eexcl, OP1_SWAP);
<a name="l04003"></a>04003 
<a name="l04004"></a>04004   abort();
<a name="l04005"></a>04005   <span class="keywordflow">return</span> 1;
<a name="l04006"></a>04006 }
<a name="l04007"></a>04007 
<a name="l04008"></a>04008 <span class="keywordtype">void</span> HIdxCursor::append_next(<span class="keywordtype">void</span> *data, Idx::Key *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n, DataBuffer *dataBuffer)
<a name="l04009"></a>04009 {
<a name="l04010"></a>04010   <span class="keywordtype">int</span> off = get_off(cur, idx);
<a name="l04011"></a>04011 
<a name="l04012"></a>04012   Link *l;
<a name="l04013"></a>04013   <span class="keywordflow">if</span> (slave) {
<a name="l04014"></a>04014     l = <span class="keyword">new</span> Link(idx-&gt;hidx.datasz);
<a name="l04015"></a>04015     data = l-&gt;data;
<a name="l04016"></a>04016     key = &amp;l-&gt;key;
<a name="l04017"></a>04017   }
<a name="l04018"></a>04018   <span class="keywordflow">else</span> {
<a name="l04019"></a>04019     l = 0;
<a name="l04020"></a>04020   }
<a name="l04021"></a>04021 
<a name="l04022"></a>04022   <span class="keywordflow">if</span> (data || dataBuffer) {
<a name="l04023"></a>04023     <span class="keywordflow">if</span> (idx-&gt;isDataGroupedByKey()) {
<a name="l04024"></a>04024       <span class="keywordflow">if</span> (dataBuffer) {
<a name="l04025"></a>04025         dataBuffer-&gt;setData(cur + off + data_group_sz(n, idx), idx-&gt;hidx.datasz);
<a name="l04026"></a>04026       }
<a name="l04027"></a>04027       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (data) {
<a name="l04028"></a>04028         memcpy(data, cur + off + data_group_sz(n, idx), idx-&gt;hidx.datasz);
<a name="l04029"></a>04029       }
<a name="l04030"></a>04030     }
<a name="l04031"></a>04031     <span class="keywordflow">else</span> {
<a name="l04032"></a>04032       <span class="keywordflow">if</span> (idx-&gt;isDataVarSize()) {
<a name="l04033"></a>04033         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xdatasz, datasz;
<a name="l04034"></a>04034 
<a name="l04035"></a>04035         memcpy(&amp;xdatasz, cur + off, DATASZ_SIZE);
<a name="l04036"></a>04036         datasz = x2h_u32(xdatasz);
<a name="l04037"></a>04037 
<a name="l04038"></a>04038         <span class="keywordflow">if</span> (dataBuffer) {
<a name="l04039"></a>04039           dataBuffer-&gt;setData(cur + off + DATASZ_SIZE, datasz);
<a name="l04040"></a>04040         }
<a name="l04041"></a>04041         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (data) {
<a name="l04042"></a>04042           memcpy(data, cur + off + DATASZ_SIZE, datasz);
<a name="l04043"></a>04043         }
<a name="l04044"></a>04044       }
<a name="l04045"></a>04045       <span class="keywordflow">else</span> {
<a name="l04046"></a>04046         <span class="keywordflow">if</span> (dataBuffer) {
<a name="l04047"></a>04047           dataBuffer-&gt;setData(cur + off, idx-&gt;hidx.datasz);
<a name="l04048"></a>04048         }
<a name="l04049"></a>04049         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (data) {
<a name="l04050"></a>04050           memcpy(data, cur + off, idx-&gt;hidx.datasz);
<a name="l04051"></a>04051         }
<a name="l04052"></a>04052       }
<a name="l04053"></a>04053     }
<a name="l04054"></a>04054   }
<a name="l04055"></a>04055         
<a name="l04056"></a>04056   <span class="keywordflow">if</span> (key) {
<a name="l04057"></a>04057     key-&gt;setKey(cur, (idx-&gt;hidx.keysz != HIdx::VarSize ?
<a name="l04058"></a>04058                       idx-&gt;hidx.keysz : strlen(cur) + 1),
<a name="l04059"></a>04059                 idx-&gt;keytype);
<a name="l04060"></a>04060   }
<a name="l04061"></a>04061   
<a name="l04062"></a>04062   <span class="keywordflow">if</span> (slave) {
<a name="l04063"></a>04063     list-&gt;insert(l);
<a name="l04064"></a>04064   }
<a name="l04065"></a>04065 }
<a name="l04066"></a>04066 
<a name="l04067"></a><a class="code" href="classeyedbsm_1_1HIdxCursor.html#a83be97989c6246ffc3e49a7147a29427">04067</a> Status HIdxCursor::next(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *found_cnt, Idx::Key *key)
<a name="l04068"></a>04068 {
<a name="l04069"></a>04069   <span class="keywordflow">if</span> (!idx-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a6edcbff89fe6e741ea297618b6cba094" title="Not yet documented.">isDataGroupedByKey</a>()) {
<a name="l04070"></a>04070     *found_cnt = 0;
<a name="l04071"></a>04071     <span class="comment">// for now</span>
<a name="l04072"></a>04072     <span class="keywordflow">return</span> statusMake(ERROR, <span class="stringliteral">&quot;cannot use this type of cursor on non data_grouped_by_key hash index&quot;</span>);
<a name="l04073"></a>04073   }
<a name="l04074"></a>04074 
<a name="l04075"></a>04075   Boolean found;
<a name="l04076"></a>04076   <span class="keywordflow">return</span> next(&amp;found, found_cnt, 0, key, 0);
<a name="l04077"></a>04077 }
<a name="l04078"></a>04078 
<a name="l04079"></a><a class="code" href="classeyedbsm_1_1HIdxCursor.html#af75009752b3325f259d35d0201620daf">04079</a> Status HIdxCursor::next(Boolean *found, <span class="keywordtype">void</span> *data, Idx::Key *key)
<a name="l04080"></a>04080 {
<a name="l04081"></a>04081   <span class="keywordflow">return</span> next(found, 0, data, key, 0);
<a name="l04082"></a>04082 }
<a name="l04083"></a>04083 
<a name="l04084"></a><a class="code" href="classeyedbsm_1_1HIdxCursor.html#ae5a6c26aaf49f178cc624f32e86473e2">04084</a> Status HIdxCursor::next(Boolean *found, DataBuffer &amp;dataBuffer, Idx::Key *key)
<a name="l04085"></a>04085 {
<a name="l04086"></a>04086   <span class="keywordflow">return</span> next(found, 0, 0, key, &amp;dataBuffer);
<a name="l04087"></a>04087 }
<a name="l04088"></a>04088 
<a name="l04089"></a>04089 Status
<a name="l04090"></a>04090 HIdxCursor::next(Boolean *found, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *found_cnt, <span class="keywordtype">void</span> *data, Idx::Key *key, DataBuffer *dataBuffer)
<a name="l04091"></a>04091 {
<a name="l04092"></a>04092   <span class="keywordflow">if</span> (!state) {
<a name="l04093"></a>04093     <span class="keywordflow">if</span> (found_cnt)
<a name="l04094"></a>04094       *found_cnt = 0;
<a name="l04095"></a>04095     *found = False;
<a name="l04096"></a>04096     <span class="keywordflow">return</span> Success;
<a name="l04097"></a>04097   }
<a name="l04098"></a>04098 
<a name="l04099"></a>04099   <span class="keywordflow">if</span> (master) {
<a name="l04100"></a>04100     <span class="keywordflow">for</span> (;;) {
<a name="l04101"></a>04101       LinkList *tlist;
<a name="l04102"></a>04102 <span class="preprocessor">#ifdef MULTI_LIST</span>
<a name="l04103"></a>04103 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; perf_cnt; n++) {
<a name="l04104"></a>04104         tlist = lists[n];
<a name="l04105"></a>04105 <span class="preprocessor">#else</span>
<a name="l04106"></a>04106 <span class="preprocessor"></span>        tlist = list;
<a name="l04107"></a>04107 <span class="preprocessor">#endif</span>
<a name="l04108"></a>04108 <span class="preprocessor"></span>        Link *l = tlist-&gt;peek();
<a name="l04109"></a>04109         <span class="keywordflow">if</span> (l) {
<a name="l04110"></a>04110           <span class="keywordflow">if</span> (dataBuffer) {
<a name="l04111"></a>04111             dataBuffer-&gt;setData(l-&gt;data, idx-&gt;hidx.datasz);
<a name="l04112"></a>04112           }
<a name="l04113"></a>04113           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (data) {
<a name="l04114"></a>04114             memcpy(data, l-&gt;data, idx-&gt;hidx.datasz);
<a name="l04115"></a>04115           }
<a name="l04116"></a>04116 
<a name="l04117"></a>04117           <span class="keywordflow">if</span> (key) {
<a name="l04118"></a>04118             key-&gt;setKey(l-&gt;key.getKey(), l-&gt;key.getSize(), idx-&gt;keytype);
<a name="l04119"></a>04119           }
<a name="l04120"></a>04120 
<a name="l04121"></a>04121           <span class="keyword">delete</span> l;
<a name="l04122"></a>04122           *found = True;
<a name="l04123"></a>04123           <span class="keywordflow">return</span> Success;
<a name="l04124"></a>04124         }
<a name="l04125"></a>04125 <span class="preprocessor">#ifdef MULTI_LIST</span>
<a name="l04126"></a>04126 <span class="preprocessor"></span>      }
<a name="l04127"></a>04127 <span class="preprocessor">#endif</span>
<a name="l04128"></a>04128 <span class="preprocessor"></span>
<a name="l04129"></a>04129 <span class="preprocessor">#ifdef NEW_WAIT</span>
<a name="l04130"></a>04130 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (perf_end_cnt == perf_cnt) {
<a name="l04131"></a>04131         thrpool-&gt;waitAll();
<a name="l04132"></a>04132         <span class="keywordflow">if</span> (found_cnt)
<a name="l04133"></a>04133           *found_cnt = 0;
<a name="l04134"></a>04134         *found = False;
<a name="l04135"></a>04135         <span class="keywordflow">return</span> Success;
<a name="l04136"></a>04136       }
<a name="l04137"></a>04137 
<a name="l04138"></a>04138       eyedblib::ThreadPerformer *perf;
<a name="l04139"></a>04139       eyedblib::ThreadPerformerArg arg = thrpool-&gt;wait(perf);
<a name="l04140"></a>04140       <span class="keywordflow">if</span> (arg.data) {
<a name="l04141"></a>04141         thrpool-&gt;waitAll(); <span class="comment">// should advert thread to stop immediately !</span>
<a name="l04142"></a>04142         <span class="keywordflow">return</span> (Status)arg.data;
<a name="l04143"></a>04143       }
<a name="l04144"></a>04144 
<a name="l04145"></a>04145       perf_end_cnt++;
<a name="l04146"></a>04146 <span class="preprocessor">#else</span>
<a name="l04147"></a>04147 <span class="preprocessor"></span>      <span class="keywordtype">int</span> n;
<a name="l04148"></a>04148       <span class="keywordflow">for</span> (n = 0; n &lt; perf_cnt; n++) {
<a name="l04149"></a>04149         <span class="keywordflow">if</span> (!perfs[n]-&gt;isIdle())
<a name="l04150"></a>04150           <span class="keywordflow">break</span>;
<a name="l04151"></a>04151       }
<a name="l04152"></a>04152 
<a name="l04153"></a>04153       <span class="keywordtype">bool</span> cond = (n == perf_cnt);
<a name="l04154"></a>04154       <span class="keywordflow">if</span> (!cond) { <span class="comment">// at least one is still running</span>
<a name="l04155"></a>04155         eyedblib::ThreadPerformer *perf;
<a name="l04156"></a>04156         eyedblib::ThreadPerformerArg arg = thrpool-&gt;wait(perf);
<a name="l04157"></a>04157         <span class="keywordflow">if</span> (arg.data) {
<a name="l04158"></a>04158           thrpool-&gt;waitAll(); <span class="comment">// should advert thread to stop immediately !</span>
<a name="l04159"></a>04159           <span class="keywordflow">return</span> (Status)arg.data;
<a name="l04160"></a>04160         }
<a name="l04161"></a>04161       }
<a name="l04162"></a>04162       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cond) { <span class="comment">// all performers have finished</span>
<a name="l04163"></a>04163         thrpool-&gt;waitAll();
<a name="l04164"></a>04164         <span class="keywordflow">if</span> (found_cnt)
<a name="l04165"></a>04165           *found_cnt = 0;
<a name="l04166"></a>04166         *found = False;
<a name="l04167"></a>04167         <span class="keywordflow">return</span> Success;
<a name="l04168"></a>04168       }
<a name="l04169"></a>04169 <span class="preprocessor">#endif</span>
<a name="l04170"></a>04170 <span class="preprocessor"></span>    }
<a name="l04171"></a>04171   }
<a name="l04172"></a>04172 
<a name="l04173"></a>04173   <span class="keywordflow">if</span> (!sdata) {
<a name="l04174"></a>04174     Boolean eox;
<a name="l04175"></a>04175     Status s = read(eox);
<a name="l04176"></a>04176     <span class="keywordflow">if</span> (s)
<a name="l04177"></a>04177       <span class="keywordflow">return</span> s;
<a name="l04178"></a>04178     
<a name="l04179"></a>04179     <span class="keywordflow">if</span> (eox) {
<a name="l04180"></a>04180       <span class="keywordflow">if</span> (found_cnt)
<a name="l04181"></a>04181         *found_cnt = 0;
<a name="l04182"></a>04182       *found = False;
<a name="l04183"></a>04183       <span class="keywordflow">return</span> Success;
<a name="l04184"></a>04184     }
<a name="l04185"></a>04185   }
<a name="l04186"></a>04186 
<a name="l04187"></a>04187   <span class="keywordflow">if</span> (found_cnt) {
<a name="l04188"></a>04188     cur += jumpsize;
<a name="l04189"></a>04189     datacnt = 0;
<a name="l04190"></a>04190     jumpsize = 0;
<a name="l04191"></a>04191   }
<a name="l04192"></a>04192   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (++idata &lt; datacnt) {
<a name="l04193"></a>04193 <span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l04194"></a>04194 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;...CURSOR DATACNT %d idata=%d\n&quot;</span>, datacnt, idata);
<a name="l04195"></a>04195 <span class="preprocessor">#endif</span>
<a name="l04196"></a>04196 <span class="preprocessor"></span>    *found = True;
<a name="l04197"></a>04197     append_next(data, key, idata, dataBuffer);
<a name="l04198"></a>04198     <span class="keywordflow">return</span> Success;
<a name="l04199"></a>04199   }
<a name="l04200"></a>04200   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (datacnt) {
<a name="l04201"></a>04201 <span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l04202"></a>04202 <span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;...CURSOR jumping\n&quot;</span>);
<a name="l04203"></a>04203 <span class="preprocessor">#endif</span>
<a name="l04204"></a>04204 <span class="preprocessor"></span>    cur += jumpsize;
<a name="l04205"></a>04205     datacnt = 0;
<a name="l04206"></a>04206     jumpsize = 0;
<a name="l04207"></a>04207   }
<a name="l04208"></a>04208 
<a name="l04209"></a>04209   <span class="keywordflow">for</span> (;;) {
<a name="l04210"></a>04210     <span class="comment">// changed the 8/12/99</span>
<a name="l04211"></a>04211     <span class="comment">// for (; cur &lt; edata; )</span>
<a name="l04212"></a>04212     <span class="keywordflow">for</span> (; cur+<span class="keyword">sizeof</span>(HIdx::CellHeader) &lt;= edata; ) {
<a name="l04213"></a>04213       <span class="keywordflow">if</span> (backend_interrupt)
<a name="l04214"></a>04214         <span class="keywordflow">return</span> statusMake(BACKEND_INTERRUPTED, <span class="stringliteral">&quot;&quot;</span>);
<a name="l04215"></a>04215       HIdx::CellHeader o;
<a name="l04216"></a>04216       mcp(&amp;o, cur, <span class="keyword">sizeof</span>(HIdx::CellHeader));
<a name="l04217"></a>04217       x2h_overhead(&amp;o);
<a name="l04218"></a>04218       cur += <span class="keyword">sizeof</span>(HIdx::CellHeader);
<a name="l04219"></a>04219           
<a name="l04220"></a>04220       <span class="keywordflow">if</span> (!o.free &amp;&amp; !cmp(cur)) {
<a name="l04221"></a>04221         <span class="keywordflow">if</span> (idx-&gt;precmp) {
<a name="l04222"></a>04222           <span class="keywordtype">int</span> r;
<a name="l04223"></a>04223           <span class="keywordtype">void</span> <span class="keyword">const</span> * sk = skey ? skey : ekey;
<a name="l04224"></a>04224           <span class="keywordflow">if</span> (sk &amp;&amp; idx-&gt;precmp(sk, cur, &amp;idx-&gt;keytype, r)) {
<a name="l04225"></a>04225             <span class="comment">//printf(&quot;skipping entry\n&quot;);</span>
<a name="l04226"></a>04226             <span class="keywordflow">if</span> (!skey) {
<a name="l04227"></a>04227               cur += o.size; <span class="comment">// 23/12/01: was not test with this statement</span>
<a name="l04228"></a>04228               <span class="keywordflow">continue</span>;
<a name="l04229"></a>04229             }
<a name="l04230"></a>04230 
<a name="l04231"></a>04231             <span class="keywordflow">if</span> (found_cnt)
<a name="l04232"></a>04232               *found_cnt = 0;
<a name="l04233"></a>04233             *found = False;
<a name="l04234"></a>04234             <span class="keywordflow">return</span> Success;
<a name="l04235"></a>04235           }
<a name="l04236"></a>04236         }
<a name="l04237"></a>04237         
<a name="l04238"></a>04238         <span class="keywordflow">if</span> (user_cmp &amp;&amp; !user_cmp(cur, cmp_arg)) {
<a name="l04239"></a>04239           cur += o.size;
<a name="l04240"></a>04240           <span class="keywordflow">continue</span>;
<a name="l04241"></a>04241         }
<a name="l04242"></a>04242 
<a name="l04243"></a>04243         <span class="keywordflow">if</span> (idx-&gt;isDataGroupedByKey()) {
<a name="l04244"></a>04244 <span class="preprocessor">#ifdef VARSZ_DATACNT</span>
<a name="l04245"></a>04245 <span class="preprocessor"></span>          Status s = idx-&gt;x2h_datacnt_cpy(&amp;datacnt, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(cur + get_off(cur, idx)));
<a name="l04246"></a>04246           <span class="keywordflow">if</span> (s)
<a name="l04247"></a>04247             <span class="keywordflow">return</span> s;
<a name="l04248"></a>04248 <span class="preprocessor">#else</span>
<a name="l04249"></a>04249 <span class="preprocessor"></span>          x2h_32_cpy(&amp;datacnt, cur + get_off(cur, idx));
<a name="l04250"></a>04250 <span class="preprocessor">#endif</span>
<a name="l04251"></a>04251 <span class="preprocessor"></span>          idata = 0;
<a name="l04252"></a>04252 <span class="preprocessor">#ifdef TRACE_DGK</span>
<a name="l04253"></a>04253 <span class="preprocessor"></span>          printf(<span class="stringliteral">&quot;CURSOR DATACNT %d idata=%d\n&quot;</span>, datacnt, idata);
<a name="l04254"></a>04254 <span class="preprocessor">#endif</span>
<a name="l04255"></a>04255 <span class="preprocessor"></span>          jumpsize = o.size;
<a name="l04256"></a>04256         }
<a name="l04257"></a>04257         <span class="keywordflow">else</span>
<a name="l04258"></a>04258           datacnt = 1;
<a name="l04259"></a>04259 
<a name="l04260"></a>04260         <span class="keywordflow">if</span> (found_cnt)
<a name="l04261"></a>04261           *found_cnt = datacnt;
<a name="l04262"></a>04262 
<a name="l04263"></a>04263         *found = True;
<a name="l04264"></a>04264         append_next(data, key, 0, dataBuffer);
<a name="l04265"></a>04265 
<a name="l04266"></a>04266         <span class="keywordflow">if</span> (!idx-&gt;isDataGroupedByKey())
<a name="l04267"></a>04267           cur += o.size;
<a name="l04268"></a>04268         <span class="keywordflow">return</span> Success;
<a name="l04269"></a>04269       }
<a name="l04270"></a>04270           
<a name="l04271"></a>04271       cur += o.size;
<a name="l04272"></a>04272     }
<a name="l04273"></a>04273       
<a name="l04274"></a>04274     <span class="keywordflow">if</span> (equal &amp;&amp; !koid.getNX()) {
<a name="l04275"></a>04275       <span class="keywordflow">if</span> (found_cnt)
<a name="l04276"></a>04276         *found_cnt = 0;
<a name="l04277"></a>04277       *found = False;
<a name="l04278"></a>04278       state = False;
<a name="l04279"></a>04279       <span class="keywordflow">return</span> Success;
<a name="l04280"></a>04280     }
<a name="l04281"></a>04281 
<a name="l04282"></a>04282     Boolean eox;
<a name="l04283"></a>04283     Status s = read(eox);
<a name="l04284"></a>04284           
<a name="l04285"></a>04285     <span class="keywordflow">if</span> (s)
<a name="l04286"></a>04286       <span class="keywordflow">return</span> s;
<a name="l04287"></a>04287 
<a name="l04288"></a>04288     <span class="keywordflow">if</span> (eox) {
<a name="l04289"></a>04289       <span class="keywordflow">if</span> (found_cnt)
<a name="l04290"></a>04290         *found_cnt = 0;
<a name="l04291"></a>04291       *found = False;
<a name="l04292"></a>04292       state = False;
<a name="l04293"></a>04293       <span class="keywordflow">return</span> Success;
<a name="l04294"></a>04294     }
<a name="l04295"></a>04295   }
<a name="l04296"></a>04296 }
<a name="l04297"></a>04297 
<a name="l04298"></a>04298 HIdxCursor::~HIdxCursor()
<a name="l04299"></a>04299 {
<a name="l04300"></a>04300   free(skey);
<a name="l04301"></a>04301   free(ekey);
<a name="l04302"></a>04302   <span class="keywordflow">if</span> (data_tofree)
<a name="l04303"></a>04303     free(sdata);
<a name="l04304"></a>04304   <span class="keyword">delete</span> [] perf_curs;
<a name="l04305"></a>04305   <span class="keyword">delete</span> [] perfs;
<a name="l04306"></a>04306 <span class="preprocessor">#ifdef MULTI_LIST</span>
<a name="l04307"></a>04307 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (lists) {
<a name="l04308"></a>04308     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; perf_cnt; n++)
<a name="l04309"></a>04309       <span class="keyword">delete</span> lists[n];
<a name="l04310"></a>04310     <span class="keyword">delete</span> lists;
<a name="l04311"></a>04311   }
<a name="l04312"></a>04312 <span class="preprocessor">#else</span>
<a name="l04313"></a>04313 <span class="preprocessor"></span>  <span class="keyword">delete</span> list;
<a name="l04314"></a>04314 <span class="preprocessor">#endif</span>
<a name="l04315"></a>04315 <span class="preprocessor"></span>}
<a name="l04316"></a>04316 
<a name="l04317"></a>04317 Status
<a name="l04318"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a328cc50cf1e6ab2148dba572d60a90b8">04318</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a328cc50cf1e6ab2148dba572d60a90b8" title="Not yet documented.">HIdx::getStats</a>(std::string &amp;stats)<span class="keyword"> const</span>
<a name="l04319"></a>04319 <span class="keyword"></span>{
<a name="l04320"></a>04320   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total;
<a name="l04321"></a>04321   <span class="keywordtype">int</span> n;
<a name="l04322"></a>04322 
<a name="l04323"></a>04323   stats  = std::string(<span class="stringliteral">&quot;  Index type: &apos;hash&apos;\n&quot;</span>);
<a name="l04324"></a>04324 
<a name="l04325"></a>04325   stats += std::string(<span class="stringliteral">&quot;  Key count: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)hidx.key_count) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04326"></a>04326   stats += std::string(<span class="stringliteral">&quot;  Magnitude Order: &quot;</span>) + str_convert((<span class="keywordtype">int</span>)hidx.mag_order) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04327"></a>04327   stats += std::string(<span class="stringliteral">&quot;  Key Type: &quot;</span>) + typeString((Type)hidx.keytype) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04328"></a>04328   stats += std::string(<span class="stringliteral">&quot;  Implementation Hints:\n&quot;</span>);
<a name="l04329"></a>04329   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; HIdxImplHintsCount; i++)
<a name="l04330"></a>04330     stats += std::string(<span class="stringliteral">&quot;    &quot;</span>) + implHintsStr(i) + <span class="stringliteral">&quot;: &quot;</span> +
<a name="l04331"></a>04331       str_convert((<span class="keywordtype">int</span>)hidx.impl_hints[i]) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04332"></a>04332   stats += std::string(<span class="stringliteral">&quot;  Dataspace ID: &quot;</span>) + str_convert((<span class="keywordtype">int</span>)(hidx.dspid == DefaultDspid ? -1 : hidx.dspid)) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04333"></a>04333   stats += std::string(<span class="stringliteral">&quot;  Data Size: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)hidx.datasz) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04334"></a>04334   stats += std::string(<span class="stringliteral">&quot;  Key Size: &quot;</span>) + str_convert((<span class="keywordtype">int</span>)hidx.keysz) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04335"></a>04335   stats += std::string(<span class="stringliteral">&quot;  Magnitude Order: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)hidx.mag_order) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04336"></a>04336 
<a name="l04337"></a>04337   total = 0;
<a name="l04338"></a>04338   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_objs = 0;
<a name="l04339"></a>04339   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max = 0;
<a name="l04340"></a>04340   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min = ~0;
<a name="l04341"></a>04341   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> free = 0, busy = 0;
<a name="l04342"></a>04342 
<a name="l04343"></a>04343   <span class="keywordflow">for</span> (n = 0; n &lt; hidx.key_count; n++) {
<a name="l04344"></a>04344     CListHeader chd;
<a name="l04345"></a>04345     Status s = readCListHeader(n, chd);
<a name="l04346"></a>04346     <span class="keywordflow">if</span> (s)
<a name="l04347"></a>04347       <span class="keywordflow">return</span> s;
<a name="l04348"></a>04348 
<a name="l04349"></a>04349     Oid toid;
<a name="l04350"></a>04350     toid = chd.clobj_first;
<a name="l04351"></a>04351     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_count = 0;
<a name="l04352"></a>04352     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nobjs = 0;
<a name="l04353"></a>04353     <span class="keywordflow">while</span> (toid.getNX() &gt; 0) {
<a name="l04354"></a>04354       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count;
<a name="l04355"></a>04355       <span class="keywordflow">if</span> (backend_interrupt)
<a name="l04356"></a>04356         <span class="keywordflow">return</span> statusMake(BACKEND_INTERRUPTED, <span class="stringliteral">&quot;&quot;</span>);
<a name="l04357"></a>04357 
<a name="l04358"></a>04358       s = getEntryCount(&amp;toid, count);
<a name="l04359"></a>04359       <span class="keywordflow">if</span> (s)
<a name="l04360"></a>04360         <span class="keywordflow">return</span> s;
<a name="l04361"></a>04361 
<a name="l04362"></a>04362       cell_count += count;
<a name="l04363"></a>04363       nobjs++;
<a name="l04364"></a>04364     }
<a name="l04365"></a>04365 
<a name="l04366"></a>04366     total_objs += nobjs;
<a name="l04367"></a>04367 
<a name="l04368"></a>04368     <span class="keywordflow">if</span> (cell_count &gt; max)
<a name="l04369"></a>04369       max = cell_count;
<a name="l04370"></a>04370     <span class="keywordflow">if</span> (cell_count &lt; min)
<a name="l04371"></a>04371       min = cell_count;
<a name="l04372"></a>04372 
<a name="l04373"></a>04373     <span class="keywordflow">if</span> (cell_count) {
<a name="l04374"></a>04374       busy++;
<a name="l04375"></a>04375       stats += std::string(<span class="stringliteral">&quot;  Cell #&quot;</span>) + str_convert(n) + <span class="stringliteral">&quot;: &quot;</span> + str_convert((<span class="keywordtype">long</span>)cell_count) + <span class="stringliteral">&quot; object&quot;</span> + (cell_count != 1 ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) + <span class="stringliteral">&quot;, &quot;</span> + str_convert((<span class="keywordtype">long</span>)nobjs) + <span class="stringliteral">&quot; hash object&quot;</span> + (nobjs != 1 ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04376"></a>04376       total += cell_count;
<a name="l04377"></a>04377     }
<a name="l04378"></a>04378     <span class="keywordflow">else</span>
<a name="l04379"></a>04379       free++;
<a name="l04380"></a>04380   }
<a name="l04381"></a>04381 
<a name="l04382"></a>04382   stats += std::string(<span class="stringliteral">&quot;  Total object count: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)total) +
<a name="l04383"></a>04383     <span class="stringliteral">&quot; {computed: &quot;</span> + str_convert((<span class="keywordtype">long</span>)<a class="code" href="classeyedbsm_1_1HIdx.html#a4a1776668092d49a37a337cc92523e0f" title="Not yet documented.">getCount</a>()) + <span class="stringliteral">&quot;}\n&quot;</span>;
<a name="l04384"></a>04384   stats += std::string(<span class="stringliteral">&quot;  Min object per entry: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)min) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04385"></a>04385   stats += std::string(<span class="stringliteral">&quot;  Max entries per entry: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)max) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04386"></a>04386   stats += std::string(<span class="stringliteral">&quot;  Free entry count: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)free) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04387"></a>04387   stats += std::string(<span class="stringliteral">&quot;  Busy entry count: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)busy) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04388"></a>04388   stats += std::string(<span class="stringliteral">&quot;  Total hash object count: 1+&quot;</span>) +
<a name="l04389"></a>04389     str_convert((<span class="keywordtype">long</span>)total_objs) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04390"></a>04390   <span class="keywordflow">return</span> Success;
<a name="l04391"></a>04391 }
<a name="l04392"></a>04392 
<a name="l04393"></a>04393 Status
<a name="l04394"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a482f1746cf9f7abcc47052eae6320809">04394</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a328cc50cf1e6ab2148dba572d60a90b8" title="Not yet documented.">HIdx::getStats</a>(HIdx::Stats &amp;stats)<span class="keyword"> const</span>
<a name="l04395"></a>04395 <span class="keyword"></span>{
<a name="l04396"></a>04396   memset(&amp;stats, 0, <span class="keyword">sizeof</span>(stats));
<a name="l04397"></a>04397   memcpy(&amp;stats.idx, &amp;hidx, <span class="keyword">sizeof</span>(hidx));
<a name="l04398"></a>04398 
<a name="l04399"></a>04399   <span class="keywordtype">unsigned</span> int (*gkey)(int) = get_gkey(version);
<a name="l04400"></a>04400   <span class="comment">// the tree object:</span>
<a name="l04401"></a>04401   stats.total_hash_object_count = 1;
<a name="l04402"></a>04402   stats.total_hash_object_size = <span class="keyword">sizeof</span>(CListHeader) * gkey(hidx.key_count);
<a name="l04403"></a>04403 
<a name="l04404"></a>04404   stats.entries = <span class="keyword">new</span> Stats::Entry[hidx.key_count];
<a name="l04405"></a>04405   memset(stats.entries, 0, <span class="keyword">sizeof</span>(Stats::Entry) * hidx.key_count);
<a name="l04406"></a>04406   stats.min_objects_per_entry = ~0;
<a name="l04407"></a>04407 
<a name="l04408"></a>04408   Stats::Entry *entry = stats.entries;
<a name="l04409"></a>04409   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; hidx.key_count; n++, entry++) {
<a name="l04410"></a>04410     CListHeader chd;
<a name="l04411"></a>04411     Status s = readCListHeader(n, chd);
<a name="l04412"></a>04412     <span class="keywordflow">if</span> (s)
<a name="l04413"></a>04413       <span class="keywordflow">return</span> s;
<a name="l04414"></a>04414 <span class="preprocessor">#if 1</span>
<a name="l04415"></a>04415 <span class="preprocessor"></span>    checkChain(&amp;chd, <span class="stringliteral">&quot;getStats&quot;</span>);
<a name="l04416"></a>04416 <span class="preprocessor">#endif</span>
<a name="l04417"></a>04417 <span class="preprocessor"></span>    Oid koid;
<a name="l04418"></a>04418     koid = chd.clobj_first;
<a name="l04419"></a>04419     <span class="keywordflow">while</span> (koid.getNX() &gt; 0) {
<a name="l04420"></a>04420       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count;
<a name="l04421"></a>04421       <span class="keywordflow">if</span> (backend_interrupt)
<a name="l04422"></a>04422         <span class="keywordflow">return</span> statusMake(BACKEND_INTERRUPTED, <span class="stringliteral">&quot;&quot;</span>);
<a name="l04423"></a>04423       
<a name="l04424"></a>04424       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, busysize;
<a name="l04425"></a>04425       s = objectSizeGet(dbh, &amp;size, DefaultLock, &amp;koid);
<a name="l04426"></a>04426       <span class="keywordflow">if</span> (s)
<a name="l04427"></a>04427         <span class="keywordflow">return</span> s;
<a name="l04428"></a>04428 
<a name="l04429"></a>04429       s = getHashObjectBusySize(&amp;koid, busysize, count, size);
<a name="l04430"></a>04430       <span class="keywordflow">if</span> (s)
<a name="l04431"></a>04431         <span class="keywordflow">return</span> s;
<a name="l04432"></a>04432 
<a name="l04433"></a>04433       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ncount;
<a name="l04434"></a>04434       s = getEntryCount(&amp;koid, ncount);
<a name="l04435"></a>04435       <span class="keywordflow">if</span> (s)
<a name="l04436"></a>04436         <span class="keywordflow">return</span> s;
<a name="l04437"></a>04437       
<a name="l04438"></a>04438       <span class="comment">/*</span>
<a name="l04439"></a>04439 <span class="comment">      if (ncount != count) {</span>
<a name="l04440"></a>04440 <span class="comment">        printf(&quot;HIdx: count differ %d %d\n&quot;, count, ncount);</span>
<a name="l04441"></a>04441 <span class="comment">      }</span>
<a name="l04442"></a>04442 <span class="comment">      else {</span>
<a name="l04443"></a>04443 <span class="comment">        printf(&quot;HIdx: count equal %d %d\n&quot;, count, ncount);</span>
<a name="l04444"></a>04444 <span class="comment">      }</span>
<a name="l04445"></a>04445 <span class="comment">      */</span>
<a name="l04446"></a>04446 
<a name="l04447"></a>04447       entry-&gt;object_count += count;
<a name="l04448"></a>04448       entry-&gt;hash_object_busy_size += busysize;
<a name="l04449"></a>04449       entry-&gt;hash_object_count++;
<a name="l04450"></a>04450       entry-&gt;hash_object_size += size;
<a name="l04451"></a>04451     }
<a name="l04452"></a>04452 
<a name="l04453"></a>04453     <span class="keywordflow">if</span> (entry-&gt;object_count &gt; stats.max_objects_per_entry)
<a name="l04454"></a>04454       stats.max_objects_per_entry = entry-&gt;object_count;
<a name="l04455"></a>04455     <span class="keywordflow">if</span> (entry-&gt;object_count &lt; stats.min_objects_per_entry)
<a name="l04456"></a>04456       stats.min_objects_per_entry = entry-&gt;object_count;
<a name="l04457"></a>04457 
<a name="l04458"></a>04458     stats.total_hash_object_count += entry-&gt;hash_object_count;
<a name="l04459"></a>04459     stats.total_hash_object_busy_size += entry-&gt;hash_object_busy_size;
<a name="l04460"></a>04460     stats.total_object_count += entry-&gt;object_count;
<a name="l04461"></a>04461     stats.total_hash_object_size += entry-&gt;hash_object_size;
<a name="l04462"></a>04462 
<a name="l04463"></a>04463     <span class="keywordflow">if</span> (entry-&gt;object_count)
<a name="l04464"></a>04464       stats.busy_key_count++;
<a name="l04465"></a>04465     <span class="keywordflow">else</span>
<a name="l04466"></a>04466       stats.free_key_count++;
<a name="l04467"></a>04467   }
<a name="l04468"></a>04468 
<a name="l04469"></a>04469   <span class="keywordflow">return</span> Success;
<a name="l04470"></a>04470 }
<a name="l04471"></a>04471 
<a name="l04472"></a>04472 HIdx::Stats::Stats()
<a name="l04473"></a>04473 {
<a name="l04474"></a>04474   entries = 0;
<a name="l04475"></a>04475 }
<a name="l04476"></a>04476 
<a name="l04477"></a>04477 std::string
<a name="l04478"></a>04478 HIdx::Stats::toString(Boolean full)<span class="keyword"> const</span>
<a name="l04479"></a>04479 <span class="keyword"></span>{
<a name="l04480"></a>04480   std::string s = idx.toString();
<a name="l04481"></a>04481   Entry *entry = entries;
<a name="l04482"></a>04482 
<a name="l04483"></a>04483   <span class="keywordflow">if</span> (full) {
<a name="l04484"></a>04484     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; idx.key_count; i++, entry++)
<a name="l04485"></a>04485       <span class="keywordflow">if</span> (entry-&gt;object_count) {
<a name="l04486"></a>04486         s += std::string(<span class="stringliteral">&quot;Entry #&quot;</span>) + str_convert((<span class="keywordtype">long</span>)i) + <span class="stringliteral">&quot; {\n&quot;</span>;
<a name="l04487"></a>04487         s += std::string(<span class="stringliteral">&quot;\tObject count: &quot;</span>) + str_convert((<span class="keywordtype">long</span>)entry-&gt;object_count) +
<a name="l04488"></a>04488           <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04489"></a>04489         s += std::string(<span class="stringliteral">&quot;\tObject size: &quot;</span>)  + 
<a name="l04490"></a>04490           str_convert((<span class="keywordtype">long</span>)entry-&gt;hash_object_busy_size) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04491"></a>04491         s += std::string(<span class="stringliteral">&quot;\tHash object count: &quot;</span>) +
<a name="l04492"></a>04492           str_convert((<span class="keywordtype">long</span>)entry-&gt;hash_object_count) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04493"></a>04493         s += std::string(<span class="stringliteral">&quot;\tHash object size: &quot;</span>)  + 
<a name="l04494"></a>04494           str_convert((<span class="keywordtype">long</span>)entry-&gt;hash_object_size) + <span class="stringliteral">&quot;b\n}\n&quot;</span>;
<a name="l04495"></a>04495       }
<a name="l04496"></a>04496 
<a name="l04497"></a>04497     s += <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04498"></a>04498   }
<a name="l04499"></a>04499 
<a name="l04500"></a>04500   s += std::string(<span class="stringliteral">&quot;Min objects per entry: &quot;</span>) +
<a name="l04501"></a>04501     str_convert((<span class="keywordtype">long</span>)min_objects_per_entry) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04502"></a>04502   s += std::string(<span class="stringliteral">&quot;Max objects per entry: &quot;</span>) +
<a name="l04503"></a>04503     str_convert((<span class="keywordtype">long</span>)max_objects_per_entry) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04504"></a>04504   s += std::string(<span class="stringliteral">&quot;Total object count: &quot;</span>) +
<a name="l04505"></a>04505     str_convert((<span class="keywordtype">long</span>)total_object_count) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04506"></a>04506   s += std::string(<span class="stringliteral">&quot;Total object size: &quot;</span>) +
<a name="l04507"></a>04507     str_convert((<span class="keywordtype">long</span>)total_hash_object_busy_size) + <span class="stringliteral">&quot;b\n&quot;</span>;
<a name="l04508"></a>04508   s += std::string(<span class="stringliteral">&quot;Total hash object count: &quot;</span>) + 
<a name="l04509"></a>04509     str_convert((<span class="keywordtype">long</span>)total_hash_object_count) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04510"></a>04510   s += std::string(<span class="stringliteral">&quot;Total hash object size: &quot;</span>) +
<a name="l04511"></a>04511     str_convert((<span class="keywordtype">long</span>)total_hash_object_size) + <span class="stringliteral">&quot;b\n&quot;</span>;
<a name="l04512"></a>04512   s += std::string(<span class="stringliteral">&quot;Busy entry count: &quot;</span>) +
<a name="l04513"></a>04513     str_convert((<span class="keywordtype">long</span>)busy_key_count) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04514"></a>04514   s += std::string(<span class="stringliteral">&quot;Free entry count: &quot;</span>) +
<a name="l04515"></a>04515     str_convert((<span class="keywordtype">long</span>)free_key_count) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l04516"></a>04516   <span class="keywordflow">return</span> s;
<a name="l04517"></a>04517 }
<a name="l04518"></a>04518 
<a name="l04519"></a>04519 <span class="keywordtype">void</span>
<a name="l04520"></a>04520 HIdx::Stats::trace(Boolean full, FILE *fd)<span class="keyword"> const</span>
<a name="l04521"></a>04521 <span class="keyword"></span>{
<a name="l04522"></a>04522   idx.trace(fd);
<a name="l04523"></a>04523   Entry *entry = entries;
<a name="l04524"></a>04524 
<a name="l04525"></a>04525   <span class="keywordflow">if</span> (full) {
<a name="l04526"></a>04526     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; idx.key_count; i++, entry++)
<a name="l04527"></a>04527       <span class="keywordflow">if</span> (entry-&gt;object_count) {
<a name="l04528"></a>04528         fprintf(fd, <span class="stringliteral">&quot;Entry #%d {\n&quot;</span>, i);
<a name="l04529"></a>04529         fprintf(fd, <span class="stringliteral">&quot;\tObject count: %d\n&quot;</span>, entry-&gt;object_count);
<a name="l04530"></a>04530         fprintf(fd, <span class="stringliteral">&quot;\tHash object count: %d\n&quot;</span>, entry-&gt;hash_object_count);
<a name="l04531"></a>04531         fprintf(fd, <span class="stringliteral">&quot;\tHash object size: %db\n&quot;</span>, entry-&gt;hash_object_size);
<a name="l04532"></a>04532         fprintf(fd, <span class="stringliteral">&quot;\tHash object busy size: %db\n&quot;</span>, entry-&gt;hash_object_busy_size);
<a name="l04533"></a>04533         fprintf(fd, <span class="stringliteral">&quot;}\n&quot;</span>);
<a name="l04534"></a>04534       }
<a name="l04535"></a>04535     fprintf(fd, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l04536"></a>04536   }
<a name="l04537"></a>04537 
<a name="l04538"></a>04538   fprintf(fd, <span class="stringliteral">&quot;Min objects per entry: %d\n&quot;</span>, min_objects_per_entry);
<a name="l04539"></a>04539   fprintf(fd, <span class="stringliteral">&quot;Max objects per entry: %d\n&quot;</span>, max_objects_per_entry);
<a name="l04540"></a>04540   fprintf(fd, <span class="stringliteral">&quot;Total object count: %d\n&quot;</span>, total_object_count);
<a name="l04541"></a>04541   fprintf(fd, <span class="stringliteral">&quot;Total hash object count: %d\n&quot;</span>, total_hash_object_count);
<a name="l04542"></a>04542   fprintf(fd, <span class="stringliteral">&quot;Total hash object size: %db\n&quot;</span>, total_hash_object_size);
<a name="l04543"></a>04543   fprintf(fd, <span class="stringliteral">&quot;Total hash object busy size: %db\n&quot;</span>, total_hash_object_busy_size);
<a name="l04544"></a>04544   fprintf(fd, <span class="stringliteral">&quot;Busy entry count: %d\n&quot;</span>, busy_key_count);
<a name="l04545"></a>04545   fprintf(fd, <span class="stringliteral">&quot;Free entry count: %d\n&quot;</span>, free_key_count);
<a name="l04546"></a>04546 }
<a name="l04547"></a>04547 
<a name="l04548"></a>04548 HIdx::Stats::~Stats()
<a name="l04549"></a>04549 {
<a name="l04550"></a>04550   <span class="keyword">delete</span> [] entries;
<a name="l04551"></a>04551 }
<a name="l04552"></a>04552 
<a name="l04553"></a>04553 Status
<a name="l04554"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a61d870226eb26716189be5d45459a357">04554</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a61d870226eb26716189be5d45459a357" title="Not yet documented.">HIdx::copy</a>(<a class="code" href="classeyedbsm_1_1HIdx.html" title="Not yet documented.">HIdx</a> *&amp;idx_n, <span class="keywordtype">int</span> key_count, <span class="keywordtype">int</span> mag_order, <span class="keywordtype">short</span> dspid,
<a name="l04555"></a>04555               <span class="keyword">const</span> <span class="keywordtype">int</span> *impl_hints, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> impl_hints_cnt,
<a name="l04556"></a>04556               hash_key_t _hash_key,
<a name="l04557"></a>04557               <span class="keywordtype">void</span> *_hash_data, KeyType *ktype)<span class="keyword"> const</span>
<a name="l04558"></a>04558 <span class="keyword"></span>{
<a name="l04559"></a>04559   key_count = (key_count &gt; MaxKeys ? MaxKeys : key_count);
<a name="l04560"></a>04560 
<a name="l04561"></a>04561   idx_n = <span class="keyword">new</span> <a class="code" href="classeyedbsm_1_1HIdx.html#a550ece58eb70ec91d93d4b586b95666d" title="Not yet documented.">HIdx</a>(dbh, (ktype ? *ktype : <a class="code" href="classeyedbsm_1_1HIdx.html#a759e4f02cbe7fb9c489328872ffb6ba9" title="Not yet documented.">getKeyType</a>()), hidx.datasz,
<a name="l04562"></a>04562                       (dspid == DefaultDspid ? hidx.dspid : dspid),
<a name="l04563"></a>04563                       (mag_order == 0 ? hidx.mag_order : mag_order),
<a name="l04564"></a>04564                       key_count,
<a name="l04565"></a>04565                       (impl_hints == 0 ? hidx.impl_hints : impl_hints),
<a name="l04566"></a>04566                       (impl_hints == 0 ? HIdxImplHintsCount : impl_hints_cnt));
<a name="l04567"></a>04567 
<a name="l04568"></a>04568   <span class="keywordflow">if</span> (idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a7bd8908faa60890c69a91e4904fb780a" title="Not yet documented.">status</a>())
<a name="l04569"></a>04569     <span class="keywordflow">return</span> idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a7bd8908faa60890c69a91e4904fb780a" title="Not yet documented.">status</a>();
<a name="l04570"></a>04570 
<a name="l04571"></a>04571   idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#ad63311b1209b685bfdf8a23e34c18b52" title="Not yet documented.">open</a>(_hash_key, _hash_data);
<a name="l04572"></a>04572   
<a name="l04573"></a>04573   <span class="keywordflow">return</span> copy_realize(idx_n);
<a name="l04574"></a>04574 }
<a name="l04575"></a>04575 
<a name="l04576"></a>04576 Status
<a name="l04577"></a>04577 HIdx::copy_realize(Idx *idx)<span class="keyword"> const</span>
<a name="l04578"></a>04578 <span class="keyword"></span>{
<a name="l04579"></a>04579   Status s = Success;
<a name="l04580"></a>04580   <a class="code" href="classeyedbsm_1_1HIdxCursor.html" title="Not yet documented.">HIdxCursor</a> curs(<span class="keyword">this</span>);
<a name="l04581"></a>04581   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[hidx.datasz];
<a name="l04582"></a>04582 
<a name="l04583"></a>04583   <span class="keywordflow">for</span> (;;) {
<a name="l04584"></a>04584     Boolean found;
<a name="l04585"></a>04585     Idx::Key key;
<a name="l04586"></a>04586 
<a name="l04587"></a>04587     s = curs.next(&amp;found, data, &amp;key);
<a name="l04588"></a>04588     <span class="keywordflow">if</span> (s) <span class="keywordflow">goto</span> error;
<a name="l04589"></a>04589 
<a name="l04590"></a>04590     <span class="keywordflow">if</span> (!found) <span class="keywordflow">break</span>;
<a name="l04591"></a>04591 
<a name="l04592"></a>04592     s = idx-&gt;insert(key.getKey(), data);
<a name="l04593"></a>04593     <span class="keywordflow">if</span> (s) <span class="keywordflow">goto</span> error;
<a name="l04594"></a>04594   }
<a name="l04595"></a>04595 
<a name="l04596"></a>04596  error:
<a name="l04597"></a>04597   <span class="keyword">delete</span> [] data;
<a name="l04598"></a>04598   <span class="keywordflow">return</span> s;
<a name="l04599"></a>04599 }
<a name="l04600"></a>04600 
<a name="l04601"></a>04601 Status
<a name="l04602"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a38d54561d762c58b656085e9ec4b472f">04602</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a38d54561d762c58b656085e9ec4b472f" title="Not yet documented.">HIdx::reimplementToBTree</a>(Oid &amp;newoid, <span class="keywordtype">int</span> degree, <span class="keywordtype">short</span> dspid)
<a name="l04603"></a>04603 {
<a name="l04604"></a>04604   <a class="code" href="classeyedbsm_1_1BIdx.html" title="Not yet documented.">BIdx</a> bidx(dbh, hidx.datasz, &amp;keytype,
<a name="l04605"></a>04605                (dspid == DefaultDspid ? hidx.dspid : dspid),
<a name="l04606"></a>04606                degree, 1);
<a name="l04607"></a>04607 
<a name="l04608"></a>04608   <span class="keywordflow">if</span> (bidx.<a class="code" href="classeyedbsm_1_1BIdx.html#a0adf9a5605fae8bf2e9b4282907c522e" title="Not yet documented.">status</a>())
<a name="l04609"></a>04609     <span class="keywordflow">return</span> bidx.<a class="code" href="classeyedbsm_1_1BIdx.html#a0adf9a5605fae8bf2e9b4282907c522e" title="Not yet documented.">status</a>();
<a name="l04610"></a>04610 
<a name="l04611"></a>04611   bidx.<a class="code" href="classeyedbsm_1_1BIdx.html#a7f680b37492e53f1c196f7ed679aba05" title="Not yet documented.">open</a>();
<a name="l04612"></a>04612 
<a name="l04613"></a>04613   Status s = copy_realize(&amp;bidx);
<a name="l04614"></a>04614   <span class="keywordflow">if</span> (s)
<a name="l04615"></a>04615     <span class="keywordflow">return</span> s;
<a name="l04616"></a>04616   s = <a class="code" href="classeyedbsm_1_1HIdx.html#a5d0f946b0e687d888e0da37a25dcca3b" title="Not yet documented.">destroy</a>();
<a name="l04617"></a>04617   <span class="keywordflow">if</span> (s)
<a name="l04618"></a>04618     <span class="keywordflow">return</span> s;
<a name="l04619"></a>04619 
<a name="l04620"></a>04620   newoid = bidx.<a class="code" href="classeyedbsm_1_1BIdx.html#af803a037365197922ae5e2d8e9b70042" title="Not yet documented.">oid</a>();
<a name="l04621"></a>04621   <span class="keywordflow">return</span> Success;
<a name="l04622"></a>04622 }
<a name="l04623"></a>04623 
<a name="l04624"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a384583150d8d84ec2a67df41ee8cf14c">04624</a> Status <a class="code" href="classeyedbsm_1_1HIdx.html#a384583150d8d84ec2a67df41ee8cf14c" title="Not yet documented.">HIdx::move</a>(<span class="keywordtype">short</span> dspid, eyedbsm::Oid &amp;newoid,
<a name="l04625"></a>04625                   hash_key_t hash_key, <span class="keywordtype">void</span> *hash_data)
<a name="l04626"></a>04626 {
<a name="l04627"></a>04627   <span class="comment">// for now</span>
<a name="l04628"></a>04628   <span class="comment">/*</span>
<a name="l04629"></a>04629 <span class="comment">  return reimplementToHash(newoid, hidx.key_count, hidx.mag_order, dspid, hidx.impl_hints, HIdxImplHintsCount, hash_key, hash_data);</span>
<a name="l04630"></a>04630 <span class="comment">  */</span>
<a name="l04631"></a>04631   <span class="comment">// construction d&apos;un index comme dans copy</span>
<a name="l04632"></a>04632   <span class="comment">// parcours de tous les objets comme dans collapse, puis writeCListHeader sur le nouvel index, sans destruction (le destroy se fait ensuite) =&gt; en fait, il faut dupliquer collapse, c&apos;est trop different</span>
<a name="l04633"></a>04633   <span class="comment">// note: le collapse est-il obligatoire ? ou bien c&apos;est une option a ajouter dans le mvidx et a passer a Index::move puis a Index::realize (via les UserData) ?</span>
<a name="l04634"></a>04634   <span class="comment">// dans un 1er temps, on peut le faire obligatoire</span>
<a name="l04635"></a>04635 <span class="preprocessor">#if 1</span>
<a name="l04636"></a>04636 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (getenv(<span class="stringliteral">&quot;MOVE_IS_COLLAPSE&quot;</span>)) {
<a name="l04637"></a>04637     printf(<span class="stringliteral">&quot;move is collapse only\n&quot;</span>);
<a name="l04638"></a>04638     newoid = <a class="code" href="classeyedbsm_1_1HIdx.html#a1394aa7916e5cb8214280f96d6cce83a" title="Not yet documented.">oid</a>();
<a name="l04639"></a>04639     <span class="keywordflow">return</span> <a class="code" href="classeyedbsm_1_1HIdx.html#a53a17768b3c1414673efff597c0c18d3" title="Not yet documented.">collapse</a>();
<a name="l04640"></a>04640   }
<a name="l04641"></a>04641 <span class="preprocessor">#endif</span>
<a name="l04642"></a>04642 <span class="preprocessor"></span>
<a name="l04643"></a>04643   <a class="code" href="classeyedbsm_1_1HIdx.html" title="Not yet documented.">HIdx</a> *idx_n = <span class="keyword">new</span> <a class="code" href="classeyedbsm_1_1HIdx.html#a550ece58eb70ec91d93d4b586b95666d" title="Not yet documented.">HIdx</a>(dbh,
<a name="l04644"></a>04644                          <a class="code" href="classeyedbsm_1_1HIdx.html#a759e4f02cbe7fb9c489328872ffb6ba9" title="Not yet documented.">getKeyType</a>(),
<a name="l04645"></a>04645                          hidx.datasz,
<a name="l04646"></a>04646                          dspid,
<a name="l04647"></a>04647                          hidx.mag_order,
<a name="l04648"></a>04648                          hidx.key_count,
<a name="l04649"></a>04649                          hidx.impl_hints,
<a name="l04650"></a>04650                          HIdxImplHintsCount);
<a name="l04651"></a>04651 
<a name="l04652"></a>04652   <span class="keywordflow">if</span> (idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a7bd8908faa60890c69a91e4904fb780a" title="Not yet documented.">status</a>())
<a name="l04653"></a>04653     <span class="keywordflow">return</span> idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a7bd8908faa60890c69a91e4904fb780a" title="Not yet documented.">status</a>();
<a name="l04654"></a>04654 
<a name="l04655"></a>04655   idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#ad63311b1209b685bfdf8a23e34c18b52" title="Not yet documented.">open</a>(hash_key, hash_data);
<a name="l04656"></a>04656 
<a name="l04657"></a>04657   IdxLock lockx_n(dbh, idx_n-&gt;treeoid);
<a name="l04658"></a>04658   Status s = lockx_n.lock();
<a name="l04659"></a>04659   <span class="keywordflow">if</span> (s)
<a name="l04660"></a>04660     <span class="keywordflow">return</span> s;
<a name="l04661"></a>04661 
<a name="l04662"></a>04662 <span class="preprocessor">#if 0</span>
<a name="l04663"></a>04663 <span class="preprocessor"></span>  s = copy_realize(idx_n);
<a name="l04664"></a>04664 <span class="preprocessor">#else</span>
<a name="l04665"></a>04665 <span class="preprocessor"></span>  s = collapse_realize(dspid, idx_n);
<a name="l04666"></a>04666 <span class="preprocessor">#endif</span>
<a name="l04667"></a>04667 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (s)
<a name="l04668"></a>04668     <span class="keywordflow">return</span> s;
<a name="l04669"></a>04669 
<a name="l04670"></a>04670   s = <a class="code" href="classeyedbsm_1_1HIdx.html#a5d0f946b0e687d888e0da37a25dcca3b" title="Not yet documented.">destroy</a>();
<a name="l04671"></a>04671   <span class="keywordflow">if</span> (s)
<a name="l04672"></a>04672     <span class="keywordflow">return</span> s;
<a name="l04673"></a>04673 
<a name="l04674"></a>04674   newoid = idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a1394aa7916e5cb8214280f96d6cce83a" title="Not yet documented.">oid</a>();
<a name="l04675"></a>04675 
<a name="l04676"></a>04676   <span class="keyword">delete</span> idx_n;
<a name="l04677"></a>04677 
<a name="l04678"></a>04678   <span class="keywordflow">return</span> Success;
<a name="l04679"></a>04679 }
<a name="l04680"></a>04680 
<a name="l04681"></a>04681 Status
<a name="l04682"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a24cc0af476fda37816e1849c0a3eadac">04682</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a24cc0af476fda37816e1849c0a3eadac" title="Not yet documented.">HIdx::reimplementToHash</a>(Oid &amp;newoid, <span class="keywordtype">int</span> key_count, <span class="keywordtype">int</span> mag_order,
<a name="l04683"></a>04683                            <span class="keywordtype">short</span> dspid, <span class="keyword">const</span> <span class="keywordtype">int</span> *impl_hints,
<a name="l04684"></a>04684                            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> impl_hints_cnt,
<a name="l04685"></a>04685                            hash_key_t _hash_key, <span class="keywordtype">void</span> *_hash_data,
<a name="l04686"></a>04686                            KeyType *ktype)
<a name="l04687"></a>04687 {
<a name="l04688"></a>04688   IdxLock lockx(dbh, treeoid);
<a name="l04689"></a>04689   Status s = lockx.lock();
<a name="l04690"></a>04690   <span class="keywordflow">if</span> (s)
<a name="l04691"></a>04691     <span class="keywordflow">return</span> s;
<a name="l04692"></a>04692 
<a name="l04693"></a>04693   printf(<span class="stringliteral">&quot;reimplementToHash:\n&quot;</span>);
<a name="l04694"></a>04694   printf(<span class="stringliteral">&quot;OLD: kc: %d dspid: %d hints: %d %d %d %d %d %d\n&quot;</span>, hidx.key_count, hidx.dspid, hidx.impl_hints[0],hidx.impl_hints[1],hidx.impl_hints[2],hidx.impl_hints[3],hidx.impl_hints[4],hidx.impl_hints[5],hidx.impl_hints[6]);
<a name="l04695"></a>04695   printf(<span class="stringliteral">&quot;NEW: kc: %d dspid: %d hints: %d %d %d %d %d %d\n&quot;</span>, key_count, dspid, impl_hints[0],impl_hints[1],impl_hints[2],impl_hints[3],impl_hints[4],impl_hints[5],impl_hints[6]);
<a name="l04696"></a>04696 
<a name="l04697"></a>04697   <span class="comment">// si tous les parametres sont identiques sauf le dspid, alors il suffit de</span>
<a name="l04698"></a>04698   <span class="comment">// reorganiser l&apos;index, et il ne faut pas le reimplementer !</span>
<a name="l04699"></a>04699 
<a name="l04700"></a>04700   <a class="code" href="classeyedbsm_1_1HIdx.html" title="Not yet documented.">HIdx</a> *idx_n = 0;
<a name="l04701"></a>04701   s = <a class="code" href="classeyedbsm_1_1HIdx.html#a61d870226eb26716189be5d45459a357" title="Not yet documented.">copy</a>(idx_n, key_count, mag_order, dspid, impl_hints,
<a name="l04702"></a>04702            impl_hints_cnt, _hash_key, _hash_data, ktype);
<a name="l04703"></a>04703   <span class="keywordflow">if</span> (s)
<a name="l04704"></a>04704     <span class="keywordflow">return</span> s;
<a name="l04705"></a>04705 
<a name="l04706"></a>04706   s = <a class="code" href="classeyedbsm_1_1HIdx.html#a5d0f946b0e687d888e0da37a25dcca3b" title="Not yet documented.">destroy</a>();
<a name="l04707"></a>04707   <span class="keywordflow">if</span> (s)
<a name="l04708"></a>04708     <span class="keywordflow">return</span> s;
<a name="l04709"></a>04709   newoid = idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a1394aa7916e5cb8214280f96d6cce83a" title="Not yet documented.">oid</a>();
<a name="l04710"></a>04710   <span class="keyword">delete</span> idx_n;
<a name="l04711"></a>04711   <span class="keywordflow">return</span> Success;
<a name="l04712"></a>04712 }
<a name="l04713"></a>04713 
<a name="l04714"></a>04714 Status
<a name="l04715"></a><a class="code" href="classeyedbsm_1_1HIdx.html#a02421404f1d8338bb1be9ef1ff7106d4">04715</a> <a class="code" href="classeyedbsm_1_1HIdx.html#a02421404f1d8338bb1be9ef1ff7106d4" title="Not yet documented.">HIdx::simulate</a>(Stats &amp;stats, <span class="keywordtype">int</span> key_count, <span class="keywordtype">int</span> mag_order,
<a name="l04716"></a>04716                   <span class="keyword">const</span> <span class="keywordtype">int</span> *impl_hints, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> impl_hints_cnt,
<a name="l04717"></a>04717                   hash_key_t _hash_key,
<a name="l04718"></a>04718                   <span class="keywordtype">void</span> *_hash_data)<span class="keyword"> const</span>
<a name="l04719"></a>04719 <span class="keyword"></span>{
<a name="l04720"></a>04720   <a class="code" href="classeyedbsm_1_1HIdx.html" title="Not yet documented.">HIdx</a> *idx_n;
<a name="l04721"></a>04721   Status s = <a class="code" href="classeyedbsm_1_1HIdx.html#a61d870226eb26716189be5d45459a357" title="Not yet documented.">copy</a>(idx_n, key_count, mag_order, hidx.dspid, impl_hints,
<a name="l04722"></a>04722                      impl_hints_cnt, _hash_key, _hash_data, 0);
<a name="l04723"></a>04723   <span class="keywordflow">if</span> (s)
<a name="l04724"></a>04724     <span class="keywordflow">return</span> s;
<a name="l04725"></a>04725 
<a name="l04726"></a>04726   s = idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a328cc50cf1e6ab2148dba572d60a90b8" title="Not yet documented.">getStats</a>(stats);
<a name="l04727"></a>04727   idx_n-&gt;<a class="code" href="classeyedbsm_1_1HIdx.html#a5d0f946b0e687d888e0da37a25dcca3b" title="Not yet documented.">destroy</a>();
<a name="l04728"></a>04728   <span class="keyword">delete</span> idx_n;
<a name="l04729"></a>04729   <span class="keywordflow">return</span> s;
<a name="l04730"></a>04730 }
<a name="l04731"></a>04731 
<a name="l04732"></a>04732 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_idx(HIdx::_Idx *idx)
<a name="l04733"></a>04733 {
<a name="l04734"></a>04734 <span class="preprocessor">#ifdef HIDX_XDR</span>
<a name="l04735"></a>04735 <span class="preprocessor"></span>  idx-&gt;idxtype = x2h_u32(idx-&gt;idxtype);
<a name="l04736"></a>04736   idx-&gt;object_count = x2h_u32(idx-&gt;object_count);
<a name="l04737"></a>04737   idx-&gt;mag_order = x2h_u32(idx-&gt;mag_order);
<a name="l04738"></a>04738   idx-&gt;key_count = x2h_u32(idx-&gt;key_count);
<a name="l04739"></a>04739   idx-&gt;dspid = x2h_16(idx-&gt;dspid);
<a name="l04740"></a>04740   idx-&gt;keytype = x2h_u32(idx-&gt;keytype);
<a name="l04741"></a>04741   idx-&gt;keysz = x2h_u32(idx-&gt;keysz);
<a name="l04742"></a>04742   idx-&gt;datasz = x2h_u32(idx-&gt;datasz);
<a name="l04743"></a>04743   idx-&gt;offset = x2h_u32(idx-&gt;offset);
<a name="l04744"></a>04744   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; HIdxImplHintsCount; i++)
<a name="l04745"></a>04745     idx-&gt;impl_hints[i] = x2h_u32(idx-&gt;impl_hints[i]);
<a name="l04746"></a>04746 <span class="preprocessor">#endif</span>
<a name="l04747"></a>04747 <span class="preprocessor"></span>}
<a name="l04748"></a>04748 
<a name="l04749"></a>04749 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_idx(HIdx::_Idx *xidx, <span class="keyword">const</span> HIdx::_Idx *hidx)
<a name="l04750"></a>04750 {
<a name="l04751"></a>04751 <span class="preprocessor">#ifdef HIDX_XDR</span>
<a name="l04752"></a>04752 <span class="preprocessor"></span>  xidx-&gt;idxtype = h2x_u32(hidx-&gt;idxtype);
<a name="l04753"></a>04753   xidx-&gt;object_count = h2x_u32(hidx-&gt;object_count);
<a name="l04754"></a>04754   xidx-&gt;mag_order = h2x_u32(hidx-&gt;mag_order);
<a name="l04755"></a>04755   xidx-&gt;key_count = h2x_u32(hidx-&gt;key_count);
<a name="l04756"></a>04756   xidx-&gt;dspid = h2x_16(hidx-&gt;dspid);
<a name="l04757"></a>04757   xidx-&gt;keytype = h2x_u32(hidx-&gt;keytype);
<a name="l04758"></a>04758   xidx-&gt;keysz = h2x_u32(hidx-&gt;keysz);
<a name="l04759"></a>04759   xidx-&gt;datasz = h2x_u32(hidx-&gt;datasz);
<a name="l04760"></a>04760   xidx-&gt;offset = h2x_u32(hidx-&gt;offset);
<a name="l04761"></a>04761   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; HIdxImplHintsCount; i++)
<a name="l04762"></a>04762     xidx-&gt;impl_hints[i] = h2x_u32(hidx-&gt;impl_hints[i]);
<a name="l04763"></a>04763 <span class="preprocessor">#else</span>
<a name="l04764"></a>04764 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (xidx != hidx)
<a name="l04765"></a>04765     memcpy(xidx, hidx, <span class="keyword">sizeof</span>(*xidx));
<a name="l04766"></a>04766 <span class="preprocessor">#endif</span>
<a name="l04767"></a>04767 <span class="preprocessor"></span>}
<a name="l04768"></a>04768 
<a name="l04769"></a>04769 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_chd(HIdx::CListHeader *chd)
<a name="l04770"></a>04770 {
<a name="l04771"></a>04771 <span class="preprocessor">#ifdef HIDX_XDR</span>
<a name="l04772"></a>04772 <span class="preprocessor"></span>  x2h_oid(&amp;chd-&gt;clobj_first, &amp;chd-&gt;clobj_first);
<a name="l04773"></a>04773   x2h_oid(&amp;chd-&gt;clobj_last, &amp;chd-&gt;clobj_last);
<a name="l04774"></a>04774   x2h_oid(&amp;chd-&gt;clobj_free_first, &amp;chd-&gt;clobj_free_first);
<a name="l04775"></a>04775 <span class="preprocessor">#endif</span>
<a name="l04776"></a>04776 <span class="preprocessor"></span>}
<a name="l04777"></a>04777 
<a name="l04778"></a>04778 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_chd(HIdx::CListHeader *xchd, <span class="keyword">const</span> HIdx::CListHeader *hchd)
<a name="l04779"></a>04779 {
<a name="l04780"></a>04780 <span class="preprocessor">#ifdef HIDX_XDR</span>
<a name="l04781"></a>04781 <span class="preprocessor"></span>  h2x_oid(&amp;xchd-&gt;clobj_first, &amp;hchd-&gt;clobj_first);
<a name="l04782"></a>04782   h2x_oid(&amp;xchd-&gt;clobj_last, &amp;hchd-&gt;clobj_last);
<a name="l04783"></a>04783   h2x_oid(&amp;xchd-&gt;clobj_free_first, &amp;hchd-&gt;clobj_free_first);
<a name="l04784"></a>04784 <span class="preprocessor">#else</span>
<a name="l04785"></a>04785 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (xchd != hchd)
<a name="l04786"></a>04786     memcpy(xchd, hchd, <span class="keyword">sizeof</span>(*xchd));
<a name="l04787"></a>04787 <span class="preprocessor">#endif</span>
<a name="l04788"></a>04788 <span class="preprocessor"></span>}
<a name="l04789"></a>04789 
<a name="l04790"></a>04790 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_header(HIdx::CListObjHeader *h)
<a name="l04791"></a>04791 {
<a name="l04792"></a>04792 <span class="preprocessor">#ifdef HIDX_XDR</span>
<a name="l04793"></a>04793 <span class="preprocessor"></span>  h-&gt;size = x2h_32(h-&gt;size);
<a name="l04794"></a>04794   h-&gt;free_cnt = x2h_u16(h-&gt;free_cnt);
<a name="l04795"></a>04795   h-&gt;alloc_cnt = x2h_u16(h-&gt;alloc_cnt);
<a name="l04796"></a>04796   h-&gt;free_whole = x2h_u32(h-&gt;free_whole);
<a name="l04797"></a>04797   h-&gt;cell_free_first = x2h_u32(h-&gt;cell_free_first);
<a name="l04798"></a>04798   x2h_oid(&amp;h-&gt;clobj_free_prev, &amp;h-&gt;clobj_free_prev);
<a name="l04799"></a>04799   x2h_oid(&amp;h-&gt;clobj_free_next, &amp;h-&gt;clobj_free_next);
<a name="l04800"></a>04800   x2h_oid(&amp;h-&gt;clobj_prev, &amp;h-&gt;clobj_prev);
<a name="l04801"></a>04801   x2h_oid(&amp;h-&gt;clobj_next, &amp;h-&gt;clobj_next);
<a name="l04802"></a>04802 <span class="preprocessor">#endif</span>
<a name="l04803"></a>04803 <span class="preprocessor"></span>}
<a name="l04804"></a>04804 
<a name="l04805"></a>04805 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_header(HIdx::CListObjHeader *xh, <span class="keyword">const</span> HIdx::CListObjHeader *hh)
<a name="l04806"></a>04806 {
<a name="l04807"></a>04807 <span class="preprocessor">#ifdef HIDX_XDR</span>
<a name="l04808"></a>04808 <span class="preprocessor"></span>  xh-&gt;size = h2x_32(hh-&gt;size);
<a name="l04809"></a>04809   xh-&gt;free_cnt = h2x_u16(hh-&gt;free_cnt);
<a name="l04810"></a>04810   xh-&gt;alloc_cnt = h2x_u16(hh-&gt;alloc_cnt);
<a name="l04811"></a>04811   xh-&gt;free_whole = h2x_u32(hh-&gt;free_whole);
<a name="l04812"></a>04812   xh-&gt;cell_free_first = h2x_32(hh-&gt;cell_free_first);
<a name="l04813"></a>04813   h2x_oid(&amp;xh-&gt;clobj_free_prev, &amp;hh-&gt;clobj_free_prev);
<a name="l04814"></a>04814   h2x_oid(&amp;xh-&gt;clobj_free_next, &amp;hh-&gt;clobj_free_next);
<a name="l04815"></a>04815   h2x_oid(&amp;xh-&gt;clobj_prev, &amp;hh-&gt;clobj_prev);
<a name="l04816"></a>04816   h2x_oid(&amp;xh-&gt;clobj_next, &amp;hh-&gt;clobj_next);
<a name="l04817"></a>04817 <span class="preprocessor">#else</span>
<a name="l04818"></a>04818 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (xh != hh)
<a name="l04819"></a>04819     memcpy(xh, hh, <span class="keyword">sizeof</span>(*xh));
<a name="l04820"></a>04820 <span class="preprocessor">#endif</span>
<a name="l04821"></a>04821 <span class="preprocessor"></span>}
<a name="l04822"></a>04822 
<a name="l04823"></a>04823 <span class="keyword">static</span> <span class="keywordtype">void</span> x2h_overhead(HIdx::CellHeader *o)
<a name="l04824"></a>04824 {
<a name="l04825"></a>04825 <span class="preprocessor">#ifdef HIDX_XDR_OVERHEAD</span>
<a name="l04826"></a>04826 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x;
<a name="l04827"></a>04827   mcp(&amp;x, o, <span class="keyword">sizeof</span>(x));
<a name="l04828"></a>04828   x = x2h_u32(x);
<a name="l04829"></a>04829   o-&gt;free = x &gt;&gt; 31;
<a name="l04830"></a>04830   o-&gt;size = x &amp; 0xefffffff;
<a name="l04831"></a>04831   o-&gt;cell_free_next = x2h_32(o-&gt;cell_free_next);
<a name="l04832"></a>04832   o-&gt;cell_free_prev = x2h_32(o-&gt;cell_free_prev);
<a name="l04833"></a>04833 <span class="preprocessor">#endif</span>
<a name="l04834"></a>04834 <span class="preprocessor"></span>}
<a name="l04835"></a>04835 
<a name="l04836"></a>04836 <span class="keyword">static</span> <span class="keywordtype">void</span> h2x_overhead(HIdx::CellHeader *xo, <span class="keyword">const</span> HIdx::CellHeader *ho)
<a name="l04837"></a>04837 {
<a name="l04838"></a>04838 <span class="preprocessor">#ifdef HIDX_XDR_OVERHEAD</span>
<a name="l04839"></a>04839 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = h2x_u32((ho-&gt;free &lt;&lt; 31) | ho-&gt;size);
<a name="l04840"></a>04840   mcp(xo, &amp;x, <span class="keyword">sizeof</span>(x));
<a name="l04841"></a>04841   xo-&gt;cell_free_next = h2x_32(ho-&gt;cell_free_next);
<a name="l04842"></a>04842   xo-&gt;cell_free_prev = h2x_32(ho-&gt;cell_free_prev);
<a name="l04843"></a>04843 <span class="preprocessor">#else</span>
<a name="l04844"></a>04844 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (xo != ho)
<a name="l04845"></a>04845     memcpy(xo, ho, <span class="keyword">sizeof</span>(*xo));
<a name="l04846"></a>04846 <span class="preprocessor">#endif</span>
<a name="l04847"></a>04847 <span class="preprocessor"></span>}
<a name="l04848"></a>04848 
<a name="l04849"></a>04849 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> out_of_bounds_fmt[] =
<a name="l04850"></a>04850 <span class="stringliteral">&quot;out of bounds data grouped sizeof: maximum data count per key is %u&quot;</span>;
<a name="l04851"></a>04851 
<a name="l04852"></a>04852 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> unsupported_sizeof_fmt[] =
<a name="l04853"></a>04853 <span class="stringliteral">&quot;unsupported data grouped sizeof in hash index %u&quot;</span>;
<a name="l04854"></a>04854 
<a name="l04855"></a>04855 <span class="keyword">static</span> Status out_of_bounds(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data_grouped_sizeof)
<a name="l04856"></a>04856 {
<a name="l04857"></a>04857   <span class="keywordflow">return</span> statusMake(ERROR, out_of_bounds_fmt,
<a name="l04858"></a>04858                     (1 &lt;&lt; (8 * data_grouped_sizeof)) - 1);
<a name="l04859"></a>04859 }
<a name="l04860"></a>04860 
<a name="l04861"></a>04861 Status HIdx::h2x_datacnt_cpy(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *rdata, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pdatacnt)<span class="keyword"> const</span>
<a name="l04862"></a>04862 <span class="keyword"></span>{
<a name="l04863"></a>04863   <span class="keywordflow">if</span> (data_grouped_sizeof == 4) {
<a name="l04864"></a>04864     h2x_32_cpy(rdata, pdatacnt);
<a name="l04865"></a>04865     <span class="keywordflow">return</span> Success;
<a name="l04866"></a>04866   }
<a name="l04867"></a>04867 
<a name="l04868"></a>04868   <span class="keywordflow">if</span> (data_grouped_sizeof == 2) {
<a name="l04869"></a>04869     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> sdatacnt = *pdatacnt;
<a name="l04870"></a>04870     <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)sdatacnt != *pdatacnt) {
<a name="l04871"></a>04871       <span class="keywordflow">return</span> out_of_bounds(data_grouped_sizeof);
<a name="l04872"></a>04872     }
<a name="l04873"></a>04873     h2x_16_cpy(rdata, &amp;sdatacnt);
<a name="l04874"></a>04874     <span class="keywordflow">return</span> Success;
<a name="l04875"></a>04875   }
<a name="l04876"></a>04876 
<a name="l04877"></a>04877   <span class="keywordflow">if</span> (data_grouped_sizeof == 1) {
<a name="l04878"></a>04878     *rdata = *pdatacnt;
<a name="l04879"></a>04879     <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)*rdata != *pdatacnt) {
<a name="l04880"></a>04880       <span class="keywordflow">return</span> out_of_bounds(data_grouped_sizeof);
<a name="l04881"></a>04881     }
<a name="l04882"></a>04882 
<a name="l04883"></a>04883     <span class="keywordflow">return</span> Success;
<a name="l04884"></a>04884   }
<a name="l04885"></a>04885 
<a name="l04886"></a>04886   <span class="keywordflow">return</span> statusMake(ERROR, unsupported_sizeof_fmt, data_grouped_sizeof);
<a name="l04887"></a>04887 }
<a name="l04888"></a>04888 
<a name="l04889"></a>04889 Status HIdx::x2h_datacnt_cpy(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pdatacnt, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pdata)<span class="keyword"> const</span>
<a name="l04890"></a>04890 <span class="keyword"></span>{
<a name="l04891"></a>04891   <span class="keywordflow">if</span> (data_grouped_sizeof == 4) {
<a name="l04892"></a>04892     x2h_32_cpy(pdatacnt, pdata);
<a name="l04893"></a>04893     <span class="keywordflow">return</span> Success;
<a name="l04894"></a>04894   }
<a name="l04895"></a>04895 
<a name="l04896"></a>04896   <span class="keywordflow">if</span> (data_grouped_sizeof == 2) {
<a name="l04897"></a>04897     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> sdatacnt;
<a name="l04898"></a>04898     x2h_16_cpy(&amp;sdatacnt, pdata);
<a name="l04899"></a>04899     *pdatacnt = sdatacnt;
<a name="l04900"></a>04900     <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)sdatacnt != *pdatacnt) {
<a name="l04901"></a>04901       <span class="keywordflow">return</span> out_of_bounds(data_grouped_sizeof);
<a name="l04902"></a>04902     }
<a name="l04903"></a>04903     <span class="keywordflow">return</span> Success;
<a name="l04904"></a>04904   }
<a name="l04905"></a>04905 
<a name="l04906"></a>04906   <span class="keywordflow">if</span> (data_grouped_sizeof == 1) {
<a name="l04907"></a>04907     *pdatacnt = *pdata;
<a name="l04908"></a>04908 
<a name="l04909"></a>04909     <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)*pdata != *pdatacnt) {
<a name="l04910"></a>04910       <span class="keywordflow">return</span> out_of_bounds(data_grouped_sizeof);
<a name="l04911"></a>04911     }
<a name="l04912"></a>04912 
<a name="l04913"></a>04913     <span class="keywordflow">return</span> Success;
<a name="l04914"></a>04914   }
<a name="l04915"></a>04915 
<a name="l04916"></a>04916   <span class="keywordflow">return</span> statusMake(ERROR, unsupported_sizeof_fmt, data_grouped_sizeof);
<a name="l04917"></a>04917 }
<a name="l04918"></a>04918 }
<a name="l04919"></a>04919 
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed May 26 10:24:59 2010 for eyedb by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
